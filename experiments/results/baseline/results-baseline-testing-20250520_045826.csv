day,approach,model,success,time_taken,code
1,single-model,gemini-2.0-flash,True,5.564193248748779,"""""""
Advent of Code 2016 Day 1: Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers, representing the left and right lists.
    """"""
    left_list: List[int] = []
    right_list: List[int] = []

    with open(input_file, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) == 2:
                try:
                    left_list.append(int(parts[0]))
                    right_list.append(int(parts[1]))
                except ValueError as e:
                    print(f""Error parsing input line: {line.strip()}\nError: {e}"", file=sys.stderr)
                    return [], [] # Or raise the exception
            else:
                print(f""Invalid input line format: {line.strip()}"", file=sys.stderr)
                return [], []  # or raise an exception

    return left_list, right_list


def solve_part_one(left_list: List[int], right_list: List[int]) -> int:
    """"""Solve part one of the puzzle: calculate the total distance between the two lists.

    Args:
        left_list: The list of integers from the left side.
        right_list: The list of integers from the right side.

    Returns:
        The total distance between the two lists.
    """"""
    if not left_list or not right_list:
        print(""One or both input lists are empty."", file=sys.stderr)
        return 0

    if len(left_list) != len(right_list):
        print(""Input lists have different lengths."", file=sys.stderr)
        # Handle lists of different lengths based on problem requirements.
        # For this particular problem, assuming we should stop if lists have different lengths.
        return 0

    total_distance = 0
    sorted_left = sorted(left_list)
    sorted_right = sorted(right_list)

    for i in range(len(sorted_left)):
        distance = abs(sorted_left[i] - sorted_right[i])
        total_distance += distance

    return total_distance


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    left_list, right_list = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(left_list, right_list)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
1,system,gemini-2.0-flash,True,45.201035022735596,"""""""
Advent of Code 2023 Day 1 (Hypothetical): Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers.
    """"""
    list1: List[int] = []
    list2: List[int] = []
    with open(input_file, 'r') as f:
        for line in f:
            nums = line.strip().split()
            if len(nums) != 2:
                raise ValueError(f""Invalid input line: {line}"")
            try:
                list1.append(int(nums[0]))
                list2.append(int(nums[1]))
            except ValueError:
                raise ValueError(f""Non-integer value found in line: {line}"")
    return list1, list2

def solve_part_one(list1: List[int], list2: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        list1: The first list of integers.
        list2: The second list of integers.

    Returns:
        The total distance between the two lists.
    """"""
    if len(list1) != len(list2):
        raise ValueError(""The two lists must have the same length."")

    sorted_list1 = sorted(list1)
    sorted_list2 = sorted(list2)

    distances: List[int] = []
    for i in range(len(sorted_list1)):
        distances.append(abs(sorted_list1[i] - sorted_list2[i]))

    total_distance = sum(distances)
    return total_distance

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    try:
        list1, list2 = parse_input(input_file)
    except ValueError as e:
        print(f""Error parsing input: {e}"")
        return

    # Solve part one
    try:
        part_one_solution = solve_part_one(list1, list2)
        # ONLY PRINT THE RESULT, NO OTHER TEXT
        print(part_one_solution)
    except ValueError as e:
        print(f""Error solving part one: {e}"")
        return


if __name__ == ""__main__"":
    main()
"
2,single-model,gemini-2.0-flash,True,4.877627372741699,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list where each element is a list of integers representing a report.
    """"""
    reports = []
    with open(input_file, 'r') as f:
        for line in f:
            reports.append([int(x) for x in line.strip().split()])
    return reports


def is_safe(report: List[int]) -> bool:
    """"""Check if a report is safe according to the given rules.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    if not report:
        return True  # Empty report is considered safe

    increasing = True
    decreasing = True

    for i in range(len(report) - 1):
        if report[i + 1] > report[i]:
            decreasing = False
        elif report[i + 1] < report[i]:
            increasing = False
        else:
            return False  # Levels are neither increasing nor decreasing

        diff = abs(report[i + 1] - report[i])
        if not (1 <= diff <= 3):
            return False  # Adjacent levels differ by more than 3 or less than 1

    return increasing or decreasing


def solve_part_one(reports: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        reports: A list of reports.

    Returns:
        The number of safe reports.
    """"""
    safe_count = 0
    for report in reports:
        if is_safe(report):
            safe_count += 1
    return safe_count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
2,system,gemini-2.0-flash,True,49.97616147994995,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists of integers, where each inner list represents a report.
    """"""
    reports = []
    with open(input_file, 'r') as f:
        for line in f:
            report = [int(level) for level in line.strip().split()]
            reports.append(report)
    return reports


def check_monotonicity(report: List[int]) -> bool:
    """"""Check if a report is strictly increasing or strictly decreasing.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is strictly increasing or strictly decreasing, False otherwise.
    """"""
    if len(report) <= 1:  # Edge case: Report with 0 or 1 level is unsafe
        return False

    increasing = True
    decreasing = True

    for i in range(1, len(report)):
        if report[i] <= report[i - 1]:
            increasing = False
        if report[i] >= report[i - 1]:
            decreasing = False

    return increasing or decreasing


def check_adjacent_difference(report: List[int]) -> bool:
    """"""Check if the absolute difference between any two adjacent levels is between 1 and 3 (inclusive).

    Args:
        report: A list of integers representing a report.

    Returns:
        True if all adjacent differences are within the range, False otherwise.
    """"""
    for i in range(1, len(report)):
        diff = abs(report[i] - report[i - 1])
        if diff < 1 or diff > 3:
            return False
    return True


def determine_safety(report: List[int]) -> bool:
    """"""Determine if a report is safe based on monotonicity and adjacent difference checks.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    return check_monotonicity(report) and check_adjacent_difference(report)


def solve_part_one(reports: List[List[int]]) -> int:
    """"""Solve part one of the puzzle by counting the number of safe reports.

    Args:
        reports: A list of lists of integers, where each inner list represents a report.

    Returns:
        The number of safe reports.
    """"""
    safe_report_count = 0
    for report in reports:
        if determine_safety(report):
            safe_report_count += 1
    return safe_report_count


def main():
    """"""Main function to execute the solution.

    Parses the input file, solves part one, and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    reports = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(reports)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
3,single-model,gemini-2.0-flash,True,3.6233208179473877,"""""""
Advent of Code 2023 Day 3: Mull It Over
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re


def solve(input_string: str) -> int:
    """"""Solves the puzzle by extracting and multiplying valid ""mul"" instructions.

    Args:
        input_string: The string of corrupted memory.

    Returns:
        The sum of the results of valid multiplication instructions.
    """"""

    pattern = re.compile(r'mul\((\d{1,3}),(\d{1,3})\)')
    matches = pattern.finditer(input_string)

    total = 0
    for match in matches:
        try:
            num1 = int(match.group(1))
            num2 = int(match.group(2))
            total += num1 * num2
        except ValueError:
            # Handle cases where the captured groups aren't valid integers.
            # This is a defensive measure, though the regex should prevent this.
            continue
    return total


def main():
    """"""Main function to read input from file and print the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    try:
        with open(input_file, 'r') as f:
            input_string = f.read().strip()
    except FileNotFoundError:
        print(f""Error: File not found: {input_file}"")
        return
    except Exception as e:
        print(f""Error reading file: {e}"")
        return

    result = solve(input_string)
    print(result)


if __name__ == ""__main__"":
    main()
"
3,system,gemini-2.0-flash,True,43.2776415348053,"""""""
Advent of Code 2023 Day 3: Mull It Over
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
import re
import sys
from typing import List


def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a string.

    Args:
        input_file: Path to the input file

    Returns:
        The input string.
    """"""
    with open(input_file, 'r') as f:
        return f.read().strip()


def solve_part_one(input_string: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        input_string: The input string containing the corrupted memory.

    Returns:
        The sum of the products of all valid mul instructions.
    """"""
    pattern = r""mul\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)""
    matches = re.findall(pattern, input_string)

    total_sum = 0
    for match in matches:
        try:
            x = int(match[0])
            y = int(match[1])
            if 1 <= x <= 999 and 1 <= y <= 999:
                total_sum += x * y
        except ValueError:
            # Ignore invalid number conversions
            pass

    return total_sum


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    input_string = parse_input(input_file)

    part_one_solution = solve_part_one(input_string)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
4,single-model,gemini-2.0-flash,True,5.41766095161438,"""""""
Advent of Code 2023 Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def solve(grid: List[str], target: str = ""XMAS"") -> int:
    """"""Solve the word search puzzle.

    Args:
        grid: The word search grid as a list of strings.
        target: The word to search for (default: XMAS).

    Returns:
        The number of times the target word appears in the grid.
    """"""

    count = 0
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0
    target_len = len(target)

    if rows == 0 or cols == 0:
        return 0

    # Directions: right, down, diagonal right-down, diagonal left-down
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]

    def check_word(row: int, col: int, row_dir: int, col_dir: int) -> bool:
        """"""Checks if the target word exists starting from a given cell and direction.""""""
        word = """"
        for i in range(target_len):
            new_row = row + i * row_dir
            new_col = col + i * col_dir

            if 0 <= new_row < rows and 0 <= new_col < cols:
                word += grid[new_row][new_col]
            else:
                return False

        return word == target

    def check_word_backwards(row: int, col: int, row_dir: int, col_dir: int) -> bool:
        """"""Checks if the reversed target word exists starting from a given cell and direction.""""""
        word = """"
        for i in range(target_len):
            new_row = row + i * row_dir
            new_col = col + i * col_dir

            if 0 <= new_row < rows and 0 <= new_col < cols:
                word += grid[new_row][new_col]
            else:
                return False

        return word == target[::-1]


    for r in range(rows):
        for c in range(cols):
            for row_dir, col_dir in directions:
                if check_word(r, c, row_dir, col_dir):
                    count += 1
                if check_word_backwards(r, c, row_dir, col_dir):
                    count += 1

    return count


def parse_input(filename: str) -> List[str]:
    """"""Reads the grid from the input file.

    Args:
        filename: The path to the input file.

    Returns:
        A list of strings representing the grid.
    """"""
    with open(filename, 'r') as f:
        return [line.strip() for line in f]


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)

    solution = solve(grid)
    print(solution)

if __name__ == ""__main__"":
    main()
"
4,system,gemini-2.0-flash,True,55.734777212142944,"""""""Advent of Code Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D grid.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    with open(input_file, 'r') as f:
        grid = [list(line.strip()) for line in f]
    return grid


def check_direction(grid: List[List[str]], r: int, c: int, row_increment: int, col_increment: int) -> bool:
    """"""Check if ""XMAS"" exists in a particular direction from a given cell.

    Args:
        grid: The 2D grid of characters.
        r: Starting row index.
        c: Starting column index.
        row_increment: Increment for row index (-1, 0, or 1).
        col_increment: Increment for column index (-1, 0, or 1).

    Returns:
        True if ""XMAS"" is found in the specified direction, False otherwise.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    word = """"
    for _ in range(4):
        if not (0 <= r < rows and 0 <= c < cols):
            return False
        word += grid[r][c]
        r += row_increment
        c += col_increment
    return word == ""XMAS""


def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: The 2D grid of characters.

    Returns:
        The total number of ""XMAS"" occurrences in the grid.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    count = 0
    for r in range(rows):
        for c in range(cols):
            count += check_direction(grid, r, c, 0, 1)  # Right
            count += check_direction(grid, r, c, 0, -1) # Left
            count += check_direction(grid, r, c, 1, 0)  # Down
            count += check_direction(grid, r, c, -1, 0) # Up
            count += check_direction(grid, r, c, 1, 1)  # Down-Right
            count += check_direction(grid, r, c, 1, -1) # Down-Left
            count += check_direction(grid, r, c, -1, 1) # Up-Right
            count += check_direction(grid, r, c, -1, -1) # Up-Left
    return count


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    part_one_solution = solve_part_one(grid)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
5,single-model,gemini-2.0-flash,True,5.617599010467529,"""""""
Advent of Code 2023 Day 5: Print Queue
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse the puzzle input from file into ordering rules and updates.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A list of tuples, where each tuple represents an ordering rule (X, Y).
        - A list of lists, where each inner list represents an update (list of page numbers).
    """"""
    with open(input_file, 'r') as f:
        content = f.read().split('\n\n')

    ordering_rules = []
    for rule in content[0].splitlines():
        if rule:
            x, y = map(int, rule.split('|'))
            ordering_rules.append((x, y))

    updates = []
    for update_str in content[1].splitlines():
        if update_str:
            updates.append(list(map(int, update_str.split(','))))

    return ordering_rules, updates

def is_update_valid(update: List[int], ordering_rules: List[Tuple[int, int]]) -> bool:
    """"""Check if the update is in the correct order according to the rules.

    Args:
        update: A list of page numbers in the update.
        ordering_rules: A list of ordering rules (X, Y).

    Returns:
        True if the update is valid, False otherwise.
    """"""
    for i in range(len(update)):
        for j in range(i + 1, len(update)):
            page_x = update[i]
            page_y = update[j]
            if (page_x, page_y) in ordering_rules:
                continue #Correct ordering, do not violate rule
            elif (page_y, page_x) in ordering_rules:
                return False #incorrect ordering, violate rule
    return True

def solve_part_one(ordering_rules: List[Tuple[int, int]], updates: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        ordering_rules: A list of ordering rules (X, Y).
        updates: A list of updates (lists of page numbers).

    Returns:
        The sum of the middle page numbers from the correctly-ordered updates.
    """"""
    total_middle_page_numbers = 0

    for update in updates:
        if is_update_valid(update, ordering_rules):
            middle_index = len(update) // 2
            total_middle_page_numbers += update[middle_index]

    return total_middle_page_numbers

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    ordering_rules, updates = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(ordering_rules, updates)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
5,system,gemini-2.0-flash,False,186.30332112312317,
6,single-model,gemini-2.0-flash,False,5.775475263595581,threw-error
7,single-model,gemini-2.0-flash,False,4.242539882659912,NO CODE
7,system,gemini-2.0-flash,True,65.32628774642944,"""""""
Advent of Code 2023 Day 7: Bridge Repair
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of tuples.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple contains the target value (int)
        and a list of numbers (list of int) for each equation.
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            try:
                target, numbers_str = line.strip().split(':')
                target = int(target)
                numbers = [int(x) for x in numbers_str.split()]
                equations.append((target, numbers))
            except ValueError:
                print(f""Skipping invalid line: {line.strip()}"", file=sys.stderr)
                continue
    return equations


def evaluate(numbers: List[int], current_result: int, index: int, target: int) -> bool:
    """"""Recursively evaluate possible combinations of operators.

    Args:
        numbers: List of numbers in the equation.
        current_result: The current result of the evaluation.
        index: The current index in the list of numbers.
        target: The target value to achieve.

    Returns:
        True if the target value can be achieved, False otherwise.
    """"""
    if index == len(numbers):
        return current_result == target

    number = numbers[index]

    # Try addition
    if evaluate(numbers, current_result + number, index + 1, target):
        return True

    # Try multiplication
    if evaluate(numbers, current_result * number, index + 1, target):
        return True

    return False


def equation_solver(target: int, numbers: List[int]) -> bool:
    """"""Check if the equation can be made true.

    Args:
        target: The target value for the equation.
        numbers: The list of numbers in the equation.

    Returns:
        True if the equation can be made true, False otherwise.
    """"""
    if not numbers:
        return False

    return evaluate(numbers, numbers[0], 1, target)


def main():
    """"""Main function to solve the puzzle.

    Parses the input, solves each equation, and prints the sum of the target
    values of the true equations.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]
    equations = parse_input(input_file)

    total_sum = 0
    for target, numbers in equations:
        if equation_solver(target, numbers):
            total_sum += target

    print(total_sum)


if __name__ == ""__main__"":
    main()
"
8,single-model,gemini-2.0-flash,False,6.240673065185547,NO CODE
8,system,gemini-2.0-flash,True,96.6331148147583,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D grid.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of characters representing the grid.
    """"""
    grid: List[List[str]] = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                grid.append(list(line))
    return grid


def locate_antennas(grid: List[List[str]]) -> Dict[str, List[Tuple[int, int]]]:
    """"""Locate antennas in the grid and group them by frequency.

    Args:
        grid: The 2D grid of antennas.

    Returns:
        A dictionary where keys are frequencies and values are lists of (row, col) tuples.
    """"""
    antennas: Dict[str, List[Tuple[int, int]]] = defaultdict(list)
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if grid[row][col].isalnum():
                antennas[grid[row][col]].append((row, col))
    return antennas


def identify_antinodes(grid: List[List[str]], antennas: Dict[str, List[Tuple[int, int]]]) -> Set[Tuple[int, int]]:
    """"""Identify antinodes based on antenna positions and the collinearity/distance criteria.

    Args:
        grid: The 2D grid of antennas.
        antennas: A dictionary of antenna locations grouped by frequency.

    Returns:
        A set of tuples representing the unique (row, col) coordinates of the antinodes.
    """"""
    antinodes: Set[Tuple[int, int]] = set()
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    for frequency, antenna_list in antennas.items():
        for i in range(len(antenna_list)):
            for j in range(i + 1, len(antenna_list)):
                row1, col1 = antenna_list[i]
                row2, col2 = antenna_list[j]

                # Check if antennas are at the same location. If so, there are no antinodes
                if (row1, col1) == (row2, col2):
                    continue

                # Calculate antinode positions
                # Case 1: antenna1 is twice as far as antenna2:
                row = row2 + (row2 - row1)
                col = col2 + (col2 - col1)
                if 0 <= row < rows and 0 <= col < cols:
                    antinodes.add((row, col))

                # Case 2: antenna2 is twice as far as antenna1:
                row = row1 + (row1 - row2)
                col = col1 + (col1 - col2)
                if 0 <= row < rows and 0 <= col < cols:
                    antinodes.add((row, col))

    return antinodes


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Locate antennas
    antennas = locate_antennas(grid)

    # Identify antinodes
    antinodes = identify_antinodes(grid, antennas)

    # Count unique antinodes and print the result
    print(len(antinodes))  # Correct way to print the solution


if __name__ == ""__main__"":
    main()
"
9,single-model,gemini-2.0-flash,False,11.274895191192627,"""""""
Advent of Code 2023 Day 9: Disk Fragmenter
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_string: str) -> List[int]:
    """"""Parse the puzzle input from string into a list of integers.

    Args:
        input_string: The input string representing the disk map

    Returns:
        List of integers representing the lengths of files and free space.
    """"""
    return [int(digit) for digit in input_string]


def compact_disk(disk_map: List[int]) -> List[str]:
    """"""Compacts the disk by moving files to the left.

    Args:
        disk_map: List of integers representing the disk map.

    Returns:
        List of strings representing the state of the disk at each step.
    """"""
    files = []
    free_spaces = []
    file_id = 0
    disk = []
    for i in range(0, len(disk_map), 2):
        file_len = disk_map[i]
        files.append(file_len)
        disk.extend([str(file_id)] * file_len)
        file_id += 1
        if i + 1 < len(disk_map):
            free_space_len = disk_map[i + 1]
            free_spaces.append(free_space_len)
            disk.extend(['.'] * free_space_len)

    history = [''.join(disk)]

    while True:
        first_free_index = -1
        for i, block in enumerate(disk):
            if block == '.':
                first_free_index = i
                break

        if first_free_index == -1:
            break

        last_file_index = -1
        for i in range(len(disk) - 1, -1, -1):
            if disk[i] != '.':
                last_file_index = i
                break

        if last_file_index == -1:
            break

        if last_file_index < first_free_index:
            break

        disk[first_free_index] = disk[last_file_index]
        disk[last_file_index] = '.'
        history.append(''.join(disk))

    return history


def calculate_checksum(disk: List[str]) -> int:
    """"""Calculates the checksum of the disk.

    Args:
        disk: List of strings representing the final state of the disk.

    Returns:
        The calculated checksum.
    """"""
    checksum = 0
    for i, block in enumerate(disk):
        if block != '.':
            checksum += i * int(block)
    return checksum


def solve_part_one(input_string: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        input_string: The raw puzzle input.

    Returns:
        Solution for part one.
    """"""
    disk_map = parse_input(input_string)
    history = compact_disk(disk_map)
    final_disk_state = list(history[-1])
    checksum = calculate_checksum(final_disk_state)
    return checksum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    with open(input_file, 'r') as f:
        input_string = f.readline().strip()

    # Solve part one
    part_one_solution = solve_part_one(input_string)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
9,system,gemini-2.0-flash,True,131.8356122970581,"""""""
Advent of Code 2023 Day 9: Disk Fragmenter
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> Tuple[List[int], List[Tuple[int, int, int, int]]]:
    """"""Parse the puzzle input from file into appropriate data structures.

    Args:
        input_file: Path to the input file

    Returns:
        Tuple containing:
            - disk_map: List of integers representing file/free space lengths.
            - files: List of tuples, each containing (file_id, length, start_index, end_index)
    """"""
    with open(input_file, 'r') as f:
        disk_map_str = f.readline().strip()

    disk_map = [int(c) for c in disk_map_str]
    files: List[Tuple[int, int, int, int]] = []
    file_id = 0
    start_index = 0
    is_file = True # starts with file
    current_index = 0

    for length in disk_map:
        if is_file:
            files.append((file_id, length, start_index, start_index + length))
            file_id += 1
        start_index += length
        is_file = not is_file  # Alternate between file and free space
        current_index += 1

    return disk_map, files

def disk_expansion(disk_map: List[int], files: List[Tuple[int, int, int, int]]) -> List[str]:
    """"""Create the initial representation of the disk as individual blocks.

    Args:
        disk_map: List of integers representing file/free space lengths.
        files: List of tuples, each containing (file_id, length, start_index, end_index)

    Returns:
        List of strings/integers representing the initial disk blocks.
    """"""
    blocks: List[str] = []
    file_id = 0
    is_file = True

    for length in disk_map:
        if is_file:
            blocks.extend([str(file_id)] * length)
            file_id += 1
        else:
            blocks.extend(['.'] * length)
        is_file = not is_file

    return blocks

def compaction_simulation(blocks: List[str]) -> List[str]:
    """"""Simulate the disk compaction process.

    Args:
        blocks: List of strings/integers representing the initial disk blocks.

    Returns:
        List of strings/integers representing the compacted disk blocks.
    """"""
    compacted_blocks = blocks.copy()
    left = 0
    right = len(compacted_blocks) - 1

    while True:
        # Find the next free space from the left
        while left < len(compacted_blocks) and compacted_blocks[left] != '.':
            left += 1

        # Find the next file block from the right
        while right >= 0 and compacted_blocks[right] == '.':
            right -= 1

        # If no more free spaces or file blocks, break
        if left >= len(compacted_blocks) or right < 0 or left >= right:
            break

        # Move the file block to the free space
        compacted_blocks[left] = compacted_blocks[right]
        compacted_blocks[right] = '.'
        left += 1
        right -= 1

    return compacted_blocks


def checksum_calculation(compacted_blocks: List[str]) -> int:
    """"""Calculate the filesystem checksum after compaction.

    Args:
        compacted_blocks: List of strings/integers representing the compacted disk blocks.

    Returns:
        The filesystem checksum.
    """"""
    checksum = 0
    for i, block in enumerate(compacted_blocks):
        if block != '.':
            checksum += i * int(block)
    return checksum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    disk_map, files = parse_input(input_file)

    # Disk Expansion
    blocks = disk_expansion(disk_map, files)

    # Compaction Simulation
    compacted_blocks = compaction_simulation(blocks)

    # Checksum Calculation
    checksum = checksum_calculation(compacted_blocks)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(checksum)

if __name__ == ""__main__"":
    main()
"
10,single-model,gemini-2.0-flash,True,6.012235879898071,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a 2D list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list representing the topographic map.
    """"""
    grid: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            row: List[int] = [int(x) for x in line.strip()]
            grid.append(row)
    return grid

def solve_part_one(grid: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: A 2D list representing the topographic map.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    total_score = 0

    def get_neighbors(r: int, c: int) -> List[Tuple[int, int]]:
        """"""Get valid neighbors (up, down, left, right) of a cell.""""""
        neighbors = []
        if r > 0:
            neighbors.append((r - 1, c))  # Up
        if r < rows - 1:
            neighbors.append((r + 1, c))  # Down
        if c > 0:
            neighbors.append((r, c - 1))  # Left
        if c < cols - 1:
            neighbors.append((r, c + 1))  # Right
        return neighbors

    def calculate_trailhead_score(start_r: int, start_c: int) -> int:
        """"""Calculate the score of a single trailhead.

        Args:
            start_r: Row index of the trailhead.
            start_c: Column index of the trailhead.

        Returns:
            The number of reachable '9' positions from the trailhead.
        """"""
        reachable_nines = 0
        visited: Set[Tuple[int, int]] = set()
        q = deque([(start_r, start_c)])
        visited.add((start_r, start_c))

        while q:
            r, c = q.popleft()

            if grid[r][c] == 9:
                reachable_nines += 1

            for nr, nc in get_neighbors(r, c):
                if (nr, nc) not in visited and grid[nr][nc] == grid[r][c] + 1:
                    q.append((nr, nc))
                    visited.add((nr, nc))

        return reachable_nines

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 0:
                total_score += calculate_trailhead_score(r, c)

    return total_score

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
10,system,gemini-2.0-flash,True,54.979761838912964,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
from collections import deque

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a 2D list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of integers representing the topographic map.
    """"""
    grid: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append([int(c) for c in line.strip()])
    return grid


def identify_trailheads(grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Find all locations with height 0 and store their coordinates.

    Args:
        grid: A 2D list of integers representing the topographic map.

    Returns:
        A list of tuples representing the coordinates (row, col) of all trailheads.
    """"""
    trailheads: List[Tuple[int, int]] = []
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if grid[row][col] == 0:
                trailheads.append((row, col))
    return trailheads


def search_from_trailhead(grid: List[List[int]], trailhead: Tuple[int, int]) -> int:
    """"""Perform a BFS search from a trailhead to find all reachable '9' positions.

    Args:
        grid: A 2D list of integers representing the topographic map.
        trailhead: A tuple representing the coordinates (row, col) of the trailhead.

    Returns:
        The number of reachable '9' positions from the trailhead.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    visited: Set[Tuple[int, int]] = set()
    queue: deque[Tuple[int, int, int]] = deque([(trailhead[0], trailhead[1], 0)])  # (row, col, height)
    reachable_9s = 0

    while queue:
        row, col, height = queue.popleft()

        if row < 0 or row >= rows or col < 0 or col >= cols or (row, col) in visited:
            continue

        visited.add((row, col))

        if grid[row][col] == 9:
            reachable_9s += 1

        # Explore neighbors (up, down, left, right)
        neighbors = [
            (row - 1, col),
            (row + 1, col),
            (row, col - 1),
            (row, col + 1),
        ]

        for nr, nc in neighbors:
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == height + 1:
                queue.append((nr, nc, height + 1))

    return reachable_9s


def calculate_total_score(grid: List[List[int]], trailheads: List[Tuple[int, int]]) -> int:
    """"""Calculate the sum of the scores of all trailheads.

    Args:
        grid: A 2D list of integers representing the topographic map.
        trailheads: A list of tuples representing the coordinates (row, col) of all trailheads.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    total_score = 0
    for trailhead in trailheads:
        total_score += search_from_trailhead(grid, trailhead)
    return total_score


def main():
    """"""Main function to solve the puzzle.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Identify trailheads
    trailheads = identify_trailheads(grid)

    # Calculate total score
    total_score = calculate_total_score(grid, trailheads)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(total_score)


if __name__ == ""__main__"":
    main()
"
11,single-model,gemini-2.0-flash,True,6.530908107757568,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        List of integers representing the initial stone arrangement.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        return [int(x) for x in line.split()]


def evolve_stones(stones: List[int]) -> List[int]:
    """"""Evolves the stones according to the given rules.

    Args:
        stones: The current list of stones.

    Returns:
        The updated list of stones after one blink.
    """"""
    new_stones: List[int] = []
    for stone in stones:
        if stone == 0:
            new_stones.append(1)
        elif len(str(stone)) % 2 == 0:
            s_stone = str(stone)
            mid = len(s_stone) // 2
            left = int(s_stone[:mid])
            right = int(s_stone[mid:])
            new_stones.append(left)
            new_stones.append(right)
        else:
            new_stones.append(stone * 2024)
    return new_stones


def solve_part_one(initial_stones: List[int], num_blinks: int) -> int:
    """"""Solves part one of the puzzle, calculating the number of stones after 25 blinks.

    Args:
        initial_stones: The initial list of stones.
        num_blinks: The number of blinks to perform.

    Returns:
        The number of stones after the specified number of blinks.
    """"""
    stones = initial_stones
    for _ in range(num_blinks):
        stones = evolve_stones(stones)
    return len(stones)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_stones = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_stones, 25)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Test with examples (if available)
    # Example 1
    example_stones_1 = [0, 1, 10, 99, 999]
    expected_stones_1 = [1, 2024, 1, 0, 9, 9, 2021976]
    assert evolve_stones(example_stones_1) == expected_stones_1, f""Example 1 failed: {evolve_stones(example_stones_1)}""

    # Example 2
    example_stones_2 = [125, 17]
    stones_after_1_blink = evolve_stones(example_stones_2)
    assert stones_after_1_blink == [253000, 1, 7], f""Example 2, blink 1 failed: {stones_after_1_blink}""
    stones_after_2_blinks = evolve_stones(stones_after_1_blink)
    assert stones_after_2_blinks == [253, 0, 2024, 14168], f""Example 2, blink 2 failed: {stones_after_2_blinks}""


if __name__ == ""__main__"":
    main()
"
11,system,gemini-2.0-flash,True,48.3014612197876,"""""""Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial state of the stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        stones = [int(x) for x in line.split()]
        return stones


def solve_part_one(stones: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        stones: A list of integers representing the initial state of the stones.

    Returns:
        The number of stones after 25 blinks.
    """"""
    num_blinks = 25
    for _ in range(num_blinks):
        new_stones: List[int] = []
        for stone in stones:
            if stone == 0:
                new_stones.append(1)
            else:
                stone_str = str(stone)
                if len(stone_str) % 2 == 0:
                    mid = len(stone_str) // 2
                    left = int(stone_str[:mid])
                    right = int(stone_str[mid:])
                    new_stones.append(left)
                    new_stones.append(right)
                else:
                    new_stones.append(stone * 2024)
        stones = new_stones
    return len(stones)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
12,single-model,gemini-2.0-flash,True,10.029915809631348,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> List[str]:
    """"""Parse the puzzle input from file into a list of strings.

    Args:
        input_file: Path to the input file

    Returns:
        A list of strings, where each string represents a row in the garden map.
    """"""
    with open(input_file, 'r') as f:
        return [line.strip() for line in f]

def find_regions(garden_map: List[str]) -> Dict[str, List[Tuple[int, int]]]:
    """"""Finds all regions in the garden map.

    Args:
        garden_map: A list of strings representing the garden map.

    Returns:
        A dictionary where keys are plant types and values are lists of coordinates (row, col) for each region.
    """"""
    regions: Dict[str, List[Tuple[int, int]]] = defaultdict(list)
    visited: Set[Tuple[int, int]] = set()
    rows = len(garden_map)
    cols = len(garden_map[0]) if rows > 0 else 0

    def explore_region(row: int, col: int, plant_type: str, current_region: List[Tuple[int, int]]) -> None:
        """"""Recursively explores a region of the same plant type.

        Args:
            row: The current row.
            col: The current column.
            plant_type: The type of plant in the region.
            current_region: The list to store the coordinates of the current region.
        """"""
        if (row < 0 or row >= rows or col < 0 or col >= cols or
            (row, col) in visited or garden_map[row][col] != plant_type):
            return

        visited.add((row, col))
        current_region.append((row, col))

        explore_region(row + 1, col, plant_type, current_region)
        explore_region(row - 1, col, plant_type, current_region)
        explore_region(row, col + 1, plant_type, current_region)
        explore_region(row, col - 1, plant_type, current_region)

    for row in range(rows):
        for col in range(cols):
            if (row, col) not in visited:
                plant_type = garden_map[row][col]
                current_region: List[Tuple[int, int]] = []
                explore_region(row, col, plant_type, current_region)
                if current_region:
                    regions[plant_type].append(current_region)

    return regions

def calculate_perimeter(region: List[Tuple[int, int]], garden_map: List[str]) -> int:
    """"""Calculates the perimeter of a region.

    Args:
        region: A list of coordinates (row, col) representing the region.
        garden_map: A list of strings representing the garden map.

    Returns:
        The perimeter of the region.
    """"""
    perimeter = 0
    rows = len(garden_map)
    cols = len(garden_map[0]) if rows > 0 else 0
    plant_type = garden_map[region[0][0]][region[0][1]]

    for row, col in region:
        # Check top
        if row == 0 or garden_map[row - 1][col] != plant_type:
            perimeter += 1
        # Check bottom
        if row == rows - 1 or garden_map[row + 1][col] != plant_type:
            perimeter += 1
        # Check left
        if col == 0 or garden_map[row][col - 1] != plant_type:
            perimeter += 1
        # Check right
        if col == cols - 1 or garden_map[row][col + 1] != plant_type:
            perimeter += 1

    return perimeter

def solve_part_one(garden_map: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        garden_map: A list of strings representing the garden map.

    Returns:
        The total price of fencing all regions.
    """"""
    regions = find_regions(garden_map)
    total_price = 0

    for plant_type, region_list in regions.items():
        for region in region_list:
            area = len(region)
            perimeter = calculate_perimeter(region, garden_map)
            price = area * perimeter
            total_price += price

    return total_price


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    garden_map = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(garden_map)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Test with examples (if available)
    example1 = [
        ""AAAA"",
        ""BBCD"",
        ""BBCC"",
        ""EEEC""
    ]
    example2 = [
        ""OOOOO"",
        ""OXOXO"",
        ""OOOOO"",
        ""OXOXO"",
        ""OOOOO""
    ]
    example3 = [
        ""RRRRIICCFF"",
        ""RRRRIICCCF"",
        ""VVRRRCCFFF"",
        ""VVRCCCJFFF"",
        ""VVVVCJJCFE"",
        ""VVIVCCJJEE"",
        ""VVIIICJJEE"",
        ""MIIIIIJJEE"",
        ""MIIISIJEEE"",
        ""MMMISSJEEE""
    ]
    assert solve_part_one(example1) == 140
    assert solve_part_one(example2) == 772
    assert solve_part_one(example3) == 1930


if __name__ == ""__main__"":
    main()
"
12,system,gemini-2.0-flash,True,73.10655689239502,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D grid of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    grid: List[List[str]] = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid


def flood_fill(grid: List[List[str]], row: int, col: int, visited: Set[Tuple[int, int]], region: Set[Tuple[int, int]]) -> None:
    """"""Recursively identifies all connected cells with the same character.

    Args:
        grid: The 2D grid.
        row: The current row index.
        col: The current column index.
        visited: A set to keep track of visited cells.
        region: A set to store the coordinates of the connected region.

    Returns:
        None (modifies the region set in place)
    """"""
    # Base cases for recursion:
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):
        return
    if (row, col) in visited:
        return
    if grid[row][col] != grid[row_start][col_start]:
        return

    # Mark the current cell as visited and add it to the region
    visited.add((row, col))
    region.add((row, col))

    # Recursively call flood fill on the four adjacent cells
    flood_fill(grid, row + 1, col, visited, region)
    flood_fill(grid, row - 1, col, visited, region)
    flood_fill(grid, row, col + 1, visited, region)
    flood_fill(grid, row, col - 1, visited, region)


def calculate_area_and_perimeter(region: Set[Tuple[int, int]], grid: List[List[str]]) -> Tuple[int, int]:
    """"""Calculates the area and perimeter of a given region.

    Args:
        region: A set of tuples representing the coordinates of the region.
        grid: The 2D grid.

    Returns:
        A tuple containing the area and perimeter of the region.
    """"""
    area = len(region)
    perimeter = 0
    for row, col in region:
        # Check the four neighbors
        if row == 0 or (row - 1, col) not in region:
            perimeter += 1
        if row == len(grid) - 1 or (row + 1, col) not in region:
            perimeter += 1
        if col == 0 or (row, col - 1) not in region:
            perimeter += 1
        if col == len(grid[0]) - 1 or (row, col + 1) not in region:
            perimeter += 1
    return area, perimeter


def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: Processed input data

    Returns:
        Solution for part one
    """"""
    global row_start, col_start
    regions: List[Set[Tuple[int, int]]] = []
    visited: Set[Tuple[int, int]] = set()

    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if (row, col) not in visited:
                row_start, col_start = row, col
                region: Set[Tuple[int, int]] = set()
                flood_fill(grid, row, col, visited, region)
                regions.append(region)

    total_price = 0
    for region in regions:
        area, perimeter = calculate_area_and_perimeter(region, grid)
        price = area * perimeter
        total_price += price

    return total_price


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Test with examples (if available)
    # Example 1
    example1 = [list(""AAAA""), list(""BBCD""), list(""BBCC""), list(""EEEC"")]
    assert solve_part_one(example1) == 140, f""Test Case 1 Failed: Expected 140, got {solve_part_one(example1)}""

    # Example 2
    example2 = [list(""OOOOO""), list(""OXOXO""), list(""OOOOO""), list(""OXOXO""), list(""OOOOO"")]
    assert solve_part_one(example2) == 772, f""Test Case 2 Failed: Expected 772, got {solve_part_one(example2)}""

    # Example 3
    example3 = [list(""RRRRIICCFF""), list(""RRRRIICCCF""), list(""VVRRRCCFFF""), list(""VVRCCCJFFF""), list(""VVVVCJJCFE""),
                list(""VVIVCCJJEE""), list(""VVIIICJJEE""), list(""MIIIIIJJEE""), list(""MIIISIJEEE""), list(""MMMISSJEEE"")]
    assert solve_part_one(example3) == 1930, f""Test Case 3 Failed: Expected 1930, got {solve_part_one(example3)}""


if __name__ == ""__main__"":
    main()
"
13,single-model,gemini-2.0-flash,False,6.230958461761475,NO CODE
13,system,gemini-2.0-flash,True,89.12088322639465,"""""""
Advent of Code 2023 Day 13: Claw Contraption
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re

def parse_input(input_file: str) -> List[Dict[str, int]]:
    """"""Parse the puzzle input from file into a list of machine configurations.

    Args:
        input_file: Path to the input file

    Returns:
        A list of dictionaries, where each dictionary represents a claw machine's configuration.
    """"""
    machines = []
    with open(input_file, 'r') as f:
        machine_data = f.read().strip().split('\n\n')
        for machine_str in machine_data:
            lines = machine_str.splitlines()
            a_x, a_y = map(int, re.findall(r'[+-]?\d+', lines[0]))
            b_x, b_y = map(int, re.findall(r'[+-]?\d+', lines[1]))
            prize_x, prize_y = map(int, re.findall(r'[+-]?\d+', lines[2]))
            machines.append({
                'A_x': a_x,
                'A_y': a_y,
                'B_x': b_x,
                'B_y': b_y,
                'prize_x': prize_x,
                'prize_y': prize_y
            })
    return machines

def solve_for_machine(machine: Dict[str, int], machine_index: int) -> Tuple[float, int]:
    """"""Solve for a single machine and return the minimum token cost and the machine index.

    Args:
        machine: A dictionary representing a claw machine's configuration.
        machine_index: The index of the machine in the input list.

    Returns:
        A tuple containing the minimum token cost for winning the prize in that machine and the machine index. If no solution is found, the cost is set to infinity.
    """"""
    min_cost = float('inf')
    for num_a in range(101):
        for num_b in range(101):
            if machine['A_x'] * num_a + machine['B_x'] * num_b == machine['prize_x'] and \
               machine['A_y'] * num_a + machine['B_y'] * num_b == machine['prize_y']:
                cost = 3 * num_a + num_b
                min_cost = min(min_cost, cost)

    return min_cost, machine_index

def collect_solutions_and_sort(machines: List[Dict[str, int]]) -> List[Tuple[float, int]]:
    """"""Collect solutions for all machines and sort them by cost in ascending order.

    Args:
        machines: A list of dictionaries, where each dictionary represents a claw machine's configuration.

    Returns:
        A sorted list of tuples, where each tuple contains the minimum token cost and the machine index.
    """"""
    solutions = []
    for i, machine in enumerate(machines):
        cost, machine_index = solve_for_machine(machine, i)
        solutions.append((cost, machine_index))

    solutions.sort(key=lambda x: x[0])
    return solutions

def calculate_total_minimum_cost(sorted_solutions: List[Tuple[float, int]]) -> int:
    """"""Calculate the total minimum token cost for all machines with valid solutions.

    Args:
        sorted_solutions: A sorted list of tuples, where each tuple contains the minimum token cost and the machine index.

    Returns:
        An integer representing the total minimum token cost to win all possible prizes.
    """"""
    total_cost = 0
    for cost, _ in sorted_solutions:
        if cost != float('inf'):
            total_cost += cost
    return total_cost

def main():
    """"""Main function to solve the claw contraption problem.
    """"""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve the problem
    sorted_solutions = collect_solutions_and_sort(parsed_data)
    total_cost = calculate_total_minimum_cost(sorted_solutions)

    # Print the result
    print(total_cost)

if __name__ == ""__main__"":
    main()
"
14,single-model,gemini-2.0-flash,False,6.709188938140869,"""""""
Advent of Code 2023 Day 14: Restroom Redoubt
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Dict
import sys
from collections import defaultdict
import re

def parse_input(input_file: str) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
    """"""Parse the puzzle input from file into a list of robot positions and velocities.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple contains a robot's initial position (x, y) and velocity (vx, vy).
    """"""
    robots = []
    with open(input_file, 'r') as f:
        for line in f:
            match = re.match(r'p=(\d+),(\d+) v=(-?\d+),(-?\d+)', line)
            if match:
                px, py, vx, vy = map(int, match.groups())
                robots.append(((px, py), (vx, vy)))
    return robots

def simulate_robots(robots: List[Tuple[Tuple[int, int], Tuple[int, int]]], time: int, width: int, height: int) -> Dict[Tuple[int, int], int]:
    """"""Simulate the movement of robots over a given time, considering wraparound.

    Args:
        robots: A list of robot positions and velocities.
        time: The number of seconds to simulate.
        width: The width of the grid.
        height: The height of the grid.

    Returns:
        A dictionary representing the grid, where keys are (x, y) coordinates and values are the number of robots at that location.
    """"""
    grid = defaultdict(int)
    for (px, py), (vx, vy) in robots:
        x = (px + vx * time) % width
        y = (py + vy * time) % height
        grid[(x, y)] += 1
    return grid

def calculate_safety_factor(grid: Dict[Tuple[int, int], int], width: int, height: int) -> int:
    """"""Calculate the safety factor by multiplying the number of robots in each quadrant.

    Args:
        grid: A dictionary representing the grid of robots.
        width: The width of the grid.
        height: The height of the grid.

    Returns:
        The safety factor calculated as the product of robots in each quadrant.
    """"""
    quadrant_counts = [0, 0, 0, 0]
    mid_x = width / 2
    mid_y = height / 2

    for (x, y), count in grid.items():
        if x < mid_x and y < mid_y:
            quadrant_counts[0] += count  # Top-left
        elif x > mid_x and y < mid_y:
            quadrant_counts[1] += count  # Top-right
        elif x < mid_x and y > mid_y:
            quadrant_counts[2] += count  # Bottom-left
        elif x > mid_x and y > mid_y:
            quadrant_counts[3] += count  # Bottom-right

    safety_factor = 1
    for count in quadrant_counts:
        if count > 0:  # Handle cases where a quadrant has no robots
            safety_factor *= count

    return safety_factor

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    robots = parse_input(input_file)

    # Simulate robots for 100 seconds
    width = 101
    height = 103
    time = 100
    grid = simulate_robots(robots, time, width, height)

    # Calculate the safety factor
    safety_factor = calculate_safety_factor(grid, width, height)

    # Print the safety factor
    print(safety_factor)

if __name__ == ""__main__"":
    main()
"
14,system,gemini-2.0-flash,True,50.81783843040466,"""""""
Advent of Code 2023 Day 14: Restroom Redoubt
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
import re

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int, int, int]], int, int]:
    """"""Parse the puzzle input from file into robot data, width, and height.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A list of tuples: [(x1, y1, vx1, vy1), (x2, y2, vx2, vy2), ...]
        - The width of the grid.
        - The height of the grid.
    """"""
    robots = []
    with open(input_file, 'r') as f:
        for line in f:
            match = re.match(r'p=(\d+),(\d+) v=(-?\d+),(-?\d+)', line)
            if match:
                x, y, vx, vy = map(int, match.groups())
                robots.append((x, y, vx, vy))
    width = 101
    height = 103
    return robots, width, height

def simulate_robot_movement(robots: List[Tuple[int, int, int, int]], width: int, height: int, num_steps: int) -> List[Tuple[int, int]]:
    """"""Simulate the movement of each robot for a given number of steps.

    Args:
        robots: A list of tuples representing the robots' initial positions and velocities.
        width: The width of the grid.
        height: The height of the grid.
        num_steps: The number of steps to simulate.

    Returns:
        A list of tuples representing the final positions of the robots.
    """"""
    final_positions = []
    for x, y, vx, vy in robots:
        current_x, current_y = x, y
        for _ in range(num_steps):
            current_x = (current_x + vx) % width
            current_y = (current_y + vy) % height
        final_positions.append((current_x, current_y))
    return final_positions

def count_robots_in_quadrants(final_positions: List[Tuple[int, int]], width: int, height: int) -> List[int]:
    """"""Count the number of robots in each quadrant.

    Args:
        final_positions: A list of tuples representing the final positions of the robots.
        width: The width of the grid.
        height: The height of the grid.

    Returns:
        A list of integers representing the number of robots in each quadrant.
    """"""
    quadrant_counts = [0, 0, 0, 0]
    center_x = width // 2
    center_y = height // 2
    for x, y in final_positions:
        if x == center_x or y == center_y:
            continue
        if x > center_x and y < center_y:
            quadrant_counts[0] += 1  # Quadrant 1
        elif x < center_x and y < center_y:
            quadrant_counts[1] += 1  # Quadrant 2
        elif x < center_x and y > center_y:
            quadrant_counts[2] += 1  # Quadrant 3
        elif x > center_x and y > center_y:
            quadrant_counts[3] += 1  # Quadrant 4
    return quadrant_counts

def calculate_safety_factor(quadrant_counts: List[int]) -> int:
    """"""Calculate the safety factor by multiplying the number of robots in each quadrant.

    Args:
        quadrant_counts: A list of integers representing the number of robots in each quadrant.

    Returns:
        The safety factor.
    """"""
    safety_factor = 1
    for count in quadrant_counts:
        if count == 0:
            return 0
        safety_factor *= count
    return safety_factor

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    robots, width, height = parse_input(input_file)

    # Simulate robot movement
    final_positions = simulate_robot_movement(robots, width, height, 100)

    # Count robots in each quadrant
    quadrant_counts = count_robots_in_quadrants(final_positions, width, height)

    # Calculate safety factor
    safety_factor = calculate_safety_factor(quadrant_counts)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(safety_factor)

if __name__ == ""__main__"":
    main()
"
15,single-model,gemini-2.0-flash,False,9.46630597114563,"""""""
Advent of Code 2023 Day 15: Warehouse Woes
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into map and moves.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing the warehouse map (list of strings) and the move sequence (string).
    """"""
    with open(input_file, 'r') as f:
        data = f.read().split('\n')
        # Separate map from moves, handling potential empty lines
        map_lines = []
        moves = []
        separator_found = False
        for line in data:
            if not separator_found:
                if line.strip() == '':
                    separator_found = True
                else:
                    map_lines.append(line)
            else:
                moves.append(line)
        warehouse_map = map_lines
        move_sequence = ''.join(moves)  # Combine all move lines into one string

        return warehouse_map, list(move_sequence)


def solve_part_one(warehouse_map: List[str], move_sequence: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        warehouse_map: The warehouse map as a list of strings.
        move_sequence: The sequence of moves as a list of characters.

    Returns:
        The sum of all boxes' GPS coordinates after the robot finishes moving.
    """"""

    grid = [list(row) for row in warehouse_map]
    robot_row, robot_col = None, None
    boxes = []
    rows, cols = len(grid), len(grid[0])

    # Find initial robot and box positions
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '@':
                robot_row, robot_col = r, c
            elif grid[r][c] == 'O':
                boxes.append((r, c))

    def is_valid(r, c):
        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#'

    def move_robot(direction):
        nonlocal robot_row, robot_col
        dr, dc = 0, 0
        if direction == '^':
            dr = -1
        elif direction == 'v':
            dr = 1
        elif direction == '<':
            dc = -1
        elif direction == '>':
            dc = 1

        new_robot_row, new_robot_col = robot_row + dr, robot_col + dc

        if not is_valid(new_robot_row, new_robot_col):
            return  # Robot can't move due to wall

        # Check if there's a box in the way
        box_index = None
        for i, (box_row, box_col) in enumerate(boxes):
            if box_row == new_robot_row and box_col == new_robot_col:
                box_index = i
                break

        if box_index is not None:
            # Attempt to move the box
            new_box_row, new_box_col = new_robot_row + dr, new_robot_col + dc
            if not is_valid(new_box_row, new_box_col):
                return  # Box can't be moved, so robot doesn't move either

            #Check if another box is in the way of the box being moved
            another_box_index = None
            for i, (other_box_row, other_box_col) in enumerate(boxes):
                if i != box_index and other_box_row == new_box_row and other_box_col == new_box_col:
                    another_box_index = i
                    break
            if another_box_index is not None:
                return

            # Move the box
            boxes[box_index] = (new_box_row, new_box_col)

            # Update map (not strictly necessary, but good for debugging)
            grid[new_box_row][new_box_col] = 'O'
            grid[robot_row][robot_col] = '.'
            grid[new_robot_row][new_robot_col] = '@'

            # Move the robot
            robot_row, robot_col = new_robot_row, new_robot_col

        else:
            # No box in the way, just move the robot
            grid[robot_row][robot_col] = '.'
            grid[new_robot_row][new_robot_col] = '@'
            robot_row, robot_col = new_robot_row, new_robot_col

    # Execute the move sequence
    for move in move_sequence:
        move_robot(move)

    # Calculate the GPS coordinates sum
    gps_sum = 0
    for box_row, box_col in boxes:
        gps_sum += 100 * box_row + box_col

    return gps_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    warehouse_map, move_sequence = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(warehouse_map, move_sequence)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
15,system,gemini-2.0-flash,False,223.40315580368042,
16,single-model,gemini-2.0-flash,False,7.245905637741089,"""""""
Advent of Code 2023 Day 16: Reindeer Maze
Solution implementation based on the provided problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Optional
import sys
from collections import deque

def parse_input(input_file: str) -> Tuple[List[str], Tuple[int, int], Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of strings representing the maze,
    the start coordinates, and the end coordinates.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - The maze as a list of strings.
            - The start coordinates (row, col).
            - The end coordinates (row, col).
    """"""
    maze: List[str] = []
    start: Optional[Tuple[int, int]] = None
    end: Optional[Tuple[int, int]] = None

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            maze.append(line.strip())
            for c, char in enumerate(line.strip()):
                if char == 'S':
                    start = (r, c)
                elif char == 'E':
                    end = (r, c)

    if start is None or end is None:
        raise ValueError(""Start or end position not found in the maze."")

    return maze, start, end


def solve_part_one(maze: List[str], start: Tuple[int, int], end: Tuple[int, int]) -> int:
    """"""Solve part one of the puzzle using BFS.

    Args:
        maze: The maze represented as a list of strings.
        start: The starting coordinates (row, col).
        end: The ending coordinates (row, col).

    Returns:
        The lowest score to reach the end.
    """"""
    rows = len(maze)
    cols = len(maze[0])

    # Define possible directions: East (0), South (1), West (2), North (3)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # State: (row, col, direction)
    # Cost: score to reach the state
    queue = deque([(start[0], start[1], 0, 0)])  # (row, col, direction, cost)

    # Visited states to avoid cycles. Store the minimum cost to reach a given state.
    visited: dict[Tuple[int, int, int], int] = {}

    while queue:
        row, col, direction, cost = queue.popleft()

        # Check if we reached the end
        if (row, col) == end:
            return cost

        # Check if we've already visited this state with a lower cost
        if (row, col, direction) in visited and visited[(row, col, direction)] <= cost:
            continue

        # Mark the current state as visited with the current cost
        visited[(row, col, direction)] = cost

        # Possible actions: move forward, turn clockwise, turn counterclockwise
        # 1. Move forward
        new_row = row + directions[direction][0]
        new_col = col + directions[direction][1]

        if 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':
            queue.append((new_row, new_col, direction, cost + 1))

        # 2. Turn clockwise
        new_direction = (direction + 1) % 4
        queue.append((row, col, new_direction, cost + 1000))

        # 3. Turn counterclockwise
        new_direction = (direction - 1) % 4
        queue.append((row, col, new_direction, cost + 1000))

    return -1  # No path found


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    maze, start, end = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(maze, start, end)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
16,system,gemini-2.0-flash,False,169.6530478000641,
17,single-model,gemini-2.0-flash,False,8.010474920272827,"""""""
Advent of Code 2023 Day 17: Chronospatial Computer
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from file into initial register values and the program.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a dictionary of initial register values and a list of integers representing the program.
    """"""
    registers = {}
    program = []

    with open(input_file, 'r') as f:
        # Read register values
        for i in range(3):
            line = f.readline().strip()
            register, value = line.split(': ')  # Split line into 'Register A' and '729'
            register_name = register.split(' ')[1] # Split register name and only keep the name
            registers[register_name] = int(value)

        # Read program
        f.readline() # Read the empty line
        program_line = f.readline().strip()
        program = [int(x) for x in program_line.split(',')]

    return registers, program


def execute_program(registers: Dict[str, int], program: List[int]) -> str:
    """"""Execute the 3-bit computer program and return the output.

    Args:
        registers: A dictionary containing the initial values of registers A, B, and C.
        program: A list of integers representing the program.

    Returns:
        A string containing the comma-separated output of the program.
    """"""
    instruction_pointer = 0
    output = []

    while instruction_pointer < len(program):
        opcode = program[instruction_pointer]
        if instruction_pointer + 1 >= len(program):
            break # halt if we are past the end of the program.
        operand = program[instruction_pointer + 1]

        if opcode == 0:  # adv
            divisor = 2 ** get_combo_operand_value(operand, registers)
            registers['A'] = registers['A'] // divisor if divisor != 0 else 0
            instruction_pointer += 2
        elif opcode == 1:  # bxl
            registers['B'] = registers['B'] ^ operand
            instruction_pointer += 2
        elif opcode == 2:  # bst
            registers['B'] = get_combo_operand_value(operand, registers) % 8
            instruction_pointer += 2
        elif opcode == 3:  # jnz
            if registers['A'] != 0:
                instruction_pointer = operand
            else:
                instruction_pointer += 2
        elif opcode == 4:  # bxc
            registers['B'] = registers['B'] ^ registers['C']
            instruction_pointer += 2
        elif opcode == 5:  # out
            output_value = get_combo_operand_value(operand, registers) % 8
            output.append(str(output_value))
            instruction_pointer += 2
        elif opcode == 6:  # bdv
            divisor = 2 ** get_combo_operand_value(operand, registers)
            registers['B'] = registers['A'] // divisor if divisor != 0 else 0
            instruction_pointer += 2
        elif opcode == 7:  # cdv
            divisor = 2 ** get_combo_operand_value(operand, registers)
            registers['C'] = registers['A'] // divisor if divisor != 0 else 0
            instruction_pointer += 2
        else:
            break  # Halt on invalid opcode

    return ','.join(output)


def get_combo_operand_value(operand: int, registers: Dict[str, int]) -> int:
    """"""Get the value of a combo operand.

    Args:
        operand: The combo operand value (0-7).
        registers: A dictionary containing the values of registers A, B, and C.

    Returns:
        The value of the combo operand.
    """"""
    if 0 <= operand <= 3:
        return operand
    elif operand == 4:
        return registers['A']
    elif operand == 5:
        return registers['B']
    elif operand == 6:
        return registers['C']
    else:
        return 0  # Should not happen according to problem statement


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    registers, program = parse_input(input_file)

    # Solve part one
    part_one_solution = execute_program(registers, program)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
17,system,gemini-2.0-flash,False,124.81015992164612,
18,single-model,gemini-2.0-flash,True,5.3043835163116455,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Deque
import sys
from collections import deque

def parse_input(input_file: str) -> List[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of (x, y) coordinates.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple represents the (x, y) coordinates of a falling byte.
    """"""
    byte_positions = []
    with open(input_file, 'r') as f:
        for line in f:
            x, y = map(int, line.strip().split(','))
            byte_positions.append((x, y))
    return byte_positions

def solve_part_one(byte_positions: List[Tuple[int, int]], grid_size: int) -> int:
    """"""Solve part one of the puzzle.

    Args:
        byte_positions: A list of (x, y) coordinates of falling bytes.
        grid_size: The size of the memory grid (0 to grid_size inclusive).

    Returns:
        The minimum number of steps needed to reach the exit (grid_size, grid_size), or -1 if no path exists.
    """"""
    corrupted = set()
    for x, y in byte_positions[:1024]:  # Simulate the first 1024 bytes
        corrupted.add((x, y))

    start = (0, 0)
    end = (grid_size, grid_size)

    if start in corrupted or end in corrupted:
        return -1 # No path possible

    queue: Deque[Tuple[Tuple[int, int], int]] = deque([(start, 0)])  # (position, steps)
    visited = {start}

    while queue:
        (x, y), steps = queue.popleft()

        if (x, y) == end:
            return steps

        # Possible moves (up, down, left, right)
        moves = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        for dx, dy in moves:
            nx, ny = x + dx, y + dy

            # Check boundaries and if the new position is corrupted or visited
            if 0 <= nx <= grid_size and 0 <= ny <= grid_size and (nx, ny) not in corrupted and (nx, ny) not in visited:
                queue.append(((nx, ny), steps + 1))
                visited.add((nx, ny))

    return -1  # No path found

def main():
    """"""Main function to parse input, solve the puzzle, and print the result.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    byte_positions = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(byte_positions, 70)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
18,system,gemini-2.0-flash,True,162.65795731544495,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
from collections import deque

def parse_input(input_file: str) -> Set[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a set of corrupted coordinates.

    Args:
        input_file: Path to the input file

    Returns:
        A set of tuples representing corrupted coordinates.
    """"""
    corrupted_coords: Set[Tuple[int, int]] = set()
    with open(input_file, 'r') as f:
        lines = f.readlines()
        for i, line in enumerate(lines):
            if i >= 1024:
                break
            x_str, y_str = line.strip().split(',')
            x, y = int(x_str), int(y_str)
            # Ensure coordinates are within the grid range
            if 0 <= x <= 70 and 0 <= y <= 70:
                corrupted_coords.add((x, y))
    return corrupted_coords

def solve_part_one(corrupted_coords: Set[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        corrupted_coords: A set of corrupted coordinates.

    Returns:
        The minimum number of steps to reach (70, 70) or -1 if no path exists.
    """"""
    queue: deque[Tuple[int, int, int]] = deque([(0, 0, 0)])
    visited: Set[Tuple[int, int]] = set([(0, 0)])
    grid_size: int = 71
    moves: List[Tuple[int, int]] = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        x, y, distance = queue.popleft()

        if x == 70 and y == 70:
            return distance

        for dx, dy in moves:
            new_x, new_y = x + dx, y + dy

            if (0 <= new_x < grid_size and 0 <= new_y < grid_size and
                    (new_x, new_y) not in corrupted_coords and (new_x, new_y) not in visited):
                queue.append((new_x, new_y, distance + 1))
                visited.add((new_x, new_y))

    return -1

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
19,single-model,gemini-2.0-flash,True,6.56246280670166,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and desired designs.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of towel patterns and a list of desired designs.
    """"""
    with open(input_file, 'r') as f:
        content = f.read().strip()
        parts = content.split('\n\n')
        towel_patterns = parts[0].split(', ')
        desired_designs = parts[1].splitlines()
    return towel_patterns, desired_designs


def can_make_design(design: str, towel_patterns: List[str]) -> bool:
    """"""Check if a design can be made using the available towel patterns.

    Args:
        design: The desired design.
        towel_patterns: The available towel patterns.

    Returns:
        True if the design can be made, False otherwise.
    """"""
    dp = [False] * (len(design) + 1)
    dp[0] = True

    for i in range(1, len(design) + 1):
        for pattern in towel_patterns:
            if i >= len(pattern) and design[i-len(pattern):i] == pattern:
                dp[i] = dp[i] or dp[i - len(pattern)]

    return dp[len(design)]


def solve_part_one(towel_patterns: List[str], desired_designs: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        towel_patterns: The available towel patterns.
        desired_designs: The desired designs.

    Returns:
        The number of designs that are possible to make.
    """"""
    possible_designs_count = 0
    for design in desired_designs:
        if can_make_design(design, towel_patterns):
            possible_designs_count += 1
    return possible_designs_count


def main():
    """"""Main function to execute the solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    towel_patterns, desired_designs = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(towel_patterns, desired_designs)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
19,system,gemini-2.0-flash,True,76.88302898406982,"'''
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
'''

from typing import List, Dict, Tuple, Set, Optional
import sys

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and designs.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of towel patterns and a list of desired designs.
    """"""
    with open(input_file, 'r') as f:
        data = f.read().strip()
        parts = data.split('\n\n')
        patterns = [p.strip() for p in parts[0].split(',')]
        designs = [d.strip() for d in parts[1].splitlines()]
    return patterns, designs

def can_construct(design: str, patterns_set: Set[str], memo: Dict[str, bool]) -> bool:
    """"""Recursively determine if a design can be constructed from available patterns using memoization.

    Args:
        design: The design string to construct.
        patterns_set: A set of available towel patterns.
        memo: A dictionary to store memoization results.

    Returns:
        True if the design can be constructed, False otherwise.
    """"""
    if design in memo:
        return memo[design]

    if not design:
        return True

    for i in range(1, len(design) + 1):
        prefix = design[:i]
        if prefix in patterns_set:
            suffix = design[i:]
            if can_construct(suffix, patterns_set, memo):
                memo[design] = True
                return True

    memo[design] = False
    return False

def solve(patterns: List[str], designs: List[str]) -> int:
    """"""Calculate the number of designs that can be constructed from the available patterns.

    Args:
        patterns: A list of available towel patterns.
        designs: A list of desired designs.

    Returns:
        The number of possible designs.
    """"""
    patterns_set = set(patterns)
    memo: Dict[str, bool] = {}
    count = 0

    for design in designs:
        if can_construct(design, patterns_set, memo):
            count += 1

    return count

def main():
    """"""Main function to execute the solution.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    patterns, designs = parse_input(input_file)

    # Solve
    solution = solve(patterns, designs)

    # Print result
    print(solution)

if __name__ == ""__main__"":
    main()
"
20,single-model,gemini-2.0-flash,False,18.495046854019165,"""""""
Advent of Code 2023 Day 20: Race Condition
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Dict
import sys
from collections import deque

def parse_input(input_file: str) -> List[str]:
    """"""Parse the puzzle input from file into a list of strings.

    Args:
        input_file: Path to the input file

    Returns:
        A list of strings, where each string represents a row in the racetrack.
    """"""
    with open(input_file, 'r') as f:
        return [line.strip() for line in f]

def find_start_and_end(racetrack: List[str]) -> Tuple[Tuple[int, int], Tuple[int, int]]:
    """"""Find the start and end positions in the racetrack.

    Args:
        racetrack: A list of strings representing the racetrack.

    Returns:
        A tuple containing the start and end positions as (row, col) tuples.
    """"""
    start = None
    end = None
    for r, row in enumerate(racetrack):
        for c, cell in enumerate(row):
            if cell == 'S':
                start = (r, c)
            elif cell == 'E':
                end = (r, c)
    if start is None or end is None:
        raise ValueError(""Start or end position not found in racetrack."")
    return start, end

def solve_part_one(racetrack: List[str]) -> int:
    """"""Solve part one of the puzzle by finding the shortest path without cheating.

    Args:
        racetrack: A list of strings representing the racetrack.

    Returns:
        The shortest path length from start to end without cheating.
    """"""
    start, end = find_start_and_end(racetrack)
    rows = len(racetrack)
    cols = len(racetrack[0])

    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    visited = {start}

    while queue:
        r, c, dist = queue.popleft()

        if (r, c) == end:
            return dist

        # Possible moves: up, down, left, right
        moves = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

        for nr, nc in moves:
            if 0 <= nr < rows and 0 <= nc < cols and racetrack[nr][nc] != '#' and (nr, nc) not in visited:
                queue.append((nr, nc, dist + 1))
                visited.add((nr, nc))

    return float('inf')  # No path found

def find_all_cheats(racetrack: List[str]) -> Dict[Tuple[Tuple[int, int], Tuple[int, int]], int]:
    """"""Find all possible cheats and their saved picoseconds.

    Args:
        racetrack: A list of strings representing the racetrack.

    Returns:
        A dictionary where keys are tuples of ((start_row, start_col), (end_row, end_col)) and values are the saved picoseconds.
    """"""
    start, end = find_start_and_end(racetrack)
    rows = len(racetrack)
    cols = len(racetrack[0])
    shortest_path = solve_part_one(racetrack)
    cheats = {}

    for r1 in range(rows):
        for c1 in range(cols):
            if racetrack[r1][c1] == '#':
                continue
            for r2 in range(rows):
                for c2 in range(cols):
                    if racetrack[r2][c2] == '#':
                        continue
                    if (r1, c1) == (r2, c2):
                        continue

                    # Try cheating from (r1, c1) to (r2, c2)
                    # Temporarily replace walls with track
                    original_racetrack = [list(row) for row in racetrack]
                    #find path from start to r1c1 without cheating
                    racetrack2 = ["""" for _ in range(len(racetrack))]
                    for i in range(len(racetrack)): racetrack2[i] = """".join(original_racetrack[i])
                    temp_racetrack = racetrack2
                    rows2 = len(temp_racetrack)
                    cols2 = len(temp_racetrack[0])

                    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
                    visited = {start}
                    dist_start_r1c1 = float('inf')
                    while queue:
                        r, c, dist = queue.popleft()

                        if (r, c) == (r1,c1):
                            dist_start_r1c1 = dist
                            break

                        # Possible moves: up, down, left, right
                        moves = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

                        for nr, nc in moves:
                            if 0 <= nr < rows2 and 0 <= nc < cols2 and temp_racetrack[nr][nc] != '#' and (nr, nc) not in visited:
                                queue.append((nr, nc, dist + 1))
                                visited.add((nr, nc))
                    #find path from r2c2 to end without cheating
                    temp_racetrack = racetrack2
                    rows2 = len(temp_racetrack)
                    cols2 = len(temp_racetrack[0])

                    queue = deque([(r2, c2, 0)])  # (row, col, distance)
                    visited = {(r2,c2)}
                    dist_r2c2_end = float('inf')
                    while queue:
                        r, c, dist = queue.popleft()

                        if (r, c) == end:
                            dist_r2c2_end = dist
                            break

                        # Possible moves: up, down, left, right
                        moves = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

                        for nr, nc in moves:
                            if 0 <= nr < rows2 and 0 <= nc < cols2 and temp_racetrack[nr][nc] != '#' and (nr, nc) not in visited:
                                queue.append((nr, nc, dist + 1))
                                visited.add((nr, nc))

                    cheated_path = dist_start_r1c1 + dist_r2c2_end + 2 #add 2 for cheating
                    saved_picoseconds = shortest_path - cheated_path
                    # Restore original racetrack

                    if saved_picoseconds > 0 and dist_start_r1c1 != float('inf') and dist_r2c2_end != float('inf'):
                        cheats[((r1, c1), (r2, c2))] = saved_picoseconds
                    racetrack = ["""" for _ in range(len(original_racetrack))]
                    for i in range(len(original_racetrack)): racetrack[i] = """".join(original_racetrack[i])
    return cheats

def solve_part_two(racetrack: List[str]) -> int:
    """"""Solve part two of the puzzle by counting the number of cheats that save at least 100 picoseconds.

    Args:
        racetrack: A list of strings representing the racetrack.

    Returns:
        The number of cheats that save at least 100 picoseconds.
    """"""
    cheats = find_all_cheats(racetrack)
    count = 0
    for cheat, saved_time in cheats.items():
        if saved_time >= 100:
            count += 1
    return count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    racetrack = parse_input(input_file)

    # Solve part two
    part_two_solution = solve_part_two(racetrack)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_two_solution)

if __name__ == ""__main__"":
    main()
"
20,system,gemini-2.0-flash,False,217.6305136680603,
21,single-model,gemini-2.0-flash,False,8.424981355667114,NO CODE
21,system,gemini-2.0-flash,False,174.30388736724854,
22,single-model,gemini-2.0-flash,True,5.358968019485474,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the provided problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def process_secret(secret: int) -> int:
    """"""Calculates the next secret number based on the given rules.

    Args:
        secret: The current secret number.

    Returns:
        The next secret number in the sequence.
    """"""
    # Multiply by 64, mix, prune
    secret = (secret * 64) ^ secret
    secret %= 16777216

    # Divide by 32, mix, prune
    secret = (secret // 32) ^ secret
    secret %= 16777216

    # Multiply by 2048, mix, prune
    secret = (secret * 2048) ^ secret
    secret %= 16777216

    return secret

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of initial secret numbers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial secret numbers for each buyer.
    """"""
    secrets = []
    with open(input_file, 'r') as f:
        for line in f:
            secrets.append(int(line.strip()))
    return secrets

def solve_part_one(initial_secrets: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        initial_secrets: A list of initial secret numbers.

    Returns:
        The sum of the 2000th secret number generated by each buyer.
    """"""
    total_sum = 0
    for initial_secret in initial_secrets:
        secret = initial_secret
        for _ in range(2000):
            secret = process_secret(secret)
        total_sum += secret
    return total_sum

def main():
    """"""Main function to execute the solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_secrets = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_secrets)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
22,system,gemini-2.0-flash,True,118.1220064163208,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial secret numbers of the buyers.
    """"""
    secret_numbers = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                try:
                    secret_numbers.append(int(line.strip()))
                except ValueError:
                    print(f""Error: Invalid input '{line.strip()}' in input file."", file=sys.stderr)
                    return []  # Or raise an exception
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        return []  # Or raise an exception

    return secret_numbers


def update_step_1(secret_number: int, original_secret_number: int) -> int:
    """"""Implements the first update operation on the secret number.

    Args:
        secret_number: The current secret number (integer).
        original_secret_number: The original secret number (integer before this step).

    Returns:
        The updated secret number after the first operation (integer).
    """"""
    multiplied = secret_number * 64
    xored = multiplied ^ original_secret_number
    modulo = xored % 16777216
    return modulo


def update_step_2(secret_number: int, original_secret_number: int) -> int:
    """"""Implements the second update operation on the secret number.

    Args:
        secret_number: The current secret number (integer).
        original_secret_number: The original secret number (integer before this step).

    Returns:
        The updated secret number after the second operation (integer).
    """"""
    divided = secret_number // 32
    xored = divided ^ original_secret_number
    modulo = xored % 16777216
    return modulo


def update_step_3(secret_number: int, original_secret_number: int) -> int:
    """"""Implements the third update operation on the secret number.

    Args:
        secret_number: The current secret number (integer).
        original_secret_number: The original secret number (integer before this step).

    Returns:
        The updated secret number after the third operation (integer).
    """"""
    multiplied = secret_number * 2048
    xored = multiplied ^ original_secret_number
    modulo = xored % 16777216
    return modulo


def simulate_secret_number_generation(initial_secret_number: int) -> int:
    """"""Simulate the pseudorandom number generation for a single buyer.

    Args:
        initial_secret_number: An initial secret number (integer).

    Returns:
        The 2000th generated secret number (integer).
    """"""
    secret_number = initial_secret_number
    for _ in range(2000):
        original_number = secret_number
        secret_number = update_step_1(secret_number, original_number)
        original_number = secret_number
        secret_number = update_step_2(secret_number, original_number)
        original_number = secret_number
        secret_number = update_step_3(secret_number, original_number)

    return secret_number


def calculate_sum_of_2000th_secret_numbers(initial_secret_numbers: List[int]) -> int:
    """"""Calculate the sum of the 2000th secret number for each buyer.

    Args:
        initial_secret_numbers: The list of initial secret numbers.

    Returns:
        The sum of the 2000th secret numbers (integer).
    """"""
    total_sum = 0
    for initial_secret_number in initial_secret_numbers:
        total_sum += simulate_secret_number_generation(initial_secret_number)

    return total_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    initial_secret_numbers = parse_input(input_file)

    if not initial_secret_numbers:
        return

    # Solve part one
    final_sum = calculate_sum_of_2000th_secret_numbers(initial_secret_numbers)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(final_sum)


if __name__ == ""__main__"":
    main()
"
23,single-model,gemini-2.0-flash,True,7.834240436553955,"""""""
Advent of Code 2023 Day 23: LAN Party
Solution implementation based on the provided problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Dict[str, Set[str]]:
    """"""Parse the puzzle input from file into a dictionary representing the network.

    Args:
        input_file: Path to the input file

    Returns:
        A dictionary where keys are computer names (strings) and values are sets of
        connected computer names (strings).
    """"""
    network: Dict[str, Set[str]] = defaultdict(set)
    with open(input_file, 'r') as f:
        for line in f:
            computer1, computer2 = line.strip().split('-')
            network[computer1].add(computer2)
            network[computer2].add(computer1)
    return network

def find_interconnected_sets(network: Dict[str, Set[str]]) -> List[Tuple[str, str, str]]:
    """"""Find all sets of three inter-connected computers in the network.

    Args:
        network: A dictionary representing the network connections.

    Returns:
        A list of tuples, where each tuple contains three computer names that form an
        inter-connected set.
    """"""
    computers = list(network.keys())
    interconnected_sets: List[Tuple[str, str, str]] = []
    for i in range(len(computers)):
        for j in range(i + 1, len(computers)):
            for k in range(j + 1, len(computers)):
                comp1 = computers[i]
                comp2 = computers[j]
                comp3 = computers[k]
                if comp2 in network[comp1] and comp3 in network[comp1] and comp3 in network[comp2]:
                    interconnected_sets.append(tuple(sorted((comp1, comp2, comp3))))
    return interconnected_sets

def solve_part_one(network: Dict[str, Set[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        network: A dictionary representing the network connections.

    Returns:
        The number of inter-connected sets that contain at least one computer
        with a name that starts with 't'.
    """"""
    interconnected_sets = find_interconnected_sets(network)
    count = 0
    for set_ in interconnected_sets:
        if any(comp.startswith('t') for comp in set_):
            count += 1
    return count

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
23,system,gemini-2.0-flash,True,106.149667263031,"""""""
Advent of Code 2023 Day 23: LAN Party
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set
import sys
from itertools import combinations

def parse_input(input_file: str) -> Tuple[Dict[str, Set[str]], Set[str], Set[str]]:
    """"""Parse the puzzle input from file into a graph (adjacency list), a set of nodes, and a set of computers with names starting with 't'.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - graph (Dict[str, Set[str]]): Adjacency list representing the network.
        - nodes (Set[str]): Set of all unique computer names.
        - computers_with_t (Set[str]): Set of computer names starting with 't'.
    """"""
    graph: Dict[str, Set[str]] = {}
    nodes: Set[str] = set()
    computers_with_t: Set[str] = set()

    with open(input_file, 'r') as f:
        for line in f:
            computer1, computer2 = line.strip().split('-')
            nodes.add(computer1)
            nodes.add(computer2)

            if computer1.startswith('t'):
                computers_with_t.add(computer1)
            if computer2.startswith('t'):
                computers_with_t.add(computer2)

            if computer1 not in graph:
                graph[computer1] = set()
            if computer2 not in graph:
                graph[computer2] = set()

            graph[computer1].add(computer2)
            graph[computer2].add(computer1)

    return graph, nodes, computers_with_t


def solve_part_one(graph: Dict[str, Set[str]], nodes: Set[str], computers_with_t: Set[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        graph: Adjacency list representing the network.
        nodes: Set of all unique computer names.
        computers_with_t: Set of computer names starting with 't'.

    Returns:
        The number of sets of three inter-connected computers where at least one computer's name starts with 't'.
    """"""
    cliques: List[Tuple[str, str, str]] = []

    for combination in combinations(nodes, 3):
        a, b, c = combination
        if (b in graph[a] and
            c in graph[a] and
            c in graph[b]):
            if (a in computers_with_t or
                b in computers_with_t or
                c in computers_with_t):
                sorted_clique = tuple(sorted((a, b, c)))
                if sorted_clique not in cliques:
                    cliques.append(sorted_clique)

    return len(cliques)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    graph, nodes, computers_with_t = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(graph, nodes, computers_with_t)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
24,single-model,gemini-2.0-flash,False,14.602813005447388,"""""""
Advent of Code 2023 Day 24: Crossed Wires
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[Tuple[str, str, str, str]]]:
    """"""Parse the puzzle input from file into appropriate data structures.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A dictionary of initial wire values (wire_name: value).
        - A list of gate instructions. Each instruction is a tuple:
          (input_wire1, operation, input_wire2, output_wire).
          If operation is None, input_wire2 is None.
    """"""
    initial_values = {}
    gate_instructions = []

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if "":"" in line:
                wire, value = line.split("": "")
                initial_values[wire] = int(value)
            elif ""->"" in line:
                parts = line.split("" "")
                if len(parts) == 3:
                    # Direct assignment: wire -> target
                    input_wire = parts[0]
                    output_wire = parts[2]
                    gate_instructions.append((input_wire, ""ASSIGN"", None, output_wire))
                elif len(parts) == 5:
                    # Two-input gate: wire1 OP wire2 -> target
                    input_wire1 = parts[0]
                    operation = parts[1]
                    input_wire2 = parts[2]
                    output_wire = parts[4]
                    gate_instructions.append((input_wire1, operation, input_wire2, output_wire))
                elif len(parts) == 4: # NOT operation
                    operation = parts[0]
                    input_wire = parts[1]
                    output_wire = parts[3]
                    gate_instructions.append((input_wire, operation, None, output_wire))

    return initial_values, gate_instructions

def solve_part_one(initial_values: Dict[str, int], gate_instructions: List[Tuple[str, str, str, str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        initial_values: Initial wire values.
        gate_instructions: List of gate instructions.

    Returns:
        The decimal number output on the wires starting with 'z'.
    """"""
    wires = initial_values.copy()

    # Keep simulating until no new values are computed in an iteration.
    while True:
        new_values_computed = False
        for instruction in gate_instructions:
            input_wire1, operation, input_wire2, output_wire = instruction

            if output_wire not in wires:
                try:
                    if operation == ""ASSIGN"":
                        wires[output_wire] = wires[input_wire1]
                        new_values_computed = True
                    elif operation == ""AND"":
                        if input_wire1 in wires and input_wire2 in wires:
                            wires[output_wire] = wires[input_wire1] & wires[input_wire2]
                            new_values_computed = True
                    elif operation == ""OR"":
                        if input_wire1 in wires and input_wire2 in wires:
                            wires[output_wire] = wires[input_wire1] | wires[input_wire2]
                            new_values_computed = True
                    elif operation == ""XOR"":
                        if input_wire1 in wires and input_wire2 in wires:
                            wires[output_wire] = wires[input_wire1] ^ wires[input_wire2]
                            new_values_computed = True
                    elif operation == ""NOT"":
                        if input_wire1 in wires:
                            wires[output_wire] = 1 - wires[input_wire1]
                            new_values_computed = True
                except KeyError:
                    pass # One or more input wires don't have values yet.

        if not new_values_computed:
            break

    # Extract the z wires and combine them into a binary string.
    z_wires = []
    for wire, value in wires.items():
        if wire.startswith(""z""):
            z_wires.append((wire, value))

    z_wires.sort(key=lambda x: int(x[0][1:]))

    binary_string = """".join(str(value) for wire, value in z_wires)

    # Convert the binary string to an integer.
    if binary_string:
        decimal_number = int(binary_string, 2)
    else:
        decimal_number = 0

    return decimal_number

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_values, gate_instructions = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_values, gate_instructions)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Example testing code:
    # initial_values_example = {""x00"": 1, ""x01"": 0, ""x02"": 1, ""x03"": 1, ""x04"": 0,
    #                         ""y00"": 1, ""y01"": 1, ""y02"": 1, ""y03"": 1, ""y04"": 1}
    # gate_instructions_example = [
    #     (""ntg"", ""XOR"", ""fgs"", ""mjb""),
    #     (""y02"", ""OR"", ""x01"", ""tnw""),
    #     (""kwq"", ""OR"", ""kpj"", ""z05""),
    #     (""x00"", ""OR"", ""x03"", ""fst""),
    #     (""tgd"", ""XOR"", ""rvg"", ""z01""),
    #     (""vdt"", ""OR"", ""tnw"", ""bfw""),
    #     (""bfw"", ""AND"", ""frj"", ""z10""),
    #     (""ffh"", ""OR"", ""nrd"", ""bqk""),
    #     (""y00"", ""AND"", ""y03"", ""djm""),
    #     (""y03"", ""OR"", ""y00"", ""psh""),
    #     (""bqk"", ""OR"", ""frj"", ""z08""),
    #     (""tnw"", ""OR"", ""fst"", ""frj""),
    #     (""gnj"", ""AND"", ""tgd"", ""z11""),
    #     (""bfw"", ""XOR"", ""mjb"", ""z00""),
    #     (""x03"", ""OR"", ""x00"", ""vdt""),
    #     (""gnj"", ""AND"", ""wpb"", ""z02""),
    #     (""x04"", ""AND"", ""y00"", ""kjc""),
    #     (""djm"", ""OR"", ""pbm"", ""qhw""),
    #     (""nrd"", ""AND"", ""vdt"", ""hwm""),
    #     (""kjc"", ""AND"", ""fst"", ""rvg""),
    #     (""y04"", ""OR"", ""y02"", ""fgs""),
    #     (""y01"", ""AND"", ""x02"", ""pbm""),
    #     (""ntg"", ""OR"", ""kjc"", ""kwq""),
    #     (""psh"", ""XOR"", ""fgs"", ""tgd""),
    #     (""qhw"", ""XOR"", ""tgd"", ""z09""),
    #     (""pbm"", ""OR"", ""djm"", ""kpj""),
    #     (""x03"", ""XOR"", ""y03"", ""ffh""),
    #     (""x00"", ""XOR"", ""y04"", ""ntg""),
    #     (""bfw"", ""OR"", ""bqk"", ""z06""),
    #     (""nrd"", ""XOR"", ""fgs"", ""wpb""),
    #     (""frj"", ""XOR"", ""qhw"", ""z04""),
    #     (""bqk"", ""OR"", ""frj"", ""z07""),
    #     (""y03"", ""OR"", ""x01"", ""nrd""),
    #     (""hwm"", ""AND"", ""bqk"", ""z03""),
    #     (""tgd"", ""XOR"", ""rvg"", ""z12""),
    #     (""tnw"", ""OR"", ""pbm"", ""gnj"")
    # ]

    # expected_output = 2024
    # actual_output = solve_part_one(initial_values_example, gate_instructions_example)
    # print(f""Example Output: {actual_output}"", file=sys.stderr)
    # assert actual_output == expected_output


if __name__ == ""__main__"":
    main()
"
24,system,gemini-2.0-flash,True,85.56309723854065,"""""""
Advent of Code 2023 Day 24: Crossed Wires
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], Dict[str, Tuple[str, str, str]]]:
    """"""Parse the puzzle input from file into initial wire values and gate connections.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two dictionaries:
        - The first dictionary maps wire names to initial values (0 or 1).
        - The second dictionary maps output wire names to a tuple containing (input wire 1, gate type, input wire 2).
    """"""
    initial_values: Dict[str, int] = {}
    gate_connections: Dict[str, Tuple[str, str, str]] = {}

    with open(input_file, 'r') as f:
        lines = f.read().splitlines()

    # Parse initial wire values
    i = 0
    while lines[i] != '':
        line = lines[i]
        wire, value = line.split(': ')
        initial_values[wire] = int(value)
        i += 1

    # Parse gate connections
    i += 1  # Skip the empty line
    for line in lines[i:]:
        parts = line.split(' -> ')
        if len(parts) != 2:
            continue # Handle lines with unexpected format, by skiping them.
        left, output_wire = parts
        left_parts = left.split()
        if len(left_parts) == 3:
            wire1, gate_type, wire2 = left_parts
            gate_connections[output_wire] = (wire1, gate_type, wire2)
        else:
            print(f""Unexpected gate connections format: {line}"", file=sys.stderr)

    return initial_values, gate_connections


def solve_part_one(initial_values: Dict[str, int], gate_connections: Dict[str, Tuple[str, str, str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        initial_values: A dictionary mapping wire names to initial values (0 or 1).
        gate_connections: A dictionary mapping output wire names to a tuple containing (input wire 1, gate type, input wire 2).

    Returns:
        The decimal number represented by the wires starting with 'z'.
    """"""
    calculated_values: Dict[str, int] = initial_values.copy()
    new_values_calculated = True

    while new_values_calculated:
        new_values_calculated = False
        for output_wire, (wire1, gate_type, wire2) in gate_connections.items():
            if output_wire in calculated_values:
                continue
            if wire1 in calculated_values and wire2 in calculated_values:
                val1 = calculated_values[wire1]
                val2 = calculated_values[wire2]
                if gate_type == 'AND':
                    calculated_values[output_wire] = val1 & val2
                elif gate_type == 'OR':
                    calculated_values[output_wire] = val1 | val2
                elif gate_type == 'XOR':
                    calculated_values[output_wire] = val1 ^ val2
                else:
                    print(f""Unknown gate type: {gate_type}"", file=sys.stderr)
                    continue
                new_values_calculated = True

    z_wires: List[int] = []
    for wire, value in calculated_values.items():
        if wire.startswith('z'):
            z_wires.append((wire, value))

    z_wires.sort(key=lambda x: x[0])

    decimal_value = 0
    for i, (wire, value) in enumerate(z_wires):
        decimal_value += value * (2 ** i)

    return decimal_value


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_values, gate_connections = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_values, gate_connections)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
25,single-model,gemini-2.0-flash,False,5.254719018936157,"""""""
Advent of Code 2023 Day 25: Code Chronicle
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[List[List[int]], List[List[int]]]:
    """"""Parse the puzzle input from file into locks and keys.

    Args:
        input_file: Path to the input file

    Returns:
        Tuple of locks (list of pin heights) and keys (list of key heights).
    """"""
    with open(input_file, 'r') as f:
        schematics = f.read().strip().split(""\n\n"")

    locks_schematics = schematics[:2]
    keys_schematics = schematics[2:]

    locks = []
    for lock_schematic in locks_schematics:
        lock_rows = lock_schematic.splitlines()
        num_cols = len(lock_rows[0])
        lock_heights = []
        for col in range(num_cols):
            height = 0
            for row in range(len(lock_rows)):
                if lock_rows[row][col] == '#':
                    height += 1
                else:
                    break
            lock_heights.append(height)
        locks.append(lock_heights)

    keys = []
    for key_schematic in keys_schematics:
        key_rows = key_schematic.splitlines()
        num_cols = len(key_rows[0])
        key_heights = []
        for col in range(num_cols):
            height = 0
            for row in range(len(key_rows) - 1, -1, -1):
                if key_rows[row][col] == '#':
                    height += 1
                else:
                    break
            key_heights.append(height)
        keys.append(key_heights)

    return locks, keys


def solve_part_one(locks: List[List[int]], keys: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        locks: List of pin heights for each lock.
        keys: List of key heights for each key.

    Returns:
        Number of lock/key pairs that fit together.
    """"""
    count = 0
    for lock in locks:
        for key in keys:
            if len(lock) != len(key):
                continue # Should not happen according to prompt, but added for safety
            fits = True
            for i in range(len(lock)):
                if lock[i] + key[i] > 7:
                    fits = False
                    break
            if fits:
                count += 1
    return count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    locks, keys = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(locks, keys)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
25,system,gemini-2.0-flash,False,121.25475692749023,
1,single-model,gemini-2.5-pro-preview-05-06,True,125.65140175819397,"### Advent of Code Day 1: Historian Hysteria
""""""
Advent of Code Day 1: Historian Hysteria
Solution for calculating total distance between two lists of location IDs.

This script reads pairs of numbers from an input file, representing two lists.
It sorts both lists and then calculates the sum of absolute differences
between corresponding elements in the sorted lists.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Each line of the input file is expected to contain two space-separated integers.
    The first integer goes into the left list, the second into the right list.
    Lines that are empty or malformed (not containing exactly two integers)
    will cause the program to print an error message to stderr and exit.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing two lists: (left_list, right_list).

    Raises:
        SystemExit: If the file is not found, or if any line is malformed
                    or contains non-integer data.
    """"""
    left_list: List[int] = []
    right_list: List[int] = []
    try:
        with open(input_file, 'r') as f:
            for line_num, line_content in enumerate(f, 1):
                line = line_content.strip()
                if not line:  # Skip empty lines if any are present
                    continue

                parts = line.split()
                if len(parts) != 2:
                    print(f""Error: Malformed line {line_num} in '{input_file}': '{line_content.rstrip()}'. Expected two numbers."", file=sys.stderr)
                    sys.exit(1)

                try:
                    left_num = int(parts[0])
                    right_num = int(parts[1])
                    left_list.append(left_num)
                    right_list.append(right_num)
                except ValueError:
                    print(f""Error: Invalid number in line {line_num} in '{input_file}': '{line_content.rstrip()}'. Both parts must be integers."", file=sys.stderr)
                    sys.exit(1)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

    return left_list, right_list

def solve_part_one(data: Tuple[List[int], List[int]]) -> int:
    """"""Calculates the total distance for Part One of the puzzle.

    The method involves sorting both lists independently, then pairing elements
    at corresponding positions (e.g., smallest with smallest, second-smallest
    with second-smallest). For each pair, the absolute difference (distance)
    is calculated. The function returns the sum of all these distances.

    Args:
        data: A tuple containing two lists of integers: (left_list, right_list).
              It's assumed these lists are of equal length, as enforced by
              the parsing logic.

    Returns:
        The total distance as an integer. Returns 0 if the lists are empty.
    """"""
    left_list, right_list = data

    # This check is mostly a safeguard; parse_input should ensure equal lengths.
    if len(left_list) != len(right_list):
        print(f""Error: Internal inconsistency. Lists have different lengths: {len(left_list)} vs {len(right_list)}."", file=sys.stderr)
        sys.exit(1)

    if not left_list:  # If one is empty, both are (due to length check).
        return 0

    sorted_left = sorted(left_list)
    sorted_right = sorted(right_list)

    total_distance = 0
    for l_val, r_val in zip(sorted_left, sorted_right):
        distance = abs(l_val - r_val)
        total_distance += distance

    return total_distance

def run_tests():
    """"""Runs built-in tests against examples and edge cases.

    Test results and diagnostic information are printed to stderr.
    The program will exit if any assertion fails.
    """"""
    print(""Running internal tests..."", file=sys.stderr)

    # Test Case 1: Provided example
    example_input_str = """"""3   4
4   3
2   5
1   3
3   9
3   3""""""

    example_left_list_manual = []
    example_right_list_manual = []
    for line in example_input_str.strip().split('\n'):
        parts = line.split()
        example_left_list_manual.append(int(parts[0]))
        example_right_list_manual.append(int(parts[1]))

    example_data = (example_left_list_manual, example_right_list_manual)
    expected_example_distance = 11
    calculated_example_distance = solve_part_one(example_data)

    print(""\n--- Test Case 1: Provided Example ---"", file=sys.stderr)
    print(f""Input Left List: {example_left_list_manual}"", file=sys.stderr)
    print(f""Input Right List: {example_right_list_manual}"", file=sys.stderr)
    print(f""Sorted Left List: {sorted(example_left_list_manual)}"", file=sys.stderr)
    print(f""Sorted Right List: {sorted(example_right_list_manual)}"", file=sys.stderr)
    print(f""Calculated Distance: {calculated_example_distance}"", file=sys.stderr)
    print(f""Expected Distance: {expected_example_distance}"", file=sys.stderr)
    assert calculated_example_distance == expected_example_distance, \
        f""Test Case 1 Failed: Expected {expected_example_distance}, got {calculated_example_distance}""
    print(""Test Case 1 Passed."", file=sys.stderr)

    # Test Case 2: Empty lists
    empty_data = ([], [])
    expected_empty_distance = 0
    calculated_empty_distance = solve_part_one(empty_data)
    print(""\n--- Test Case 2: Empty Lists ---"", file=sys.stderr)
    print(f""Input Data: {empty_data}"", file=sys.stderr)
    print(f""Calculated Distance: {calculated_empty_distance}"", file=sys.stderr)
    print(f""Expected Distance: {expected_empty_distance}"", file=sys.stderr)
    assert calculated_empty_distance == expected_empty_distance, \
        f""Test Case 2 Failed: Expected {expected_empty_distance}, got {calculated_empty_distance}""
    print(""Test Case 2 Passed."", file=sys.stderr)

    # Test Case 3: Single element lists
    single_element_data = ([5], [10])
    expected_single_distance = 5 # abs(5-10)
    calculated_single_distance = solve_part_one(single_element_data)
    print(""\n--- Test Case 3: Single Element Lists ---"", file=sys.stderr)
    print(f""Input Data: {single_element_data}"", file=sys.stderr)
    print(f""Calculated Distance: {calculated_single_distance}"", file=sys.stderr)
    print(f""Expected Distance: {expected_single_distance}"", file=sys.stderr)
    assert calculated_single_distance == expected_single_distance, \
        f""Test Case 3 Failed: Expected {expected_single_distance}, got {calculated_single_distance}""
    print(""Test Case 3 Passed."", file=sys.stderr)

    # Test Case 4: Lists with negative numbers
    negative_data = ([-1, -5, 0], [-10, 0, 5]) # Sorted: ([-5, -1, 0], [-10, 0, 5])
    # Pairs: (-5, -10) -> diff 5
    #        (-1, 0)   -> diff 1
    #        (0, 5)    -> diff 5
    # Total: 5 + 1 + 5 = 11
    expected_negative_distance = 11
    calculated_negative_distance = solve_part_one(negative_data)
    print(""\n--- Test Case 4: Lists with Negative Numbers ---"", file=sys.stderr)
    print(f""Input Data: {negative_data}"", file=sys.stderr)
    print(f""Sorted Left: {sorted(negative_data[0])}"", file=sys.stderr)
    print(f""Sorted Right: {sorted(negative_data[1])}"", file=sys.stderr)
    print(f""Calculated Distance: {calculated_negative_distance}"", file=sys.stderr)
    print(f""Expected Distance: {expected_negative_distance}"", file=sys.stderr)
    assert calculated_negative_distance == expected_negative_distance, \
        f""Test Case 4 Failed: Expected {expected_negative_distance}, got {calculated_negative_distance}""
    print(""Test Case 4 Passed."", file=sys.stderr)

    print(""\nAll internal tests passed successfully."", file=sys.stderr)


def main():
    """"""Main function to execute the solution.

    Handles command-line argument parsing, runs internal tests,
    parses the input file, solves the puzzle, and prints the solution.
    """"""
    # Run internal tests to verify correctness with examples and edge cases.
    # Output from tests goes to stderr.
    run_tests()

    # Check for input file argument
    if len(sys.argv) < 2:
        print(""\nUsage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    print(f""\nProcessing input file: {input_file}"", file=sys.stderr)

    # Parse input data from the specified file
    parsed_data = parse_input(input_file)

    # Solve Part One of the puzzle
    part_one_solution = solve_part_one(parsed_data)

    # Print the final solution to STDOUT.
    # This must be the only output to STDOUT.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
1,system,gemini-2.5-pro-preview-05-06,True,738.6703543663025,"""""""
Advent of Code Day 1: Historian Hysteria
Solution implementation based on the provided plan.

Calculates the sum of absolute differences between corresponding elements
of two lists of integers after both lists are independently sorted.
The lists are derived from a two-column input file.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Each line in the input file is expected to contain two integers
    separated by whitespace. The first integer goes into the left list,
    and the second into the right list.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing two lists: (left_numbers, right_numbers).

    Raises:
        FileNotFoundError: If the input_file does not exist.
        ValueError: If a line contains non-integer values or an incorrect number of values.
    """"""
    left_numbers: List[int] = []
    right_numbers: List[int] = []
    try:
        with open(input_file, 'r') as f:
            for line_num, line_content in enumerate(f, 1):
                stripped_line = line_content.strip()
                if not stripped_line:  # Skip empty lines
                    continue

                parts = stripped_line.split()
                if len(parts) != 2:
                    raise ValueError(
                        f""Line {line_num} in {input_file} must contain exactly two numbers. Found: '{stripped_line}'""
                    )

                try:
                    left_val = int(parts[0])
                    right_val = int(parts[1])
                except ValueError as e:
                    raise ValueError(
                        f""Line {line_num} in {input_file} contains non-integer values: '{stripped_line}'. Error: {e}""
                    )

                left_numbers.append(left_val)
                right_numbers.append(right_val)
    except FileNotFoundError:
        # Re-raise to be handled in main or calling context
        raise
    except ValueError:
        # Re-raise to be handled in main or calling context
        raise

    return left_numbers, right_numbers

def solve_part_one(left_numbers: List[int], right_numbers: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Sorts both lists independently in non-decreasing order. Then, calculates
    the sum of absolute differences between corresponding elements (i.e., elements
    at the same index after sorting).

    Args:
        left_numbers: A list of integers from the first column.
        right_numbers: A list of integers from the second column.
                       It's assumed to be of the same length as left_numbers,
                       as per problem constraints.

    Returns:
        The total sum of absolute differences.
    """"""
    # Handle empty lists case: if input is empty, sum of differences is 0.
    if not left_numbers and not right_numbers:
        return 0

    # Ensure lists are of equal length as expected by problem logic for zipping.
    # The problem statement guarantees this from input structure.
    if len(left_numbers) != len(right_numbers):
        # This case should ideally not occur if input conforms to problem spec.
        # Handling it defensively for robustness, though AoC inputs are usually strict.
        raise ValueError(""Input lists must be of equal length."")

    # Sort both lists in non-decreasing (ascending) order.
    # sorted() creates new sorted lists, leaving original lists unchanged.
    sorted_left = sorted(left_numbers)
    sorted_right = sorted(right_numbers)

    total_absolute_difference = 0
    # Iterate through the sorted lists using zip.
    # zip pairs elements from sorted_left and sorted_right at corresponding indices.
    # e.g., (sorted_left[0], sorted_right[0]), (sorted_left[1], sorted_right[1]), ...
    for val_left, val_right in zip(sorted_left, sorted_right):
        difference = abs(val_left - val_right)
        total_absolute_difference += difference

    return total_absolute_difference

def run_example_tests():
    """"""Runs tests based on the example provided in the problem description.""""""
    example_input_str = ""3   4\n4   3\n2   5\n1   3\n3   9\n3   3""

    # Simulate parsing for the example string input
    example_left_numbers: List[int] = []
    example_right_numbers: List[int] = []
    for line in example_input_str.strip().split('\n'):
        parts = line.split()
        example_left_numbers.append(int(parts[0]))
        example_right_numbers.append(int(parts[1]))

    expected_example_solution = 11
    example_solution = solve_part_one(example_left_numbers, example_right_numbers)

    # Debug output to stderr
    print(""--- Example Test ---"", file=sys.stderr)
    print(f""Example Left Input: {example_left_numbers}"", file=sys.stderr)
    print(f""Example Right Input: {example_right_numbers}"", file=sys.stderr)
    print(f""Sorted Left: {sorted(example_left_numbers)}"", file=sys.stderr)
    print(f""Sorted Right: {sorted(example_right_numbers)}"", file=sys.stderr)
    print(f""Calculated Example Solution: {example_solution}"", file=sys.stderr)
    print(f""Expected Example Solution: {expected_example_solution}"", file=sys.stderr)

    assert example_solution == expected_example_solution, \
        f""Example test FAILED! Got {example_solution}, expected {expected_example_solution}""
    print(""Example test PASSED!"", file=sys.stderr)
    print(""--------------------"", file=sys.stderr)

def main():
    """"""Main entry point for the script.
    Parses command-line arguments, runs example tests, processes the input file,
    and prints the solution.
    """"""
    # Run example tests first for quick verification
    run_example_tests()

    # Check command line arguments for input file
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Parse input from the specified file
    try:
        left_numbers, right_numbers = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input file '{input_file}': {e}"", file=sys.stderr)
        sys.exit(1)

    # Solve the puzzle for the parsed data
    solution = solve_part_one(left_numbers, right_numbers)

    # Print the final solution to STDOUT (as required by Advent of Code)
    print(solution)

if __name__ == ""__main__"":
    main()
"
2,single-model,gemini-2.5-pro-preview-05-06,True,140.54361820220947,"import sys
from typing import List

""""""
Advent of Code Day 2: Red-Nosed Reports
Solution implementation for analyzing reactor safety reports.

A report is a list of numbers (levels). A report is safe if:
1. The levels are all increasing or all decreasing.
2. Any two adjacent levels differ by at least one and at most three.

Usage: python3 solution.py [input_file|test]
If 'test' is provided as input_file, runs built-in test cases.
""""""

def parse_line_to_report(line: str) -> List[int]:
    """"""Parses a single line of space-separated numbers into a list of integers.

    Args:
        line: A string representing a report.

    Returns:
        A list of integers representing the levels in the report.
        Returns an empty list if the line is empty or contains only whitespace.
    """"""
    stripped_line = line.strip()
    if not stripped_line:
        return []
    return [int(x) for x in stripped_line.split()]

def is_report_safe(report: List[int]) -> bool:
    """"""Checks if a single report is safe according to the rules.

    Args:
        report: A list of integers representing the levels.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    num_levels = len(report)

    if num_levels == 0:
        return False  # An empty report is not considered safe.
    if num_levels == 1:
        return True   # A report with a single level is trivially safe.

    # Determine initial trend and check the first pair of levels
    # report[0] and report[1] exist because num_levels >= 2
    diff0 = report[1] - report[0]

    # Condition 2: Difference must be between 1 and 3 (inclusive absolute)
    # This means 1 <= abs(diff) <= 3.
    # abs(diff) < 1 (i.e. diff == 0) is unsafe.
    # abs(diff) > 3 is unsafe.
    if not (1 <= abs(diff0) <= 3):
        return False

    # Condition 1: Determine if trend is increasing or decreasing
    # This trend must hold for the entire report.
    expected_increasing_trend = diff0 > 0

    # Check subsequent pairs of levels
    # Loop runs from i=1 up to num_levels-2.
    # This covers pairs (report[1], report[2]) up to (report[num_levels-2], report[num_levels-1]).
    for i in range(1, num_levels - 1):
        current_level = report[i]
        next_level = report[i+1]
        diff_current = next_level - current_level

        # Condition 2 for current pair
        if not (1 <= abs(diff_current) <= 3):
            return False

        # Condition 1: Check if trend is consistent
        current_is_increasing = diff_current > 0
        if current_is_increasing != expected_increasing_trend:
            return False # Trend changed (e.g., increasing then decreasing)

    return True

def solve_part_one(reports: List[List[int]]) -> int:
    """"""Counts the number of safe reports.

    Args:
        reports: A list of reports, where each report is a list of integers.

    Returns:
        The total count of safe reports.
    """"""
    safe_report_count = 0
    for report_data in reports:
        if is_report_safe(report_data):
            safe_report_count += 1
    return safe_report_count

def parse_input(input_file_path: str) -> List[List[int]]:
    """"""Parses the puzzle input from a file.

    Args:
        input_file_path: Path to the input file.

    Returns:
        A list of reports (each report is a list of integers).
    """"""
    parsed_reports: List[List[int]] = []
    try:
        with open(input_file_path, 'r') as f:
            for line_content in f:
                parsed_reports.append(parse_line_to_report(line_content))
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file_path}"", file=sys.stderr)
        sys.exit(1)
    except ValueError:
        # This would catch error from int(x) if non-numeric data is present
        print(f""Error: Input file contains non-integer values or malformed lines."", file=sys.stderr)
        sys.exit(1)
    return parsed_reports

def run_tests():
    """"""Runs built-in test cases and prints progress to stderr.""""""
    print(""Running tests for is_report_safe..."", file=sys.stderr)
    test_cases_is_safe = [
        (""7 6 4 2 1"", True), (""1 2 7 8 9"", False), (""9 7 6 2 1"", False),
        (""1 3 2 4 5"", False), (""8 6 4 4 1"", False), (""1 3 6 7 9"", True),
        (""1"", True), (""1 2"", True), (""1 4"", True), (""1 5"", False),
        (""4 1"", True), (""5 1"", False), (""1 1"", False), ("""", False),
        (""1 2 1"", False), (""3 2 3"", False),
        (""5 4 3 2 1"", True), (""1 2 3 4 5"", True),
        (""1 2 3 2 1"", False), (""5 4 3 4 5"", False),
        (""1 4 1"", False), (""10 7 4 1"", True),
        (""10 13 16 19"", True), (""10 13 17"", False), (""10 13 13"", False),
        (""2 4"", True) # Test case for a report with exactly 2 levels
    ]
    for i, (report_str, expected) in enumerate(test_cases_is_safe):
        report_data = parse_line_to_report(report_str)
        actual = is_report_safe(report_data)
        assert actual == expected, \
            f""Test is_report_safe case {i+1} ('{report_str}'): Expected {expected}, got {actual}. Report: {report_data}""
    print(""is_report_safe tests passed."", file=sys.stderr)

    print(""\nRunning test for solve_part_one with example data..."", file=sys.stderr)
    example_input_str = """"""7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9""""""
    example_reports_data = []
    for line_content in example_input_str.splitlines():
        example_reports_data.append(parse_line_to_report(line_content))

    expected_safe_count = 2
    actual_safe_count = solve_part_one(example_reports_data)
    assert actual_safe_count == expected_safe_count, \
        f""Test solve_part_one: Expected {expected_safe_count}, got {actual_safe_count}""
    print(f""Test solve_part_one passed. Found {actual_safe_count} safe reports."", file=sys.stderr)

    print(""\nAll tests passed successfully."", file=sys.stderr)

def main():
    """"""Main entry point for the script.
    Handles command-line arguments, parsing input, solving the puzzle, and printing the solution.
    """"""
    if len(sys.argv) < 2:
        # sys.argv[0] is the script name
        print(f""Usage: python3 {sys.argv[0]} [input_file|test]"", file=sys.stderr)
        sys.exit(1)

    input_arg = sys.argv[1]

    if input_arg == ""test"":
        run_tests()
        return

    # Parse input from file
    parsed_data = parse_input(input_arg)

    # Solve Part One
    solution = solve_part_one(parsed_data)

    # Print the solution to stdout
    print(solution)

if __name__ == ""__main__"":
    main()
"
2,system,gemini-2.5-pro-preview-05-06,True,817.4026658535004,"""""""
Advent of Code Problem: Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

This script analyzes reactor reports, where each report is a list of numbers (levels).
It counts how many reports are ""safe"" according to two rules:
1. The levels must be strictly increasing or strictly decreasing throughout the report.
2. The absolute difference between any two adjacent levels must be between 1 and 3 (inclusive).

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Optional

# Helper function to parse a single line into a list of integers
def _parse_single_report(line: str) -> Optional[List[int]]:
    """"""
    Parses a single line string representing a report into a list of integer levels.

    Args:
        line: The string line from the input file.

    Returns:
        A list of integers if parsing is successful.
        An empty list if the input line is empty or contains only whitespace.
        None if the line contains non-numeric parts or is otherwise malformed,
        in which case a warning is printed to stderr.
    """"""
    stripped_line = line.strip()
    if not stripped_line:
        # Handles empty lines or lines with only whitespace.
        # These will be treated as reports with 0 levels, which are_safe_report will handle.
        return []

    parts = stripped_line.split()
    levels: List[int] = []
    try:
        for part in parts:
            levels.append(int(part))
    except ValueError:
        # Problem statement implies valid numeric input, but robust handling is good.
        print(f""Warning: Non-numeric data found in report line: '{line.strip()}'. This report will be skipped."", file=sys.stderr)
        return None # Indicate parsing failure for this report
    return levels

def parse_input(input_file: str) -> List[List[int]]:
    """"""
    Parse the puzzle input from a file.
    Each line of the file is a report, consisting of space-separated integers.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of reports, where each report is a list of integer levels.
        Malformed reports are skipped (a warning is printed to stderr).
    """"""
    parsed_reports: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            report_levels = _parse_single_report(line)
            if report_levels is not None: # Successfully parsed (could be empty list)
                parsed_reports.append(report_levels)
            # If report_levels is None, it means _parse_single_report handled it (e.g., printed warning)
    return parsed_reports

def is_safe_report(levels: List[int]) -> bool:
    """"""
    Checks if a single report (list of levels) is ""safe"".

    A report is safe if:
    1. It has at least two levels.
    2. The levels are either all strictly increasing or all strictly decreasing.
       (Adjacent levels cannot be equal).
    3. The absolute difference between any two adjacent levels is between 1 and 3, inclusive.

    Args:
        levels: A list of integers representing the levels in the report.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    if len(levels) < 2:
        # Reports with 0 or 1 level cannot satisfy adjacency rules.
        return False

    # determined_trend: None for undetermined, 1 for increasing, -1 for decreasing.
    determined_trend: Optional[int] = None

    for i in range(len(levels) - 1):
        current_level = levels[i]
        next_level = levels[i+1]

        diff = next_level - current_level

        # Rule 1 (partially - strictness) & Rule 2: Difference Magnitude
        # abs(diff) must be between 1 and 3.
        # This means diff cannot be 0 (ensuring strict increase/decrease).
        # abs(diff) > 3 is also unsafe.
        if diff == 0 or abs(diff) > 3:
            return False

        # Determine trend of the current pair (1 for increasing, -1 for decreasing)
        current_pair_trend = 1 if diff > 0 else -1

        # Rule 1: Trend Consistency
        if determined_trend is None:
            # First valid pair determines the trend for the report
            determined_trend = current_pair_trend
        elif determined_trend != current_pair_trend:
            # Trend changed mid-report
            return False

    # If the loop completes, all pairs met criteria and trend was consistent.
    return True

def solve_part_one(parsed_data: List[List[int]]) -> int:
    """"""
    Solves part one of the puzzle by counting the number of safe reports.

    Args:
        parsed_data: A list of reports, where each report is a list of integer levels.

    Returns:
        The total count of safe reports.
    """"""
    safe_report_count = 0
    for report_levels in parsed_data:
        if is_safe_report(report_levels):
            safe_report_count += 1
    return safe_report_count

def run_tests():
    """"""
    Runs automated tests based on examples from the problem description
    and specific test cases.
    """"""
    print(""Running example tests..."", file=sys.stderr)

    # Test cases for is_safe_report function
    # Format: (list_of_levels, expected_is_safe_result)
    individual_report_tests = [
        ([7, 6, 4, 2, 1], True),    # Example: Safe, decreasing
        ([1, 2, 7, 8, 9], False),   # Example: Unsafe (diff 5)
        ([9, 7, 6, 2, 1], False),   # Example: Unsafe (diff -4)
        ([1, 3, 2, 4, 5], False),   # Example: Unsafe (trend change)
        ([8, 6, 4, 4, 1], False),   # Example: Unsafe (diff 0)
        ([1, 3, 6, 7, 9], True),    # Example: Safe, increasing
        # Additional test cases for edge conditions
        ([], False),                 # Empty report
        ([1], False),                # Single level report
        ([1, 2], True),              # Minimal valid increasing
        ([2, 1], True),              # Minimal valid decreasing
        ([1, 1], False),             # Equal levels
        ([1, 5], False),             # Difference too large (>3)
        ([1, 2, 3, 2], False),       # Trend change
        ([5, 4, 3, 4], False),       # Trend change
    ]

    for i, (levels, expected_safe) in enumerate(individual_report_tests):
        actual_safe = is_safe_report(levels)
        assert actual_safe == expected_safe, \
            f""Test {i} (is_safe_report for {levels}): FAILED. Expected safe={expected_safe}, got safe={actual_safe}""

    # Test with the full example input from the problem description (""test_cases"" field in JSON)
    example_input_str = ""7 6 4 2 1\n1 2 7 8 9\n9 7 6 2 1\n1 3 2 4 5\n8 6 4 4 1\n1 3 6 7 9""
    expected_total_safe_reports = 2

    parsed_example_reports: List[List[int]] = []
    for line in example_input_str.splitlines():
        report = _parse_single_report(line)
        if report is not None:
             parsed_example_reports.append(report)

    actual_total_safe_reports = solve_part_one(parsed_example_reports)
    assert actual_total_safe_reports == expected_total_safe_reports, \
        f""Full example test (solve_part_one): FAILED. Expected {expected_total_safe_reports} safe reports, got {actual_total_safe_reports}""

    print(""All example tests passed."", file=sys.stderr)

def main():
    """"""
    Main execution flow: parses input, solves the puzzle, and prints the result.
    Includes running example tests.
    """"""
    # Run example tests to verify logic before processing actual input
    run_tests()

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        print(""Error: Input file path not provided."", file=sys.stderr)
        sys.exit(1) # Exit with an error code

    input_file = sys.argv[1]

    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e: # Catch other potential errors during parsing
        print(f""An error occurred during input parsing: {e}"", file=sys.stderr)
        sys.exit(1)

    part_one_solution = solve_part_one(parsed_data)

    # The problem asks for the final result to be printed to STDOUT.
    # All other informational messages (debug, errors, test status) go to STDERR.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
3,single-model,gemini-2.5-pro-preview-05-06,True,102.97484564781189,"""""""
Advent of Code YYYY Day 3: Mull It Over
Solution implementation for Day 3 of an Advent of Code-like puzzle.
This program scans corrupted memory for valid 'mul(X,Y)' instructions,
calculates the product X*Y for each, and sums these products.

Usage: python3 solution.py [input_file]
""""""
import sys
import re
from typing import List, Tuple

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a single string.

    Args:
        input_file: Path to the input file.

    Returns:
        The content of the file as a single string.
    """"""
    try:
        with open(input_file, 'r') as f:
            # Read the entire file content. Strip any leading/trailing whitespace,
            # especially newlines, which might affect parsing if not handled,
            # though for this specific regex, it's robust.
            return f.read().strip()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)
    # The lines above call sys.exit(1) which raises SystemExit.
    # Thus, this part of the function should be unreachable.
    # Adding a failsafe return for linters/type checkers that might not infer this.
    return """"

def solve_part_one(memory_string: str) -> int:
    """"""Solve part one of the puzzle.
    Finds all valid mul(X,Y) instructions in the memory_string,
    calculates X*Y for each, and sums these results.

    Args:
        memory_string: The corrupted memory string.

    Returns:
        The sum of all multiplication results. Returns 0 if no valid
        instructions are found or if the input string is empty.
    """"""
    # Regex to find ""mul(X,Y)"" where X and Y are 1-3 digit numbers.
    # - ""mul\("": Matches the literal ""mul("". The parenthesis ( is escaped as it's a regex metacharacter.
    # - ""(\d{1,3})"": This is the first capturing group. It matches:
    #   - ""\d"": Any digit (0-9).
    #   - ""{1,3}"": Between 1 and 3 occurrences of the preceding token (a digit).
    #   This captures the first number X.
    # - "","": Matches the literal comma separating the numbers.
    # - ""(\d{1,3})"": This is the second capturing group, structured identically to the first.
    #   It captures the second number Y.
    # - ""\)"": Matches the literal "")"". The parenthesis ) is escaped.
    # Example: For ""mul(44,46)"", group 1 is ""44"", group 2 is ""46"".
    pattern = r""mul\((\d{1,3}),(\d{1,3})\)""

    matches: List[Tuple[str, str]] = re.findall(pattern, memory_string)
    # re.findall returns a list of tuples. Each tuple contains strings
    # corresponding to the captured groups. E.g., [('2', '4'), ('5', '5')]

    total_sum = 0
    for num1_str, num2_str in matches:
        # The regex \d{1,3} ensures these are strings of digits.
        # int() conversion should be safe.
        num1 = int(num1_str)
        num2 = int(num2_str)
        product = num1 * num2
        total_sum += product

    return total_sum

def main():
    """"""Main entry point for the script.""""""
    # Check for correct number of command-line arguments
    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Test with the provided example before processing the actual input file.
    # This helps catch logical errors early.
    EXAMPLE_INPUT = ""xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))""
    EXPECTED_EXAMPLE_OUTPUT = 161

    example_result = solve_part_one(EXAMPLE_INPUT)
    if example_result == EXPECTED_EXAMPLE_OUTPUT:
        print(f""INFO: Example test PASSED. Result: {example_result}, Expected: {EXPECTED_EXAMPLE_OUTPUT}."", file=sys.stderr)
    else:
        print(f""ERROR: Example test FAILED. Result: {example_result}, Expected: {EXPECTED_EXAMPLE_OUTPUT}. Input: '{EXAMPLE_INPUT}'"", file=sys.stderr)
        # Depending on strictness, one might choose to exit here if the example fails.
        # For AoC, it's common to proceed and try the puzzle input anyway.

    # Parse actual input from the file specified by command-line argument
    parsed_data = parse_input(input_file)

    # It's good practice to inform if the input is empty, though for this problem,
    # an empty input string correctly results in a sum of 0.
    if not parsed_data and input_file:
        # Only print warning if input_file was not empty string (e.g. for testing)
        print(f""INFO: Input file '{input_file}' is empty or contains only whitespace. Proceeding with empty data."", file=sys.stderr)

    # Solve Part One with the parsed data
    part_one_solution = solve_part_one(parsed_data)

    # Print the final solution for Part One to STDOUT.
    # This is the only output that should go to STDOUT.
    print(part_one_solution)

if __name__ == ""__main__"":
    # This construct ensures main() is called only when the script is executed directly,
    # not when imported as a module.
    main()
"
3,system,gemini-2.5-pro-preview-05-06,True,870.4606282711029,"import sys
import re
from typing import List, Tuple

""""""
Advent of Code Day 3: Mull It Over
Solution implementation based on the provided plan.

The program scans a string of ""corrupted memory"" for valid `mul(X,Y)`
instructions, where X and Y are 1-3 digit numbers. It calculates
X * Y for each valid instruction and sums these products.
The core logic uses a regular expression to find all valid instructions.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file.

    The input is expected to be a single string representing corrupted memory.
    This function reads the entire file content and strips leading/trailing whitespace.

    Args:
        input_file: Path to the input file.

    Returns:
        The content of the file as a single string.
    """"""
    with open(input_file, 'r') as f:
        content = f.read()
    return content.strip()

def solve_part_one(data: str) -> int:
    """"""Solve the puzzle: find mul(X,Y) instructions, calculate products, and sum them.

    Args:
        data: The corrupted memory string.

    Returns:
        The sum of all X*Y products from valid mul(X,Y) instructions.
    """"""
    # Regex pattern:
    # mul\(    -- matches the literal ""mul(""
    # (\d{1,3}) -- captures group 1: one to three digits (for X)
    # ,        -- matches the literal "",""
    # (\d{1,3}) -- captures group 2: one to three digits (for Y)
    # \)        -- matches the literal "")""
    # This pattern strictly adheres to ""mul(X,Y)"" where X and Y are 1-3 digits each.
    # It correctly finds occurrences like ""...prefix_garbage_mul(1,2)_suffix_garbage...""
    pattern = r""mul\((\d{1,3}),(\d{1,3})\)""

    # re.findall finds all non-overlapping matches of the pattern in the string.
    # It returns a list of tuples, where each tuple contains the captured groups.
    # For example, in ""abc_mul(1,2)_mul(34,567)"", it returns [('1','2'), ('34','567')].
    matches: List[Tuple[str, str]] = re.findall(pattern, data)

    total_sum = 0
    for x_str, y_str in matches:
        # The regex \d{1,3} ensures x_str and y_str are valid digit sequences.
        # So, int() conversion here is safe and should not raise ValueError.
        x_int = int(x_str)
        y_int = int(y_str)
        product = x_int * y_int
        total_sum += product

    return total_sum

def main():
    """"""Main execution function: handles arguments, runs tests, parses input, solves, and prints solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1) # Exit with an error code

    input_file = sys.argv[1]

    # --- Self-Tests ---
    # These tests print diagnostic information to stderr and use assertions to verify logic.
    # The final puzzle solution is printed to stdout.

    print(""--- Running Self-Tests ---"", file=sys.stderr)

    # Test case from problem description / `test_cases` JSON field
    # Input: ""xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))""
    # Expected sum: 2*4 + 5*5 + 11*8 + 8*5 = 8 + 25 + 88 + 40 = 161
    example_input_str = ""xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))""
    expected_example_output = 161

    calculated_example_output = solve_part_one(example_input_str)
    print(f""Test: Main Example"", file=sys.stderr)
    print(f""  Input: \""{example_input_str}\"""", file=sys.stderr)
    print(f""  Calculated: {calculated_example_output}"", file=sys.stderr)
    print(f""  Expected: {expected_example_output}"", file=sys.stderr)
    assert calculated_example_output == expected_example_output, \
           f""  Main example FAILED: expected {expected_example_output}, got {calculated_example_output}""
    print(f""  Main example PASSED"", file=sys.stderr)

    # Test specific cases derived from the main example string or problem rules
    test_cases_specific = {
        ""do_not_mul(5,5)"": 25, # Should find mul(5,5) within this string
        ""xmul(2,4)"": 8,        # Should find mul(2,4) within this string
        ""mul(44,46)"": 2024    # Simple valid instruction from problem description
    }
    for s_input, s_expected in test_cases_specific.items():
        s_calculated = solve_part_one(s_input)
        print(f""Test: Specific case '{s_input}'"", file=sys.stderr)
        print(f""  Calculated: {s_calculated}, Expected: {s_expected}"", file=sys.stderr)
        assert s_calculated == s_expected, f""  Specific test '{s_input}' FAILED: expected {s_expected}, got {s_calculated}""
        print(f""  Specific test PASSED"", file=sys.stderr)

    # Test invalid sequences (all should result in a sum of 0)
    invalid_sequences = [
        ""mul(4*"", ""mul(6,9!"", ""?(12,34)"", ""mul ( 2 , 4 )"", # From problem description
        ""mul[3,7]"", ""mul(32,64]"",                           # Malformed, from example string context
        ""mul(1234,5)"", ""mul(5,1234)"",                       # Too many digits
        ""mul(a,5)"", ""mul(5,b)"",                            # Non-digits
        ""mul(,5)"", ""mul(5,)"", ""mul(,)"", ""mul()"",           # Missing numbers
        ""mul(1,2,3)""                                      # Extra comma and number
    ]
    print(f""Test: Invalid sequences (all should yield 0)"", file=sys.stderr)
    all_invalid_passed = True
    for i, seq in enumerate(invalid_sequences):
        result = solve_part_one(seq)
        if result != 0:
            print(f""  Invalid sequence '{seq}' FAILED: produced {result}, expected 0"", file=sys.stderr)
            all_invalid_passed = False
    if all_invalid_passed:
        print(f""  All invalid sequence tests PASSED"", file=sys.stderr)
    else:
        # Assertion will fail on the first one if enabled, but this reports all failures.
        assert False, ""One or more invalid sequence tests failed.""

    # Test a string with a mix of valid and invalid instructions
    complex_test_input = ""mul(1,1) xxx mul (2,2) yyy mul(10,10) zzz mul(1,2,3) www mul(01,05)""
    # Expected: 1*1 (from mul(1,1)) + 10*10 (from mul(10,10)) + 1*5 (from mul(01,05)) = 1 + 100 + 5 = 106
    complex_test_expected = 106
    complex_test_calculated = solve_part_one(complex_test_input)
    print(f""Test: Complex mix '{complex_test_input}'"", file=sys.stderr)
    print(f""  Calculated: {complex_test_calculated}, Expected: {complex_test_expected}"", file=sys.stderr)
    assert complex_test_calculated == complex_test_expected, \
        f""  Complex mix test FAILED: expected {complex_test_expected}, got {complex_test_calculated}""
    print(f""  Complex mix test PASSED"", file=sys.stderr)

    # Test empty string
    empty_str_expected = 0
    empty_str_calculated = solve_part_one("""")
    print(f""Test: Empty string ''"", file=sys.stderr)
    print(f""  Calculated: {empty_str_calculated}, Expected: {empty_str_expected}"", file=sys.stderr)
    assert empty_str_calculated == empty_str_expected, \
        f""  Empty string test FAILED: expected {empty_str_expected}, got {empty_str_calculated}""
    print(f""  Empty string test PASSED"", file=sys.stderr)

    # Test string with no mul instructions
    no_mul_input = ""abcdefg 12345 !@#$%^""
    no_mul_expected = 0
    no_mul_calculated = solve_part_one(no_mul_input)
    print(f""Test: No mul instructions '{no_mul_input}'"", file=sys.stderr)
    print(f""  Calculated: {no_mul_calculated}, Expected: {no_mul_expected}"", file=sys.stderr)
    assert no_mul_calculated == no_mul_expected, \
        f""  No mul instructions test FAILED: expected {no_mul_expected}, got {no_mul_calculated}""
    print(f""  No mul instructions test PASSED"", file=sys.stderr)

    print(""--- Self-Tests Complete ---"", file=sys.stderr)

    # Parse actual input file
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1) # Exit with an error code
    except Exception as e:
        print(f""Error processing input file: {e}"", file=sys.stderr)
        sys.exit(1)

    # Solve the puzzle for the actual input
    solution = solve_part_one(parsed_data)

    # Print the final solution to stdout (only the numerical result)
    print(solution)

if __name__ == ""__main__"":
    main()
"
4,single-model,gemini-2.5-pro-preview-05-06,False,114.6504499912262,NO CODE
4,system,gemini-2.5-pro-preview-05-06,True,838.4316692352295,"""""""
Advent of Code Day 4: Ceres Search
Solution for counting ""XMAS"" occurrences in a 2D grid.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run internal tests)
""""""
import sys
from typing import List, Tuple

# Constants
TARGET_WORD: str = ""XMAS""
DIRECTIONS: List[Tuple[int, int]] = [
    (0, 1),  # Right
    (0, -1), # Left
    (1, 0),  # Down
    (-1, 0), # Up
    (1, 1),  # Down-Right (Diagonal)
    (1, -1), # Down-Left (Diagonal)
    (-1, 1), # Up-Right (Diagonal)
    (-1, -1) # Up-Left (Diagonal)
]

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of characters.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of lists of characters representing the grid.
        Exits if the file is not found, cannot be read, or is malformed.
        Returns an empty list if the file is genuinely empty (contains no characters).
    """"""""""
    grid: List[List[str]] = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                stripped_line = line.strip()
                if stripped_line:
                    grid.append(list(stripped_line))
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading or parsing file: {e}"", file=sys.stderr)
        sys.exit(1)

    if grid:
        first_row_len = len(grid[0])
        if not all(len(row) == first_row_len for row in grid):
            print(""Error: Grid rows have inconsistent lengths. Input is malformed."", file=sys.stderr)
            sys.exit(1)

    return grid

def check_word_in_direction(
    grid: List[List[str]],
    start_row: int,
    start_col: int,
    dr: int,
    dc: int,
    word_to_check: str,
    num_rows: int,
    num_cols: int,
    word_len: int
) -> bool:
    """"""
    Checks if the `word_to_check` can be formed starting from (`start_row`, `start_col`)
    in the direction (`dr`, `dc`) within the `grid`.

    Args:
        grid: The 2D character grid.
        start_row: The starting row index.
        start_col: The starting column index.
        dr: The row change per step in the direction.
        dc: The column change per step in the direction.
        word_to_check: The word to search for (e.g., ""XMAS"").
        num_rows: The total number of rows in the grid.
        num_cols: The total number of columns in the grid.
        word_len: The length of `word_to_check`.

    Returns:
        True if the word is found, False otherwise.
    """"""
    for k in range(word_len):
        current_r = start_row + k * dr
        current_c = start_col + k * dc

        # Boundary check
        if not (0 <= current_r < num_rows and 0 <= current_c < num_cols):
            return False

        # Character match check
        if grid[current_r][current_c] != word_to_check[k]:
            return False

    return True # All characters matched successfully

def solve_part_one(grid: List[List[str]]) -> int:
    """"""
    Counts all occurrences of TARGET_WORD in the grid.
    The word can appear horizontally, vertically, or diagonally,
    in any of the 8 standard directions. Occurrences can overlap.

    Args:
        grid: The 2D character grid.

    Returns:
        The total number of times TARGET_WORD appears in the grid.
    """"""
    if not grid or not grid[0]: # Handles empty grid or grid with empty rows like [[]]
        return 0

    num_rows = len(grid)
    num_cols = len(grid[0]) # Assumes rectangular grid as per problem statement

    occurrence_count = 0
    word_len = len(TARGET_WORD)

    if word_len == 0: # Edge case, TARGET_WORD=""XMAS"" so len is 4. This won't trigger.
        return 0

    for r in range(num_rows):
        for c in range(num_cols):
            # For each cell (r, c) as a potential start
            for dr, dc in DIRECTIONS:
                # For each of the 8 directions
                if check_word_in_direction(grid, r, c, dr, dc, TARGET_WORD, num_rows, num_cols, word_len):
                    occurrence_count += 1

    return occurrence_count

def _run_tests():
    """"""Runs internal test cases. Output to stderr.""""""
    print(""Running internal test cases..."", file=sys.stderr)

    # Test Case 1: From problem description
    example_input_str = (
        ""MMMSXXMASM\n""
        ""MSAMXMSMSA\n""
        ""AMXSXMAAMM\n""
        ""MSAMASMSMX\n""
        ""XMASAMXAMM\n""
        ""XXAMMXXAMA\n""
        ""SMSMSASXSS\n""
        ""SAXAMASAAA\n""
        ""MAMMMXMMMM\n""
        ""MXMXAXMASX""
    )
    example_grid = [list(line) for line in example_input_str.splitlines()]
    expected_output = 18
    actual_output = solve_part_one(example_grid)
    assert actual_output == expected_output, \
        f""Test Case 1 FAILED: Expected {expected_output}, Got {actual_output}""
    print(""Test Case 1 PASSED."", file=sys.stderr)

    # Test Case 2: Empty grid
    empty_grid: List[List[str]] = []
    expected_output_empty = 0
    actual_output_empty = solve_part_one(empty_grid)
    assert actual_output_empty == expected_output_empty, \
        f""Test Case 2 (Empty Grid) FAILED: Expected {expected_output_empty}, Got {actual_output_empty}""
    print(""Test Case 2 (Empty Grid) PASSED."", file=sys.stderr)

    # Test Case 3: Grid with empty rows e.g. [[]]
    empty_row_grid: List[List[str]] = [[]]
    expected_output_empty_row = 0
    actual_output_empty_row = solve_part_one(empty_row_grid)
    assert actual_output_empty_row == expected_output_empty_row, \
        f""Test Case 3 (Empty Row Grid) FAILED: Expected {expected_output_empty_row}, Got {actual_output_empty_row}""
    print(""Test Case 3 (Empty Row Grid) PASSED."", file=sys.stderr)

    # Test Case 4: Grid smaller than word
    small_grid = [list(""XM""), list(""AS"")] # 2x2 grid, word ""XMAS"" is length 4
    expected_output_small = 0
    actual_output_small = solve_part_one(small_grid)
    assert actual_output_small == expected_output_small, \
        f""Test Case 4 (Small Grid) FAILED: Expected {expected_output_small}, Got {actual_output_small}""
    print(""Test Case 4 (Small Grid) PASSED."", file=sys.stderr)

    # Test Case 5: Word fits exactly horizontally (L-R and R-L)
    exact_grid_lr = [list(""XMAS"")]
    assert solve_part_one(exact_grid_lr) == 1, ""Test Case 5a (Exact Horizontal L-R) FAILED""
    print(""Test Case 5a (Exact Horizontal L-R) PASSED."", file=sys.stderr)
    exact_grid_rl = [list(""SAMX"")]
    assert solve_part_one(exact_grid_rl) == 1, ""Test Case 5b (Exact Horizontal R-L) FAILED""
    print(""Test Case 5b (Exact Horizontal R-L) PASSED."", file=sys.stderr)

    # Test Case 6: Word fits exactly vertically (T-B and B-T)
    exact_grid_tb = [list(c) for c in [""X"", ""M"", ""A"", ""S""]] # [['X'], ['M'], ['A'], ['S']]
    assert solve_part_one(exact_grid_tb) == 1, ""Test Case 6a (Exact Vertical T-B) FAILED""
    print(""Test Case 6a (Exact Vertical T-B) PASSED."", file=sys.stderr)
    exact_grid_bt = [list(c) for c in [""S"", ""A"", ""M"", ""X""]] # [['S'], ['A'], ['M'], ['X']]
    assert solve_part_one(exact_grid_bt) == 1, ""Test Case 6b (Exact Vertical B-T) FAILED""
    print(""Test Case 6b (Exact Vertical B-T) PASSED."", file=sys.stderr)

    # Test Case 7: Word fits exactly diagonally
    diag_grid_tlbr = [list(""X...""), list("".M..""), list(""..A.""), list(""...S"")]
    assert solve_part_one(diag_grid_tlbr) == 1, ""Test Case 7a (Diagonal TL-BR) FAILED""
    print(""Test Case 7a (Diagonal TL-BR) PASSED."", file=sys.stderr)
    diag_grid_bltr = [list(""...S""), list(""..A.""), list("".M..""), list(""X..."")]
    assert solve_part_one(diag_grid_bltr) == 1, ""Test Case 7b (Diagonal BL-TR) FAILED""
    print(""Test Case 7b (Diagonal BL-TR) PASSED."", file=sys.stderr)

    # Test Case 8: All X's (or any char not forming XMAS)
    all_x_grid = [list(""XXXX""), list(""XXXX""), list(""XXXX""), list(""XXXX"")]
    assert solve_part_one(all_x_grid) == 0, ""Test Case 8 (All X's) FAILED""
    print(""Test Case 8 (All X's) PASSED."", file=sys.stderr)

    print(""All internal test cases PASSED."", file=sys.stderr)


def main():
    """"""
    Main entry point for the script. Parses command line arguments,
    reads input, solves the puzzle, and prints the solution.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""       python3 solution.py test (to run internal tests)"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    if input_file.lower() == ""test"":
        _run_tests()
        return

    parsed_data = parse_input(input_file)

    solution = solve_part_one(parsed_data)

    # ONLY PRINT THE RESULT to STDOUT for AoC submission
    print(solution)

if __name__ == ""__main__"":
    main()
"
5,single-model,gemini-2.5-pro-preview-05-06,True,138.59321451187134,"### Advent of Code [Year] Day 5: Print Queue
""""""
Advent of Code [Year] Day 5: Print Queue
Solution implementation based on the problem description.

This script processes a list of page ordering rules and a list of print job updates.
It identifies which updates are correctly ordered according to the rules.
For each correctly-ordered update, it finds the middle page number.
The final result is the sum of these middle page numbers.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Tuple, Dict, Set

# Example input for testing, provided in the problem description
EXAMPLE_INPUT = """"""47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47""""""

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse the puzzle input from file into rules and updates.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - A list of rules, where each rule is (page_X, page_Y) meaning X before Y.
            - A list of updates, where each update is a list of page numbers.
    Raises:
        ValueError: If the input file format is incorrect.
    """"""
    with open(input_file, 'r') as f:
        raw_content = f.read()

    # Input is split into two sections by a blank line
    sections = raw_content.strip().split('\n\n')
    if len(sections) != 2:
        raise ValueError(""Input file must contain two sections (rules and updates) separated by a blank line."")

    rules_str, updates_str = sections

    rules: List[Tuple[int, int]] = []
    if rules_str: # Process rules section if not empty
        for line_num, line in enumerate(rules_str.splitlines(), 1):
            line = line.strip()
            if not line: continue # Skip empty lines if any within section

            parts = line.split('|')
            if len(parts) != 2:
                raise ValueError(f""Malformed rule on line {line_num}: '{line}'. Expected format 'X|Y'."")
            try:
                rules.append((int(parts[0]), int(parts[1])))
            except ValueError:
                raise ValueError(f""Invalid page number in rule on line {line_num}: '{line}'. Page numbers must be integers."")

    updates: List[List[int]] = []
    if updates_str: # Process updates section if not empty
        for line_num, line in enumerate(updates_str.splitlines(), 1):
            line = line.strip()
            if not line: continue # Skip empty lines if any within section

            try:
                page_numbers = [int(p) for p in line.split(',')]
                if not page_numbers and line: # e.g. line consisting only of ',' or non-numeric parts that were filtered by split
                     raise ValueError(f""Update line {line_num} ('{line}') parsed to empty list of pages."")
                if page_numbers: # Only add if there are actual pages
                    updates.append(page_numbers)
            except ValueError:
                raise ValueError(f""Invalid page number in update on line {line_num}: '{line}'. Page numbers must be integers separated by commas."")

    return rules, updates

def is_update_valid(update: List[int], rules: List[Tuple[int, int]]) -> bool:
    """"""Check if a given update respects all applicable ordering rules.

    Args:
        update: A list of page numbers representing the print order.
        rules: A list of ordering rules (page_X, page_Y), meaning X must appear before Y.

    Returns:
        True if the update is valid, False otherwise.
    """"""
    # An empty update has no pages, so no rules can be violated.
    # However, get_middle_page would fail. Assume updates are non-empty based on problem context.
    if not update:
        return True # Or False; problem implies updates are non-empty. Let's say it's trivially valid.

    update_pages_set: Set[int] = set(update)
    # Create a mapping from page number to its index in the update for quick lookups
    page_to_index: Dict[int, int] = {page: i for i, page in enumerate(update)}

    for rule_page_x, rule_page_y in rules:
        # A rule X|Y applies only if both X and Y are present in the current update.
        if rule_page_x in update_pages_set and rule_page_y in update_pages_set:
            # The rule states X must be printed before Y. This means index(X) < index(Y).
            # If index(Y) < index(X), the rule is violated because Y appears before X.
            idx_x = page_to_index[rule_page_x]
            idx_y = page_to_index[rule_page_y]

            if idx_y < idx_x:
                # Violation: Y was printed before X, but rule states X must be before Y.
                # For debugging: print(f""Update {update} invalid: Rule ({rule_page_x}|{rule_page_y}) violated. Page {rule_page_y} (idx {idx_y}) before {rule_page_x} (idx {idx_x})."", file=sys.stderr)
                return False

    return True

def get_middle_page(update: List[int]) -> int:
    """"""Get the middle page number of an update.
    Assumes 0-indexed list. For an even number of pages, it uses the element at index len // 2.
    E.g., for [1,2,3,4], len=4, len//2=2, returns page at index 2 (which is 3).
    Problem examples [75,47,61,53,29] (len 5) -> 61 (idx 2); [75,29,13] (len 3) -> 29 (idx 1).
    This matches `len // 2` behavior.

    Args:
        update: A non-empty list of page numbers.

    Returns:
        The middle page number.
    Raises:
        ValueError: If the update list is empty.
    """"""
    if not update:
        raise ValueError(""Cannot get middle page of an empty update."")

    middle_index = len(update) // 2
    return update[middle_index]

def solve_part_one(parsed_data: Tuple[List[Tuple[int, int]], List[List[int]]]) -> int:
    """"""Solve part one of the puzzle.
    Calculates the sum of middle page numbers from all correctly-ordered updates.

    Args:
        parsed_data: A tuple containing the list of rules and list of updates.

    Returns:
        The sum of middle page numbers of valid updates.
    """"""
    rules, updates_list = parsed_data
    total_middle_page_sum = 0

    for i, update in enumerate(updates_list):
        if not update:
            # This should ideally be caught by parser or not occur based on problem spec.
            print(f""Warning: Encountered an empty update at index {i}. Skipping."", file=sys.stderr)
            continue

        if is_update_valid(update, rules):
            try:
                middle_page = get_middle_page(update)
                total_middle_page_sum += middle_page
                # For debugging: print(f""Update {update} is valid. Middle page: {middle_page}. Current sum: {total_middle_page_sum}"", file=sys.stderr)
            except ValueError as e:
                # This would happen if get_middle_page failed (e.g. on an empty list it was not supposed to get)
                print(f""Error processing valid update {update}: {e}"", file=sys.stderr)
        # else:
            # For debugging: print(f""Update {update} is invalid."", file=sys.stderr)

    return total_middle_page_sum

def run_tests():
    """"""Runs tests using the embedded example input.""""""
    print(""Running example tests..."", file=sys.stderr)

    # Simulate parsing EXAMPLE_INPUT string
    # This re-uses the main parsing logic by writing to a temporary file-like object
    # or by splitting the parse_input function. For simplicity, direct parsing here:
    sections = EXAMPLE_INPUT.strip().split('\n\n')
    rules_str, updates_str = sections

    example_rules: List[Tuple[int, int]] = []
    for line in rules_str.splitlines():
        parts = line.split('|')
        example_rules.append((int(parts[0]), int(parts[1])))

    example_updates: List[List[int]] = []
    for line in updates_str.splitlines():
        example_updates.append([int(p) for p in line.split(',')])

    parsed_data_example = (example_rules, example_updates)

    # Test specific updates from example
    # Update 1: 75,47,61,53,29 (Valid)
    assert is_update_valid(example_updates[0], example_rules) is True, \
        f""Test Case 1 ({example_updates[0]}) failed: Should be valid""
    # Update 4: 75,97,47,61,53 (Invalid due to 97|75)
    assert is_update_valid(example_updates[3], example_rules) is False, \
        f""Test Case 4 ({example_updates[3]}) failed: Should be invalid (violates 97|75)""
    # Update 5: 61,13,29 (Invalid due to 29|13)
    assert is_update_valid(example_updates[4], example_rules) is False, \
        f""Test Case 5 ({example_updates[4]}) failed: Should be invalid (violates 29|13)""

    # Test get_middle_page
    assert get_middle_page(example_updates[0]) == 61, ""Test: Middle page of update 1 (75,47,61,53,29 -> 61)""
    assert get_middle_page(example_updates[1]) == 53, ""Test: Middle page of update 2 (97,61,53,29,13 -> 53)""
    assert get_middle_page(example_updates[2]) == 29, ""Test: Middle page of update 3 (75,29,13 -> 29)""

    # Test overall solution for example
    solution_example = solve_part_one(parsed_data_example)
    expected_example_solution = 143
    assert solution_example == expected_example_solution, \
        f""Example solution failed: Expected {expected_example_solution}, got {solution_example}""

    print(""All example tests passed."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    # Run tests defined with the example input to verify logic.
    run_tests()
    print(""-"" * 20, file=sys.stderr) # Visual separator in stderr

    # Check command line arguments for the input file path
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        # As per requirements, exit if no input file is specified.
        # Tests have already run. Puzzle solution requires an input file.
        return

    input_file = sys.argv[1]

    # Parse input from the specified file
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        return
    except ValueError as e:
        print(f""Error parsing input file '{input_file}': {e}"", file=sys.stderr)
        return

    # Solve part one of the puzzle using the parsed data
    part_one_solution = solve_part_one(parsed_data)

    # Print the solution for part one to STDOUT as per requirements.
    # No other text should be printed to STDOUT.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
5,system,gemini-2.5-pro-preview-05-06,True,816.3694467544556,"import sys
from typing import List, Tuple, Dict, Set

# It's good practice to define a helper for printing to stderr for debugging
def eprint(*args, **kwargs):
    """"""Prints to stderr.""""""
    print(*args, file=sys.stderr, **kwargs)

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse the puzzle input from file into rules and updates.

    The input is divided into two sections: page ordering rules (X|Y)
    and page updates (comma-separated page numbers). These sections are
    typically separated by a blank line.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
        - parsed_rules: A list of (X, Y) tuples representing ordering rules.
        - parsed_updates: A list of lists, where each inner list is an update sequence.
    """"""
    parsed_rules: List[Tuple[int, int]] = []
    parsed_updates: List[List[int]] = []

    parsing_rules_section = True # True if currently parsing rules, False for updates

    with open(input_file, 'r') as f:
        for line_num, line_content in enumerate(f, 1):
            line = line_content.strip()

            if not line: # Blank line
                # If this blank line is the separator between rules and updates
                if parsing_rules_section:
                    parsing_rules_section = False
                # Continue to next line, whether it's a separator or just an extra blank line
                continue

            if parsing_rules_section:
                parts = line.split('|')
                if len(parts) == 2:
                    try:
                        # Ensure parts are stripped of whitespace before int conversion
                        page_x = int(parts[0].strip())
                        page_y = int(parts[1].strip())
                        parsed_rules.append((page_x, page_y))
                    except ValueError:
                        eprint(f""Warning (line {line_num}): Error parsing rule '{line}'. Invalid integer. Skipping."")
                else:
                    eprint(f""Warning (line {line_num}): Malformed rule line '{line}'. Expected 'X|Y' format. Skipping."")
            else: # Parsing updates section
                # A rule-like line appearing after updates/blank line separator is unexpected
                if '|' in line:
                     eprint(f""Warning (line {line_num}): Rule-like line '{line}' found in updates section. Skipping."")
                     continue

                # Split by comma and convert parts to integers
                # Filter out empty strings that might result from ""1,,2"" by checking p.strip()
                str_pages = [p.strip() for p in line.split(',') if p.strip()]
                try:
                    update_sequence = [int(p) for p in str_pages]
                    if update_sequence: # Only add if non-empty after parsing
                        parsed_updates.append(update_sequence)
                    elif line: # Original line was not empty but parsing resulted in empty sequence (e.g. line was just ',,,')
                        eprint(f""Warning (line {line_num}): Parsed update sequence from '{line}' is empty. Skipping."")
                except ValueError:
                    eprint(f""Warning (line {line_num}): Error parsing update sequence '{line}'. Contains invalid integer. Skipping."")

    return parsed_rules, parsed_updates

def is_correctly_ordered(update_sequence: List[int], rules: List[Tuple[int, int]]) -> bool:
    """"""Validates if a given update_sequence adheres to all applicable rules.

    An update sequence is correctly ordered if for every rule X|Y where both X and Y
    are in the sequence, X appears before Y.

    Args:
        update_sequence: A list of integers representing page numbers in print order.
        rules: The list of (X, Y) rule tuples (X must be before Y).

    Returns:
        True if update_sequence is correctly ordered; False otherwise.
    """"""
    # An empty update sequence trivially satisfies all rules (no rules apply).
    if not update_sequence:
        return True

    # For efficient lookup:
    # A set of pages present in the update.
    pages_in_update_set: Set[int] = set(update_sequence)
    # A map from page number to its 0-based index in the sequence.
    page_to_index_map: Dict[int, int] = {page: i for i, page in enumerate(update_sequence)}

    for page_x, page_y in rules:
        # A rule X|Y applies only if both page X and page Y are present in the update.
        if page_x in pages_in_update_set and page_y in pages_in_update_set:
            index_x = page_to_index_map[page_x]
            index_y = page_to_index_map[page_y]

            # If page_X is not strictly before page_Y, the rule is violated.
            if index_x >= index_y:
                # For debugging specific violations:
                # eprint(f""Rule violation: {page_x}|{page_y}. In update {update_sequence}, {page_x} (idx {index_x}) is not before {page_y} (idx {index_y})."")
                return False

    # If all applicable rules are satisfied
    return True

def solve_part_one(parsed_data: Tuple[List[Tuple[int, int]], List[List[int]]]) -> int:
    """"""
    Calculates the sum of middle page numbers from all correctly-ordered updates
    that have an odd number of pages.

    Args:
        parsed_data: A tuple containing (parsed_rules, parsed_updates).
                     parsed_rules is a list of rule tuples (X, Y).
                     parsed_updates is a list of update sequences (lists of page numbers).

    Returns:
        The sum of relevant middle page numbers.
    """"""
    parsed_rules, parsed_updates = parsed_data
    total_middle_page_sum = 0

    for current_update in parsed_updates:
        if is_correctly_ordered(current_update, parsed_rules):
            # eprint(f""Update {current_update} is correctly ordered."") # Debug
            n = len(current_update)
            # Middle page is relevant only if the update has an odd number of pages.
            # N > 0 check also implicitly handled as empty updates are len 0 (even).
            if n % 2 != 0:
                middle_index = (n - 1) // 2
                middle_page = current_update[middle_index]
                total_middle_page_sum += middle_page
                # eprint(f""  Length {n}, middle page {middle_page} (index {middle_index}). Sum is now {total_middle_page_sum}."") # Debug
            # else: # Debug
                # eprint(f""  Length {n}, not odd or is empty. No middle page added."") # Debug
        # else: # Debug
            # eprint(f""Update {current_update} is NOT correctly ordered."") # Debug

    return total_middle_page_sum

def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        # Print usage to stdout as per common CLI behavior (though stderr is also common)
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1) # Exit with an error code for incorrect usage

    input_file = sys.argv[1]

    # --- Test with example ---
    # Example test case from problem description
    example_input_raw = """"""47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47""""""
    expected_example_output = 143

    # Use a temporary file for the example input to test parse_input fully
    import tempfile
    import os
    tmp_file_path = """" # Initialize to prevent NameError in finally if NamedTemporaryFile fails
    try:
        with tempfile.NamedTemporaryFile(mode=""w"", delete=False, encoding='utf-8') as tmp_file:
            tmp_file.write(example_input_raw)
            tmp_file_path = tmp_file.name

        eprint(""--- Running example test case ---"")
        example_parsed_data = parse_input(tmp_file_path)
        # For detailed debugging of example parsing:
        # eprint(""Example Parsed Rules:"", example_parsed_data[0])
        # eprint(""Example Parsed Updates:"", example_parsed_data[1])
        example_solution = solve_part_one(example_parsed_data)
        eprint(f""Example solution: {example_solution}, Expected: {expected_example_output}"")
        assert example_solution == expected_example_output, \
            f""Test case failed: Expected {expected_example_output}, got {example_solution}""
        eprint(""Example test case passed."")
        eprint(""---------------------------------\n"")
    finally:
        if tmp_file_path and os.path.exists(tmp_file_path):
             os.remove(tmp_file_path) # Clean up temporary file
    # --- End Test with example ---

    # Parse actual input
    eprint(f""Parsing actual input file: {input_file}..."")
    parsed_data = parse_input(input_file)
    # For detailed debugging of actual input parsing:
    # eprint(""Actual Parsed Rules:"", parsed_data[0])
    # eprint(""Actual Parsed Updates:"", parsed_data[1])

    # Solve the problem for the actual input
    eprint(""Solving problem for actual input..."")
    solution = solve_part_one(parsed_data)
    eprint(""Solving complete."")

    # Print the final solution to stdout
    # ONLY PRINT THE RESULT, NO OTHER TEXT to stdout
    print(solution)

if __name__ == ""__main__"":
    # Add docstring to main module for context.
    """"""
    Advent of Code [Year] Day 5: Print Queue
    Solution implementation based on the provided plan.

    This script processes a set of page ordering rules and page update sequences.
    It identifies correctly-ordered updates, and for those with an odd number of pages,
    it finds the middle page. The final result is the sum of these middle page numbers.

    Usage: python3 solution.py [input_file]
    """"""
    main()
"
6,single-model,gemini-2.5-pro-preview-05-06,True,178.96263527870178,"""""""
Advent of Code [Year] Day 6: Guard Gallivant
Solution for Day 6, simulating guard movement on a grid.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run example tests)
""""""
import sys
from typing import List, Dict, Tuple, Set

# --- Constants for Directions ---
UP: Tuple[int, int] = (-1, 0)
RIGHT: Tuple[int, int] = (0, 1)
DOWN: Tuple[int, int] = (1, 0)
LEFT: Tuple[int, int] = (0, -1)

# Ordered list of directions for turning right (clockwise)
DIRECTIONS_ORDERED: List[Tuple[int, int]] = [UP, RIGHT, DOWN, LEFT]
# Mapping from direction tuple to its index in DIRECTIONS_ORDERED
DIR_TO_INDEX: Dict[Tuple[int, int], int] = {
    direction: i for i, direction in enumerate(DIRECTIONS_ORDERED)
}
# Mapping from character on map to initial direction
CHAR_TO_DIR: Dict[str, Tuple[int, int]] = {
    '^': UP,
    '>': RIGHT,
    'v': DOWN,
    '<': LEFT,
}

def parse_text_map(text_lines: List[str]) -> Tuple[Set[Tuple[int, int]], Tuple[int, int, int, int], int, int]:
    """"""
    Parses a map represented by a list of strings.

    Args:
        text_lines: A list of non-empty, stripped strings, where each string is a row of the map.

    Returns:
        A tuple containing:
        - obstacles: A set of (row, col) tuples for '#' locations.
        - start_state: A tuple (row, col, dr, dc) for the guard's initial state.
                       (dr, dc) is the direction vector.
        - num_rows: Number of rows in the grid.
        - num_cols: Number of columns in the grid.

    Raises:
        ValueError: If the map is malformed (e.g., not rectangular, multiple guards, no guard on non-empty map).
    """"""
    if not text_lines:
        return set(), (0, 0, 0, 0), 0, 0 # No map, 0 rows, 0 cols

    num_rows = len(text_lines)
    num_cols = len(text_lines[0]) # All lines assumed to be non-empty and same length by pre-filtering

    obstacles: Set[Tuple[int, int]] = set()
    # Initialize start_state with placeholder values for safety, though they should be overwritten if guard found.
    start_row, start_col = -1, -1
    start_dr, start_dc = 0, 0
    found_guard = False

    for r, line in enumerate(text_lines):
        if len(line) != num_cols:
            raise ValueError(""Grid is not rectangular."")
        for c, char in enumerate(line):
            if char == '#':
                obstacles.add((r, c))
            elif char in CHAR_TO_DIR:
                if found_guard:
                    raise ValueError(""Multiple guards found on the map."")
                start_row, start_col = r, c
                start_dr, start_dc = CHAR_TO_DIR[char]
                found_guard = True
            elif char != '.':
                raise ValueError(f""Invalid character '{char}' on map at ({r},{c})."")

    if num_rows > 0 and num_cols > 0 and not found_guard:
        # A map with positive dimensions must have a guard.
        raise ValueError(""No guard found on a non-empty map."")

    start_state: Tuple[int, int, int, int] = (start_row, start_col, start_dr, start_dc)
    return obstacles, start_state, num_rows, num_cols


def parse_input(input_file: str) -> Tuple[Set[Tuple[int, int]], Tuple[int, int, int, int], int, int]:
    """"""
    Parse the puzzle input from a file into appropriate data structures.

    Args:
        input_file: Path to the input file.

    Returns:
        Tuple as described in parse_text_map.
    """"""
    with open(input_file, 'r') as f:
        # Filter out empty or whitespace-only lines
        lines = [line.strip() for line in f if line.strip()]
    return parse_text_map(lines)


def solve_part_one(
    obstacles: Set[Tuple[int, int]],
    start_state: Tuple[int, int, int, int],
    num_rows: int,
    num_cols: int
) -> int:
    """"""
    Simulates the guard's movement and counts distinct visited positions on the map.

    The guard follows these rules:
    1. If there is an obstacle (#) directly in front, turn right 90 degrees.
    2. Otherwise, take one step forward.

    The simulation stops when the guard steps off the map.

    Args:
        obstacles: A set of (row, col) coordinates of obstacles.
        start_state: A tuple (row, col, dr, dc) representing the guard's initial
                     position and direction vector.
        num_rows: The number of rows in the map.
        num_cols: The number of columns in the map.

    Returns:
        The number of distinct positions visited by the guard on the map.
    """"""
    if num_rows == 0 or num_cols == 0:
        return 0 # No place to visit on an empty/degenerate map

    current_r, current_c, current_dr, current_dc = start_state

    # Guard must start on the map. If not, 0 positions visited.
    if not (0 <= current_r < num_rows and 0 <= current_c < num_cols):
        return 0

    visited_positions: Set[Tuple[int, int]] = set()

    # Loop as long as the guard is on the map
    while 0 <= current_r < num_rows and 0 <= current_c < num_cols:
        visited_positions.add((current_r, current_c))

        next_r_in_front = current_r + current_dr
        next_c_in_front = current_c + current_dc

        # An obstacle is ""something directly in front"". Obstacles are always on-map.
        is_obstacle_in_front = (next_r_in_front, next_c_in_front) in obstacles

        if is_obstacle_in_front:
            # Turn right (clockwise)
            current_dir_index = DIR_TO_INDEX[(current_dr, current_dc)]
            new_dir_index = (current_dir_index + 1) % len(DIRECTIONS_ORDERED)
            current_dr, current_dc = DIRECTIONS_ORDERED[new_dir_index]
            # Guard stays at (current_r, current_c), but direction changes for the next iteration.
        else:
            # No obstacle in front: step forward.
            # This step might take the guard off the map.
            current_r = next_r_in_front
            current_c = next_c_in_front
            # The loop condition (while on_map) will handle termination if guard moves off-map.

    return len(visited_positions)

# --- Test Cases ---
EXAMPLE_INPUT_STR = """"""....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...""""""

def run_tests():
    """"""Runs all defined test cases.""""""
    print(""--- Running Tests ---"", file=sys.stderr)
    test_example_case()
    test_custom_cases()
    print(""--- All Tests Passed ---"", file=sys.stderr)

def test_example_case():
    """"""Tests the provided example from the problem description.""""""
    print(""Testing official example..."", file=sys.stderr)
    lines = [line.strip() for line in EXAMPLE_INPUT_STR.strip().split('\n')]
    obstacles, start_state, num_rows, num_cols = parse_text_map(lines)

    expected_start_state = (6, 4, UP[0], UP[1]) # (row=6, col=4, dir=UP)
    assert start_state == expected_start_state, \
        f""Example parsing error: start_state. Expected {expected_start_state}, got {start_state}""
    assert num_rows == 10, f""Example parsing error: num_rows. Expected 10, got {num_rows}""
    assert num_cols == 10, f""Example parsing error: num_cols. Expected 10, got {num_cols}""

    assert (0,4) in obstacles, ""Example parsing error: obstacle at (0,4) missing""
    assert (6,4) not in obstacles, ""Example parsing error: guard start pos (6,4) should not be an obstacle""

    result = solve_part_one(obstacles, start_state, num_rows, num_cols)
    expected_result = 41
    assert result == expected_result, \
        f""Example test failed: Expected {expected_result}, got {result}""
    print(""Official example test passed."", file=sys.stderr)

def test_custom_cases():
    """"""Tests various custom edge cases.""""""
    print(""Testing custom cases..."", file=sys.stderr)

    # Case 1: Guard starts facing out of bounds
    case1_map_str = ""^""
    lines = [line.strip() for line in case1_map_str.strip().split('\n')]
    obs, state, r, c = parse_text_map(lines)
    res = solve_part_one(obs, state, r, c)
    assert res == 1, f""Custom Case 1 (^) failed: Expected 1, got {res}. Visited: {(0,0)}""

    # Case 2: Guard faces an obstacle immediately, turns, then moves off map
    case2_map_str = ""^#""
    lines = [line.strip() for line in case2_map_str.strip().split('\n')]
    obs, state, r_count, c_count = parse_text_map(lines)
    # Start: (0,0) UP. Obstacle: (0,1).
    # Iter 1: (0,0)UP. Visited {(0,0)}. Front (-1,0) clear. Move. Pos=(-1,0). Off map. Loop ends.
    # This was error in manual trace. It doesn't see (0,1) if facing UP. It sees (-1,0).
    res = solve_part_one(obs, state, r_count, c_count)
    assert res == 1, f""Custom Case 2 (^#) failed: Expected 1, got {res}. Visited: {(0,0)}""

    # Case 2b: Guard at (0,0) facing Right towards obstacle at (0,1)
    case2b_map_str = "">#""
    lines = [line.strip() for line in case2b_map_str.strip().split('\n')]
    obs, state, r_count, c_count = parse_text_map(lines)
    # Start: (0,0)R. Obstacle: (0,1).
    # Iter 1: (0,0)R. Visited {(0,0)}. Front (0,1) is obstacle. Turn. Dir=DOWN. Pos=(0,0).
    # Iter 2: (0,0)D. Visited {(0,0)}. Front (1,0) clear (off-map). Move. Pos=(1,0). Off map. Loop ends.
    res = solve_part_one(obs, state, r_count, c_count)
    assert res == 1, f""Custom Case 2b (>#) failed: Expected 1, got {res}. Visited: {(0,0)}""

    # Case 3: Empty map input (no lines or only whitespace lines)
    empty_map_str = """"
    lines = [line.strip() for line in empty_map_str.strip().split('\n') if line.strip()]
    obs, state, r_count, c_count = parse_text_map(lines)
    assert r_count == 0 and c_count == 0, ""Empty map parsing failed""
    res = solve_part_one(obs, state, r_count, c_count)
    assert res == 0, f""Custom Case Empty Map failed: Expected 0, got {res}""

    print(""Custom cases passed."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        print(f""Alternatively, use 'python3 {sys.argv[0]} test' to run example tests."", file=sys.stderr)
        sys.exit(1)

    input_arg = sys.argv[1]

    if input_arg.lower() == ""test"":
        run_tests()
        return

    try:
        obstacles, start_state, num_rows, num_cols = parse_input(input_arg)
    except FileNotFoundError:
        print(f""Error: Input file '{input_arg}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    solution = solve_part_one(obstacles, start_state, num_rows, num_cols)
    # Only print the solution to STDOUT for AoC submission compatibility
    print(solution)

if __name__ == ""__main__"":
    main()
"
6,system,gemini-2.5-pro-preview-05-06,True,1151.2887198925018,"""""""
Advent of Code 2023 Day 6 (Hypothetical, based on prompt): Guard Gallivant
Solution implementation based on the provided plan.

Simulates a guard's movement on a 2D grid. The guard follows specific rules:
- If an obstacle ('#') is directly in front, turn right 90 degrees.
- Otherwise, step forward.
The simulation counts the number of distinct grid cells visited, including the
starting cell, until the guard steps off the map.
The starting cell of the guard is treated as '.' after initial state is recorded.

Usage: python3 solution.py [input_file | test]
""""""
import sys
from typing import List, Tuple, Dict, Set, NamedTuple, Optional

# Define constants for directions and parsing
# Directions: 0: Up, 1: Right, 2: Down, 3: Left
# (delta_row, delta_col)
DIRECTION_DELTAS: List[Tuple[int, int]] = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # Up, Right, Down, Left
INITIAL_DIRECTION_MAP: Dict[str, int] = {'^': 0, '>': 1, 'v': 2, '<': 3}
NUM_DIRECTIONS = len(DIRECTION_DELTAS)

class ParsedInput(NamedTuple):
    """"""
    Stores the parsed input data for the simulation.

    Attributes:
        grid: The map as a list of lists of characters.
        initial_pos: Guard's starting (row, col) coordinates.
        initial_dir_idx: Guard's starting direction index.
        grid_height: Number of rows in the grid.
        grid_width: Number of columns in the grid.
    """"""
    grid: List[List[str]]
    initial_pos: Tuple[int, int]
    initial_dir_idx: int
    grid_height: int
    grid_width: int


def parse_input(input_file: str) -> ParsedInput:
    """"""Parse the puzzle input from file into appropriate data structures.

    Reads the grid, finds the guard's initial position and direction,
    replaces the guard's character with '.', and returns structured data.

    Args:
        input_file: Path to the input file.

    Returns:
        A ParsedInput NamedTuple containing the grid and initial state.

    Raises:
        ValueError: If the input grid is empty, guard is not found,
                    rows have inconsistent lengths, or multiple guards are found.
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out empty lines that might result from multiple newlines, etc.
    grid_lines_content = [s for s in lines if s]
    if not grid_lines_content:
        raise ValueError(""Input file is empty or contains no lines with content."")

    grid_repr: List[List[str]] = [list(row_str) for row_str in grid_lines_content]

    if not grid_repr: # Should be caught by previous check, but as a safeguard.
        raise ValueError(""Grid is empty after parsing lines."")

    grid_height: int = len(grid_repr)
    grid_width: int = len(grid_repr[0])

    if not all(len(row) == grid_width for row in grid_repr):
        raise ValueError(""Grid rows have inconsistent lengths."")

    initial_guard_pos: Optional[Tuple[int, int]] = None
    initial_guard_direction_idx: Optional[int] = None

    guard_found = False
    for r in range(grid_height):
        for c in range(grid_width):
            char = grid_repr[r][c]
            if char in INITIAL_DIRECTION_MAP:
                if initial_guard_pos is not None:
                    raise ValueError(""Multiple guards found in input, problem constraints violated."")
                initial_guard_pos = (r, c)
                initial_guard_direction_idx = INITIAL_DIRECTION_MAP[char]
                grid_repr[r][c] = '.'  # Replace guard's start cell with empty space
                guard_found = True
                break # Breaks inner c loop (column scan)
        if guard_found:
            break # Breaks outer r loop (row scan)

    if initial_guard_pos is None or initial_guard_direction_idx is None:
        raise ValueError(""Guard not found in input."")

    # Cast to non-Optional types as we've validated they are set.
    # Type checkers might not infer this perfectly across guard_found logic,
    # but at runtime, this will be fine due to the ValueError above.
    return ParsedInput(grid_repr, initial_guard_pos, initial_guard_direction_idx, grid_height, grid_width)


def solve_part_one(parsed_data: ParsedInput) -> int:
    """"""Solve part one of the puzzle: Simulate guard movement and count visited cells.

    Args:
        parsed_data: Processed input data from parse_input.

    Returns:
        The total count of distinct cells visited by the guard.
    """"""
    grid = parsed_data.grid
    current_pos = parsed_data.initial_pos
    current_dir_idx = parsed_data.initial_dir_idx
    grid_height = parsed_data.grid_height
    grid_width = parsed_data.grid_width

    visited_cells: Set[Tuple[int, int]] = set()

    while True:
        # Mark current cell as visited (Constraint: ""at the beginning of each decision step"")
        visited_cells.add(current_pos)

        # Determine forward cell based on current direction
        dr, dc = DIRECTION_DELTAS[current_dir_idx]
        forward_row, forward_col = current_pos[0] + dr, current_pos[1] + dc

        # Check forward cell status
        # Case 1: Off map
        if not (0 <= forward_row < grid_height and 0 <= forward_col < grid_width):
            # Guard steps off the map. Simulation ends.
            break

        # Forward cell is on the map. Check its content.
        cell_in_front = grid[forward_row][forward_col]

        if cell_in_front == '#':
            # Case 2: Obstacle
            # Turn right (clockwise 90 degrees)
            current_dir_idx = (current_dir_idx + 1) % NUM_DIRECTIONS
            # Position does not change
        elif cell_in_front == '.':
            # Case 3: Empty space
            # Move forward
            current_pos = (forward_row, forward_col)
            # Direction does not change
        else:
            # This case should ideally not be reached if input adheres to '#', '.', and initial guard symbols.
            raise ValueError(f""Unexpected character '{cell_in_front}' encountered at ({forward_row},{forward_col})."")

    return len(visited_cells)


def main():
    """"""
    Main entry point for the script. Parses arguments, runs the simulation,
    and prints the result. Allows 'test' argument to run example test cases.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file | test]"", file=sys.stderr)
        return

    input_arg = sys.argv[1]

    if input_arg.lower() == ""test"":
        run_tests()
        return

    try:
        parsed_data = parse_input(input_arg)
        solution = solve_part_one(parsed_data)
        print(solution) # Output final solution to STDOUT
    except FileNotFoundError:
        print(f""Error: Input file '{input_arg}' not found."", file=sys.stderr)
    except ValueError as e:
        print(f""Error: {e}"", file=sys.stderr)
    except Exception as e:
        print(f""An unexpected error occurred: {e}"", file=sys.stderr)


def run_tests():
    """"""
    Runs test cases against the solution. Test results and messages are printed to STDERR.
    """"""
    # Test Case 1 (from problem description)
    example_input_str = """"""....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...""""""

    import tempfile
    import os

    # Using a temporary file to test the parse_input function as it's intended to be used.
    tmp_file_path = """"
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, encoding='utf-8') as tmp_file:
            tmp_file.write(example_input_str)
            tmp_file_path = tmp_file.name

        parsed_data_example = parse_input(tmp_file_path)
        result_example = solve_part_one(parsed_data_example)
        expected_example = 41

        assert result_example == expected_example, \
            f""Test Case 1 Failed: Expected {expected_example}, Got {result_example}""
        print(""Test Case 1 Passed!"", file=sys.stderr)

    except AssertionError as e:
        print(str(e), file=sys.stderr)
    except Exception as e:
        print(f""Error during test execution: {e}"", file=sys.stderr)
    finally:
        if tmp_file_path and os.path.exists(tmp_file_path):
            os.remove(tmp_file_path)

    # Add more test cases here if available or deemed necessary for robust testing.
    # Example of a simple edge case: guard starts at corner, facing out.
    # test_small_grid_immediate_exit_str = ""^""
    # ... (similar temp file logic and assertion) ...

if __name__ == ""__main__"":
    main()
"
7,single-model,gemini-2.5-pro-preview-05-06,True,162.56462907791138,"import sys
from typing import List, Tuple

# Advent of Code YYYY Day 7: Bridge Repair
# Solution implementation for determining which calibration equations can be true.
#
# The problem requires evaluating expressions with numbers and operators (+, *),
# where operators are evaluated left-to-right. For each equation (a target value
# and a list of numbers), we need to check if any combination of operators
# can make the expression equal the target. The final result is the sum of
# target values for all such ""true"" equations.
#
# The core logic uses a recursive backtracking approach (`_recursive_eval`)
# to try all possible operator combinations.
#
# Usage: python3 solution.py [input_file]


# Define Equation type alias for clarity
Equation = Tuple[int, List[int]]

# Example input data from the problem description
EXAMPLE_INPUT = """"""
190: 10 19
3267: 81 40 27
83: 17 5
156: 15 6
7290: 6 8 6 15
161011: 16 10 13
192: 17 8 14
21037: 9 7 18 13
292: 11 6 16 20
""""""

def parse_text_input(text_input: str) -> List[Equation]:
    """"""
    Parses a string containing multiple lines of equations.
    Each equation is represented as a tuple: (target_value, list_of_numbers).
    Handles and warns about malformed lines.
    """"""
    equations: List[Equation] = []
    # .splitlines() handles various newline characters consistently
    for line_num, line_content in enumerate(text_input.strip().splitlines(), 1):
        line = line_content.strip()
        if not line: # Skip empty lines
            continue

        parts = line.split(':', 1) # Split only on the first colon
        if len(parts) != 2:
            print(f""Warning (line {line_num}): Skipping malformed line (no colon or incorrect format): {line_content}"", file=sys.stderr)
            continue

        target_str, numbers_part_str = parts[0].strip(), parts[1].strip()

        try:
            target = int(target_str)
        except ValueError:
            print(f""Warning (line {line_num}): Invalid target value '{target_str}'. Skipping line: {line_content}"", file=sys.stderr)
            continue

        numbers_str_list = numbers_part_str.split()

        if not numbers_str_list: # Handles cases like ""10:"" or ""10:  ""
            print(f""Warning (line {line_num}): Equation with no numbers. Skipping line: {line_content}"", file=sys.stderr)
            continue

        try:
            numbers = [int(n) for n in numbers_str_list]
        except ValueError:
            # This handles cases like ""10: 1 2 abc 3""
            print(f""Warning (line {line_num}): Line contains non-integer number(s). Skipping line: {line_content}"", file=sys.stderr)
            continue

        equations.append((target, numbers))

    return equations

def parse_input(input_file: str) -> List[Equation]:
    """"""Parse the puzzle input from file into a list of equations.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of equations. Each equation is a tuple of
        (target_value, list_of_numbers).
        Exits if the file cannot be read.
    """"""
    try:
        with open(input_file, 'r') as f:
            content = f.read()
        return parse_text_input(content)
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1) # Exit with error code for file issues
    except Exception as e:
        print(f""Error reading or parsing file: {e}"", file=sys.stderr)
        sys.exit(1) # Exit with error code for other file issues


def _recursive_eval(current_value: int, numbers_idx: int, all_numbers: List[int], target: int) -> bool:
    """"""
    Helper recursive function to evaluate expressions by trying all operator combinations.

    Args:
        current_value: The accumulated value from the expression evaluated so far (left-to-right).
        numbers_idx: The index of the next number in `all_numbers` to be incorporated.
        all_numbers: The full list of numbers for the current equation.
        target: The target value the expression should evaluate to.

    Returns:
        True if an operator combination results in `target`, False otherwise.
    """"""
    # Base case: all numbers have been processed and incorporated into current_value
    if numbers_idx == len(all_numbers):
        return current_value == target

    next_number = all_numbers[numbers_idx]

    # Try with '+' operator: current_value + next_number
    if _recursive_eval(current_value + next_number, numbers_idx + 1, all_numbers, target):
        return True

    # Try with '*' operator: current_value * next_number
    if _recursive_eval(current_value * next_number, numbers_idx + 1, all_numbers, target):
        return True

    # No combination from this path led to the target
    return False


def can_form_target(target: int, numbers: List[int]) -> bool:
    """"""
    Determines if the list of numbers can form the target value using '+' or '*'
    operators, evaluated strictly left-to-right.

    Args:
        target: The integer value to aim for.
        numbers: A list of integers to combine.

    Returns:
        True if `numbers` can form `target`, False otherwise.
    """"""
    if not numbers:
        # An equation with no numbers cannot form any target value.
        # Problem context implies numbers will always be present in valid equations.
        return False

    # The recursion starts with the first number as the initial `current_value`.
    # Subsequent numbers (from index 1) are then incorporated one by one.
    # If `numbers` has only one element, `_recursive_eval` handles this correctly:
    # `numbers_idx` (1) will equal `len(all_numbers)` (1), leading to the base case
    # which checks if `numbers[0] == target`.
    return _recursive_eval(numbers[0], 1, numbers, target)


def solve_part_one(equations: List[Equation]) -> int:
    """"""Solve part one of the puzzle.
    Calculates the sum of target values for all equations that can be satisfied.

    Args:
        equations: A list of parsed equations.

    Returns:
        The total calibration result (sum of target values of true equations).
    """"""
    total_calibration_result = 0
    for target, numbers in equations:
        if can_form_target(target, numbers):
            total_calibration_result += target

    return total_calibration_result


def run_tests():
    """"""Runs test cases against the implementation. Output is to stderr.""""""
    print(""Running tests..."", file=sys.stderr)

    # Test case 1: Provided example from problem description
    example_equations = parse_text_input(EXAMPLE_INPUT)
    expected_result = 3749
    actual_result = solve_part_one(example_equations)
    assert actual_result == expected_result, \
        f""Test Case 1 (Full Example) Failed: Expected {expected_result}, Got {actual_result}""
    print(""Test Case 1 (Full Example) Passed."", file=sys.stderr)

    # Individual can_form_target tests
    assert can_form_target(190, [10, 19]) == True, ""Test (can_form_target): 190: 10 19""
    assert can_form_target(3267, [81, 40, 27]) == True, ""Test (can_form_target): 3267: 81 40 27""
    assert can_form_target(292, [11, 6, 16, 20]) == True, ""Test (can_form_target): 292: 11 6 16 20""
    assert can_form_target(83, [17, 5]) == False, ""Test (can_form_target): 83: 17 5""
    assert can_form_target(29, [10, 19]) == True, ""Test (can_form_target): 29: 10 19 (10+19)""
    assert can_form_target(10, [10]) == True, ""Test (can_form_target): 10: 10""
    assert can_form_target(0, []) == False, ""Test (can_form_target): 0: (empty)""
    print(""Individual can_form_target tests passed."", file=sys.stderr)

    # Test parsing robustness
    malformed_input_test = """"""
    10: 1 2
    20: 3 4: 5
    30: 6 abc 7
    : 8 9
    40:
    50: 10
    """"""
    parsed_malformed = parse_text_input(malformed_input_test)

    expected_equations = [(10, [1,2]), (50, [10])]
    assert parsed_malformed == expected_equations, \
        f""Test (parse_text_input robustness): Expected {expected_equations}, got {parsed_malformed}""
    print(""Parser robustness tests passed (check stderr for expected warnings)."", file=sys.stderr)

    print(""All assertion tests passed."", file=sys.stderr)


def main():
    # Run tests. Output to stderr.
    run_tests()
    print(""-"" * 20, file=sys.stderr)

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        # As per template, just return. For CLI, sys.exit(1) would be common.
        return

    input_file = sys.argv[1]
    # parse_input handles file errors and exits if necessary
    parsed_data = parse_input(input_file)

    part_one_solution = solve_part_one(parsed_data)

    # Print the final solution to STDOUT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
7,system,gemini-2.5-pro-preview-05-06,True,1199.2310004234314,"""""""
Advent of Code [Year] Day [Day]: Operator Insertion Puzzle
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file_path]
   or: python3 solution.py --test (to run example tests)
""""""
import sys
from typing import List, Tuple

# Constants for example testing as per the problem description
EXAMPLE_INPUT_STR = """"""190: 10 19
3267: 81 40 27
83: 17 5
156: 15 6
7290: 6 8 6 15
161011: 16 10 13
192: 17 8 14
21037: 9 7 18 13
292: 11 6 16 20""""""
EXPECTED_EXAMPLE_OUTPUT = 3749

def _parse_lines(lines_content: List[str]) -> List[Tuple[int, List[int]]]:
    """"""Helper function to parse lines of equation strings.

    Args:
        lines_content: A list of strings, each representing a line from input.

    Returns:
        A list of (target_value, operands_list) tuples.
    """"""
    equations: List[Tuple[int, List[int]]] = []
    for line_num, line_str in enumerate(lines_content, 1):
        line = line_str.strip()
        if not line:  # Skip empty or whitespace-only lines
            continue

        # Plan specifies splitting at "": ""
        parts = line.split(': ', 1)
        if len(parts) != 2:
            print(f""Warning: Malformed line {line_num} (expected 'TARGET: OPERANDS' format) skipped: '{line}'"", file=sys.stderr)
            continue

        target_str, operands_full_str = parts

        try:
            target_value = int(target_str) # Assumes target_str is clean, no extra spaces

            # Split operands string by space; filter out empty strings if multiple spaces occur
            operand_strings = [op_s for op_s in operands_full_str.split(' ') if op_s]

            if not operand_strings: # Check if there are any operand strings after split
                 print(f""Warning: Line {line_num} has no operands after parsing: '{line}'"", file=sys.stderr)
                 continue

            operands = [int(op_str) for op_str in operand_strings]
            equations.append((target_value, operands))

        except ValueError:
            # This catches errors from int() conversion for target or operands
            print(f""Warning: Line {line_num} contains non-integer value(s), skipped: '{line}'"", file=sys.stderr)
            continue

    return equations

def parse_input_from_file(input_file_path: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from a file.

    Args:
        input_file_path: Path to the input file.

    Returns:
        A list of tuples, where each tuple is (target_value, operands_list).
    """"""
    try:
        with open(input_file_path, 'r') as f:
            lines = f.readlines()
        return _parse_lines(lines)
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file_path}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading or parsing file {input_file_path}: {e}"", file=sys.stderr)
        sys.exit(1)

def can_achieve_target(
    current_eval_result: int,
    next_operand_idx: int,
    all_operands: List[int],
    target_value: int
) -> bool:
    """"""
    Recursively explores if the target_value can be achieved by applying
    '+' or '*' operators to the remaining operands. Evaluation is left-to-right.

    Args:
        current_eval_result: The accumulated value of the expression so far.
                             Initially, this is all_operands[0].
        next_operand_idx: Index of the next operand in all_operands to incorporate.
                          Starts at 1 (for all_operands[1]).
        all_operands: The full list of operand integers for the current equation.
        target_value: The target integer for the current equation.

    Returns:
        True if there exists a combination of operators that results in target_value,
        False otherwise.
    """"""
    # Base Case: All operands have been processed and incorporated.
    if next_operand_idx == len(all_operands):
        return current_eval_result == target_value

    operand_to_apply = all_operands[next_operand_idx]

    # Recursive Step: Try Addition ('+')
    # If adding the current operand leads to a solution, return True.
    if can_achieve_target(current_eval_result + operand_to_apply,
                          next_operand_idx + 1,
                          all_operands,
                          target_value):
        return True

    # Recursive Step: Try Multiplication ('*')
    # If multiplying by the current operand leads to a solution, return True.
    if can_achieve_target(current_eval_result * operand_to_apply,
                          next_operand_idx + 1,
                          all_operands,
                          target_value):
        return True

    # If neither operator choice leads to a solution from this state, return False.
    return False

def solve_puzzle(parsed_data: List[Tuple[int, List[int]]]) -> int:
    """"""
    Calculates the sum of target values for all solvable equations based on the plan.

    Args:
        parsed_data: A list of (target_value, operands_list) tuples, where
                     operands_list contains at least one operand.

    Returns:
        The sum of target values for solvable equations.
    """"""
    total_calibration_result = 0
    for target, ops_list in parsed_data:
        # Per constraints (k >= 1), ops_list has at least one element.

        if len(ops_list) == 1:
            # Single Operand Case: Solvable if the operand itself is the target.
            if ops_list[0] == target:
                total_calibration_result += target
        else:
            # Multiple Operands Case (len(ops_list) > 1):
            # The first operand ops_list[0] is the initial current_eval_result.
            # The recursive solver starts by trying to incorporate ops_list[1],
            # so next_operand_idx is 1.
            initial_eval_result = ops_list[0]
            if can_achieve_target(initial_eval_result, 1, ops_list, target):
                total_calibration_result += target

    return total_calibration_result

def run_example_tests():
    """"""Runs tests using the provided example input and expected output.
    Prints results to stderr.
    """"""
    print(""Running example test..."", file=sys.stderr)
    # Use _parse_lines directly for string input for tests
    example_data = _parse_lines(EXAMPLE_INPUT_STR.strip().split('\n'))
    example_solution = solve_puzzle(example_data)

    print(f""Example Input:\n{EXAMPLE_INPUT_STR}"", file=sys.stderr)
    print(f""Calculated Example Output: {example_solution}"", file=sys.stderr)
    print(f""Expected Example Output: {EXPECTED_EXAMPLE_OUTPUT}"", file=sys.stderr)

    if example_solution == EXPECTED_EXAMPLE_OUTPUT:
        print(""Example Test PASSED"", file=sys.stderr)
    else:
        print(f""Example Test FAILED: Expected {EXPECTED_EXAMPLE_OUTPUT}, Got {example_solution}"", file=sys.stderr)
    print(""-"" * 30, file=sys.stderr)

def main():
    """"""
    Main entry point for the script. Parses command line arguments,
    reads input, solves the puzzle, and prints the solution.
    Includes an option to run example tests via '--test' argument.
    """"""
    if len(sys.argv) == 2 and sys.argv[1] == ""--test"":
        run_example_tests()
        return

    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file_path]"", file=sys.stderr)
        print(""   or: python3 solution.py --test"", file=sys.stderr)
        sys.exit(1)

    input_file_path = sys.argv[1]
    parsed_data = parse_input_from_file(input_file_path)

    # If parsed_data is empty (e.g., file was empty or all lines malformed),
    # solve_puzzle will correctly return 0.
    if not parsed_data:
        print(f""Warning: No valid equations found in '{input_file_path}'. Sum will be 0."", file=sys.stderr)

    solution = solve_puzzle(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
8,single-model,gemini-2.5-pro-preview-05-06,False,162.41527009010315,"""""""
Advent of Code Day 8: Resonant Collinearity
Solution implementation.

This program calculates the number of unique antinode locations on a map based on antenna positions.
Antennas are represented by characters on a grid. Antennas of the same frequency (same character)
can create antinodes. An antinode point P is formed by two antennas A and B of the same frequency
if P is collinear with A and B, and one antenna is twice as far from P as the other.

For any pair of antennas A and B of the same frequency, two such antinode points exist:
1. P1 = 2*A - B (vector math: P1 = A - (B - A)). Here, A is between P1 and B.
   Distance(P1, B) = 2 * Distance(P1, A).
2. P2 = 2*B - A (vector math: P2 = B + (B - A)). Here, B is between A and P2.
   Distance(A, P2) = 2 * Distance(A, B).  (Correction: this should be Distance(A, P2) = 2 * Distance(A, B_midpoint_P2), or more simply: P2 is such that B is the midpoint of A and P2, and antenna A is twice as far from P2 as antenna B is from P2. The formula 2*B - A is correct for the point P where A, B, P are collinear in that order and dist(A,P) = 2 * dist(A,B).)
   Let's re-verify the problem statement's implication: ""one on either side of them"".
   If A and B are antennas, antinodes P are where dist(P, X) = 2 * dist(P, Y) where X, Y is A,B or B,A.
   Case 1: P, A, B are collinear. dist(P,B) = 2 * dist(P,A).  A is midpoint of P and M (where M is midpoint of P and B). Vector PA = A-P. PB = B-P. B-P = 2(A-P) => B-P = 2A-2P => P = 2A-B.
   Case 2: P, B, A are collinear. dist(P,A) = 2 * dist(P,B).  B is midpoint of P and M (where M is midpoint of P and A). Vector PB = B-P. PA = A-P. A-P = 2(B-P) => A-P = 2B-2P => P = 2B-A.
   These are the two points, and the formulas 2A-B and 2B-A are correct.

The program parses the map to find antenna locations, groups them by frequency,
then iterates through pairs of same-frequency antennas to calculate potential antinodes.
Calculated antinodes are checked to ensure they are within map boundaries.
A set is used to store unique antinode locations, and its size is the final answer.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set
import sys
from collections import defaultdict

def parse_input(input_file: str) -> Tuple[Dict[str, List[Tuple[int, int]]], int, int]:
    """"""Parse the puzzle input from file into antenna locations and map dimensions.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
        - antennas_by_freq: Dictionary mapping frequency character to a list of
                            (row, col) tuples representing antenna locations.
        - map_height: The height (number of rows) of the map.
        - map_width: The width (number of columns) of the map.
    """"""
    lines: List[str] = []
    try:
        with open(input_file, 'r') as f:
            # Read all lines, strip whitespace from ends, and filter out empty lines
            lines = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1) # Exit if file not found
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1) # Exit on other read errors

    if not lines:
        # If the file was empty or contained only whitespace
        return defaultdict(list), 0, 0

    map_height = len(lines)
    # Assume a rectangular grid based on the first line's length.
    map_width = len(lines[0])

    antennas_by_freq: Dict[str, List[Tuple[int, int]]] = defaultdict(list)

    for r, row_str in enumerate(lines):
        # Validate that the map is rectangular.
        if len(row_str) != map_width:
            print(f""Error: Input map is not rectangular. Row {r} has length {len(row_str)}, ""
                  f""expected {map_width} based on the first row."", file=sys.stderr)
            sys.exit(1) # Exit if map is not rectangular

        for c, char_val in enumerate(row_str):
            if char_val != '.': # '.' represents empty space
                antennas_by_freq[char_val].append((r, c))

    return antennas_by_freq, map_height, map_width

def solve_part_one(antennas_by_freq: Dict[str, List[Tuple[int, int]]],
                   map_height: int, map_width: int) -> int:
    """"""Calculate the total number of unique antinode locations.

    Args:
        antennas_by_freq: A dictionary mapping antenna frequencies to lists of their (row, col) coordinates.
        map_height: The height of the map.
        map_width: The width of the map.

    Returns:
        The count of unique antinode locations within the map boundaries.
    """"""
    # If map dimensions are zero (e.g., from empty input), no antinodes can exist.
    if map_height == 0 or map_width == 0:
        return 0

    all_antinodes: Set[Tuple[int, int]] = set()

    # Iterate over each frequency and its list of antenna coordinates
    for freq, antenna_coords_list in antennas_by_freq.items():
        num_antennas_of_freq = len(antenna_coords_list)

        # Antinodes require at least two antennas of the same frequency
        if num_antennas_of_freq < 2:
            continue

        # Consider all unique pairs of antennas (A, B) for the current frequency
        for i in range(num_antennas_of_freq):
            for j in range(i + 1, num_antennas_of_freq):
                # Antenna A coordinates
                r1, c1 = antenna_coords_list[i]
                # Antenna B coordinates
                r2, c2 = antenna_coords_list[j]

                # Calculate first potential antinode P1 = 2*A - B.
                # This corresponds to the case where P1, A, B are collinear in that order,
                # and antenna B is twice as far from P1 as antenna A is from P1.
                p1_r, p1_c = 2 * r1 - r2, 2 * c1 - c2

                # Add P1 to the set if it's within map boundaries
                if 0 <= p1_r < map_height and 0 <= p1_c < map_width:
                    all_antinodes.add((p1_r, p1_c))

                # Calculate second potential antinode P2 = 2*B - A.
                # This corresponds to the case where P2, B, A are collinear in that order (or A, B, P2),
                # and antenna A is twice as far from P2 as antenna B is from P2.
                p2_r, p2_c = 2 * r2 - r1, 2 * c2 - c1

                # Add P2 to the set if it's within map boundaries
                if 0 <= p2_r < map_height and 0 <= p2_c < map_width:
                    all_antinodes.add((p2_r, p2_c))

    # The result is the total count of unique antinode locations found
    return len(all_antinodes)

def main():
    """"""Main script execution.""""""
    # Ensure an input file path is provided as a command-line argument
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1) # Exit if no input file specified

    input_file = sys.argv[1]

    # Parse the input file to get antenna data and map dimensions
    antennas_data, map_h, map_w = parse_input(input_file)

    # Calculate the solution for Part One
    # (This problem description implies a single part problem)
    solution = solve_part_one(antennas_data, map_h, map_w)

    # Print the final solution to standard output
    # Per AoC conventions, only the answer should be printed to STDOUT.
    print(solution)

# Helper function for tests (not called in standard execution)
# To run these tests, one could uncomment the call or add a CLI flag.
# Example: if __name__ == ""__main__"" and ""--test"" in sys.argv: run_tests(); sys.exit()
def run_tests():
    """"""Runs a suite of test cases for verification.""""""
    print(""Running example tests..."", file=sys.stderr)

    # Test Case 1: Single pair 'a' antennas from problem description
    # Map: 10x10. Antennas: a at (3,4), (5,5)
    # Expected antinodes: (1,3), (7,6) -> 2 unique
    example1_antennas = defaultdict(list, {'a': [(3,4), (5,5)]})
    result1 = solve_part_one(example1_antennas, 10, 10)
    expected1 = 2
    assert result1 == expected1, f""Test Case 1 Failed: Expected {expected1}, Got {result1}""
    print(""Test Case 1 Passed"", file=sys.stderr)

    # Test Case 2: Three 'a' antennas from problem description
    # Map: 10x10. Antennas: a at (3,4), (4,8), (5,5)
    # Expected antinodes: (1,3), (2,0), (6,2), (7,6) -> 4 unique
    example2_antennas = defaultdict(list, {'a': [(3,4), (4,8), (5,5)]})
    result2 = solve_part_one(example2_antennas, 10, 10)
    expected2 = 4
    assert result2 == expected2, f""Test Case 2 Failed: Expected {expected2}, Got {result2}""
    print(""Test Case 2 Passed"", file=sys.stderr)

    # Test Case 3: Full problem example data (manual check or requires example input file)
    # Based on manual walkthrough for example_day8.txt data yielding 14 antinodes.
    # If example_day8.txt were available:
    # antennas_ex3, h_ex3, w_ex3 = parse_input(""example_day8.txt"")
    # result_ex3 = solve_part_one(antennas_ex3, h_ex3, w_ex3)
    # expected_ex3 = 14
    # assert result_ex3 == expected_ex3, f""Full Example Test Failed: Expected {expected_ex3}, Got {result_ex3}""
    # print(""Full Example Test Passed"", file=sys.stderr)

    # Test Case 4: Empty input (results in 0,0 dimensions from parse_input)
    result_empty = solve_part_one(defaultdict(list), 0, 0)
    expected_empty = 0
    assert result_empty == expected_empty, f""Empty Input Test Failed: Expected {expected_empty}, Got {result_empty}""
    print(""Empty Input Test Passed"", file=sys.stderr)

    # Test Case 5: No antennas on a non-empty map
    result_no_antennas = solve_part_one(defaultdict(list), 10, 10)
    expected_no_antennas = 0
    assert result_no_antennas == expected_no_antennas, f""No Antennas Test Failed: Expected {expected_no_antennas}, Got {result_no_antennas}""
    print(""No Antennas Test Passed"", file=sys.stderr)

    # Test Case 6: Antennas, but all of different frequencies (or only one of each)
    example_diff_freq_antennas = defaultdict(list, {'a': [(1,1)], 'b': [(2,2)]})
    result_diff_freq = solve_part_one(example_diff_freq_antennas, 5, 5)
    expected_diff_freq = 0
    assert result_diff_freq == expected_diff_freq, f""Different Frequencies Test Failed: Expected {expected_diff_freq}, Got {result_diff_freq}""
    print(""Different Frequencies Test Passed"", file=sys.stderr)

    # Test Case 7: All antinodes out of bounds
    # Antennas A=(0,0), B=(1,1) on a 2x2 map (H=2, W=2).
    # P1 = 2*A-B = (-1,-1) -> Out.
    # P2 = 2*B-A = (2,2) -> Out (max index is 1 for 2x2 map).
    example_oob_antennas = defaultdict(list, {'a': [(0,0), (1,1)]})
    result_oob = solve_part_one(example_oob_antennas, 2, 2)
    expected_oob = 0
    assert result_oob == expected_oob, f""All Out Of Bounds Test Failed: Expected {expected_oob}, Got {result_oob}""
    print(""All Out Of Bounds Test Passed"", file=sys.stderr)

    # Test Case 8: One antinode in bounds, one out of bounds
    # Antennas A=(0,1), B=(1,1) on a 3x3 map (H=3, W=3).
    # P1 = 2*A-B = 2*(0,1)-(1,1) = (-1,1) -> Out (row -1).
    # P2 = 2*B-A = 2*(1,1)-(0,1) = (2,1) -> In.
    example_one_in_one_out = defaultdict(list, {'a': [(0,1), (1,1)]})
    result_one_in_one_out = solve_part_one(example_one_in_one_out, 3, 3)
    expected_one_in_one_out = 1
    assert result_one_in_one_out == expected_one_in_one_out, f""One In/One Out Test Failed: Expected {expected_one_in_one_out}, Got {result_one_in_one_out}""
    print(""One In/One Out Test Passed"", file=sys.stderr)

    print(""All defined tests completed."", file=sys.stderr)

if __name__ == ""__main__"":
    main()
"
8,system,gemini-2.5-pro-preview-05-06,True,994.1804921627045,"""""""
Advent of Code [Year] Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

This program calculates the number of unique antinode locations on a grid
of antennas. Antennas are defined by their position and frequency.
Antinodes are generated by pairs of antennas of the same frequency
according to specific geometric rules.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set
import sys
from collections import defaultdict
import itertools # For combinations

def _core_parse_logic(grid_lines: List[str]) -> Tuple[Dict[str, List[Tuple[int, int]]], int, int]:
    """"""Core logic to parse grid lines into antenna data.

    Args:
        grid_lines: A list of strings, where each string is a row of the map.
                    Assumed that empty/whitespace-only lines are already filtered.

    Returns:
        A tuple containing:
        - antennas_by_frequency: Dict mapping frequency char to list of (row, col) tuples.
        - num_rows: Number of rows in the grid.
        - num_cols: Number of columns in the grid.
    """"""
    if not grid_lines:
        return defaultdict(list), 0, 0

    num_rows = len(grid_lines)
    num_cols = len(grid_lines[0]) # Assuming rectangular grid from problem spec

    antennas_by_frequency: Dict[str, List[Tuple[int, int]]] = defaultdict(list)

    for r, row_str in enumerate(grid_lines):
        if len(row_str) != num_cols:
            # This case should ideally not happen based on typical AoC problem constraints
            # (uniform row lengths).
            print(f""Warning: Non-rectangular grid detected. Row {r} has length {len(row_str)}, expected {num_cols}. Behavior might be undefined."", file=sys.stderr)
            # For robustness, one might choose to error out or pad rows, but sticking to expected format.

        for c, char_val in enumerate(row_str):
            if char_val != '.': # '.' represents an empty location
                antennas_by_frequency[char_val].append((r, c))

    return antennas_by_frequency, num_rows, num_cols

def parse_input(input_file_path: str) -> Tuple[Dict[str, List[Tuple[int, int]]], int, int]:
    """"""Parse the puzzle input from a file.

    Args:
        input_file_path: Path to the input file.

    Returns:
        Data structures representing the parsed input, as per _core_parse_logic.
    """"""
    with open(input_file_path, 'r') as f:
        # Read lines and strip leading/trailing whitespace from each line
        lines = [line.strip() for line in f]

    # Filter out any lines that became completely empty after stripping.
    # This handles cases like empty lines used for formatting or trailing empty lines in the file.
    grid_lines = [line for line in lines if line]

    return _core_parse_logic(grid_lines)

def _parse_string_input(input_str: str) -> Tuple[Dict[str, List[Tuple[int, int]]], int, int]:
    """"""Helper function to parse puzzle input from a string (primarily for tests).

    Args:
        input_str: The string containing the puzzle input.

    Returns:
        Data structures representing the parsed input, as per _core_parse_logic.
    """"""
    lines = [line.strip() for line in input_str.splitlines()]
    grid_lines = [line for line in lines if line]
    return _core_parse_logic(grid_lines)

def calculate_antinodes(
    antennas_by_frequency: Dict[str, List[Tuple[int, int]]],
    num_rows: int,
    num_cols: int
) -> Set[Tuple[int, int]]:
    """"""Calculate all unique, in-bounds antinode locations.

    Args:
        antennas_by_frequency: Antennas grouped by frequency.
        num_rows: Number of rows in the grid.
        num_cols: Number of columns in the grid.

    Returns:
        A set of (row, col) tuples representing unique antinode locations.
    """"""
    unique_antinodes: Set[Tuple[int, int]] = set()

    if num_rows == 0 or num_cols == 0:
        return unique_antinodes # Empty grid means no antinodes

    for frequency_key in antennas_by_frequency:
        locations_list = antennas_by_frequency[frequency_key]

        # Need at least two antennas of the same frequency to form a pair
        if len(locations_list) < 2:
            continue

        # Generate all unique pairs of antennas for the current frequency
        for antenna1_coords, antenna2_coords in itertools.combinations(locations_list, 2):
            r1, c1 = antenna1_coords
            r2, c2 = antenna2_coords

            # Calculate P1 (antinode 1)
            # P1 is such that A1 is the midpoint of P1 and A2. (P1---A1---A2)
            # Formula: P1 = 2*A1 - A2
            p1_row = 2 * r1 - r2
            p1_col = 2 * c1 - c2
            if 0 <= p1_row < num_rows and 0 <= p1_col < num_cols:
                unique_antinodes.add((p1_row, p1_col))

            # Calculate P2 (antinode 2)
            # P2 is such that A2 is the midpoint of P2 and A1. (P2---A2---A1)
            # Formula: P2 = 2*A2 - A1
            p2_row = 2 * r2 - r1
            p2_col = 2 * c2 - c1
            if 0 <= p2_row < num_rows and 0 <= p2_col < num_cols:
                unique_antinodes.add((p2_row, p2_col))

    return unique_antinodes

def solve_part_one(parsed_data: Tuple[Dict[str, List[Tuple[int, int]]], int, int]) -> int:
    """"""Solve part one of the puzzle.
       (In this case, the problem seems to have only one part)

    Args:
        parsed_data: A tuple from parse_input containing:
                     - antennas_by_frequency: Dict mapping frequency to antenna locations.
                     - num_rows: Number of rows in the grid.
                     - num_cols: Number of columns in the grid.

    Returns:
        The total count of unique antinode locations.
    """"""
    antennas_by_frequency, num_rows, num_cols = parsed_data

    # If the grid is empty (num_rows or num_cols is 0),
    # calculate_antinodes will correctly return an empty set.
    # No special check for an empty grid is needed here before the call.

    unique_antinodes = calculate_antinodes(antennas_by_frequency, num_rows, num_cols)
    return len(unique_antinodes)

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Test with the example provided in the problem description
    example_input_str = """"""............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............""""""
    expected_example_output = 14

    # Use the string parsing helper for the example test
    example_parsed_data = _parse_string_input(example_input_str)
    example_solution = solve_part_one(example_parsed_data)

    # Print example test diagnostics to STDERR
    print(f""--- Example Test ---"", file=sys.stderr)
    # Example input string can be very long, so optionally print it or parts of it.
    # For brevity, it's omitted here, but can be useful: print(f""Example Input:\n{example_input_str}"", file=sys.stderr)
    antennas_dict, rows, cols = example_parsed_data
    print(f""Parsed Example Antennas: {dict(antennas_dict)}"", file=sys.stderr)
    print(f""Example Grid Dimensions: Rows={rows}, Cols={cols}"", file=sys.stderr)
    print(f""Expected Example Output: {expected_example_output}"", file=sys.stderr)
    print(f""Calculated Example Output: {example_solution}"", file=sys.stderr)

    assert example_solution == expected_example_output, \
        f""Example test FAILED! Expected {expected_example_output}, got {example_solution}""
    print(""Example test PASSED."", file=sys.stderr)
    print(f""--------------------"", file=sys.stderr)

    # Parse actual input from file
    parsed_data_main = parse_input(input_file)

    # Solve the puzzle for the actual input
    solution = solve_part_one(parsed_data_main)

    # ONLY PRINT THE FINAL RESULT for the actual input to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
9,single-model,gemini-2.5-pro-preview-05-06,False,196.0390384197235,"""""""
Advent of Code [Year] Day 9: Disk Fragmenter
Solution implementation for Part One.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

# Optional: A DEBUG flag for verbose output during defragmentation
# Set to True for step-by-step defrag output to stderr
DEBUG = False

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file.
    Reads the single line of disk map string.

    Args:
        input_file: Path to the input file.

    Returns:
        The disk map string.
    """"""
    try:
        with open(input_file, 'r') as f:
            line = f.readline().strip()
        if not line and DEBUG:
            print(f""Warning: Input file '{input_file}' is empty or contains only whitespace."", file=sys.stderr)
        return line
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

def expand_disk_map(disk_map_str: str) -> List[str]:
    """"""Expand the dense disk map string into a list representation of the disk.
    '0' represents a block of file ID 0, '.' represents free space.

    Args:
        disk_map_str: The dense disk map string (e.g., ""12345"").

    Returns:
        A list of strings representing blocks on the disk.
    """"""
    disk: List[str] = []
    file_id_counter = 0
    for i, length_char in enumerate(disk_map_str):
        try:
            length = int(length_char)
        except ValueError:
            if DEBUG:
                print(f""Warning: Invalid character '{length_char}' in disk map string. Assuming length 0."", file=sys.stderr)
            length = 0

        if length < 0:
            if DEBUG:
                print(f""Warning: Negative length '{length}' in disk map string. Assuming length 0."", file=sys.stderr)
            length = 0

        is_file_segment = (i % 2 == 0)

        if length == 0:
            if is_file_segment: # File of length 0
                file_id_counter += 1 # File ID is ""consumed""
            # For free space of length 0, or file of length 0, nothing is added to disk.
            continue

        if is_file_segment:  # File length
            for _ in range(length):
                disk.append(str(file_id_counter))
            file_id_counter += 1
        else:  # Free space length
            for _ in range(length):
                disk.append('.')
    return disk

def defragment_disk(disk: List[str]) -> List[str]:
    """"""Defragment the disk by moving file blocks from the end to the leftmost free space.
    Modifies the disk list in-place and also returns it.

    Args:
        disk: A list of strings representing the disk state.

    Returns:
        The defragmented disk state.
    """"""
    if not disk: # Handle empty disk
        return []

    while True:
        rightmost_file_block_idx = -1
        block_to_move = '' # Stores the file ID char of the block to move

        # Find the rightmost file block
        for i in range(len(disk) - 1, -1, -1):
            if disk[i] != '.':
                rightmost_file_block_idx = i
                block_to_move = disk[i]
                break

        if rightmost_file_block_idx == -1:
            if DEBUG:
                print(""Defrag: No file blocks found to move (disk is all free space or empty)."", file=sys.stderr)
            break # Process complete

        leftmost_free_space_idx = -1
        # Find the leftmost free space block
        for i in range(len(disk)):
            if disk[i] == '.':
                leftmost_free_space_idx = i
                break

        if leftmost_free_space_idx == -1:
            if DEBUG:
                print(""Defrag: No free space found (disk is full)."", file=sys.stderr)
            break # Process complete

        if leftmost_free_space_idx < rightmost_file_block_idx:
            if DEBUG:
                print(f""Defrag: Moving block '{block_to_move}' from index {rightmost_file_block_idx} to {leftmost_free_space_idx}"", file=sys.stderr)
            disk[leftmost_free_space_idx] = block_to_move
            disk[rightmost_file_block_idx] = '.'
            if DEBUG:
                print(f""Defrag: Disk state: {''.join(disk)}"", file=sys.stderr)
        else:
            if DEBUG:
                print(f""Defrag: No valid move. Leftmost free @ {leftmost_free_space_idx}, Rightmost file @ {rightmost_file_block_idx}. Process complete."", file=sys.stderr)
            break # Process complete

    return disk

def calculate_checksum(final_disk: List[str]) -> int:
    """"""Calculate the checksum of the defragmented disk.
    Checksum = sum of (block_position * file_ID) for all file blocks.

    Args:
        final_disk: The disk state after defragmentation.

    Returns:
        The calculated checksum.
    """"""
    checksum = 0
    for position, block_char in enumerate(final_disk):
        if block_char != '.':
            try:
                file_id = int(block_char)
                checksum += position * file_id
            except ValueError:
                # This should not happen if disk contains only digit strings for files or '.'
                print(f""Error: Invalid block character '{block_char}' at position {position} for checksum calculation."", file=sys.stderr)
    return checksum

def solve_part_one(disk_map_str: str) -> int:
    """"""Solve part one of the puzzle.
    Expands the disk map, defragments it, and calculates the checksum.

    Args:
        disk_map_str: The dense disk map string from input.

    Returns:
        The final checksum.
    """"""
    if not disk_map_str:
        return 0

    initial_disk = expand_disk_map(disk_map_str)
    if DEBUG:
        print(f""Initial disk ({len(initial_disk)} blocks): {''.join(initial_disk)}"", file=sys.stderr)

    # defragment_disk modifies the list in-place. Pass a copy if initial_disk needs to be preserved elsewhere.
    # Here, initial_disk is modified directly.
    defragmented_disk = defragment_disk(initial_disk)
    if DEBUG:
        print(f""Final disk ({len(defragmented_disk)} blocks): {''.join(defragmented_disk)}"", file=sys.stderr)

    checksum = calculate_checksum(defragmented_disk)
    return checksum

def _run_tests():
    """"""Runs test cases against the implemented functions. Output to stderr.""""""
    print(""Running tests..."", file=sys.stderr)
    # Store original DEBUG state and ensure tests run with DEBUG off unless specified
    # Or, could set DEBUG = True here for verbose test output.
    # global DEBUG; original_debug_state = DEBUG; DEBUG = False

    # Test case 1: ""12345""
    disk_map_1 = ""12345""
    expected_expanded_1 = ['0', '.', '.', '1', '1', '1', '.', '.', '.', '.', '2', '2', '2', '2', '2']
    expanded_1 = expand_disk_map(disk_map_1)
    assert expanded_1 == expected_expanded_1, f""Test 1 expand failed. Expected: {''.join(expected_expanded_1)}, Got: {''.join(expanded_1)}""

defragmented_1 = defragment_disk(list(expanded_1))
    expected_defragmented_1 = ['0', '2', '2', '1', '1', '1', '2', '2', '2', '.', '.', '.', '.', '.', '.']
    assert defragmented_1 == expected_defragmented_1, f""Test 1 defrag failed. Expected: {''.join(expected_defragmented_1)}, Got: {''.join(defragmented_1)}""

    checksum_1 = calculate_checksum(defragmented_1)
    expected_checksum_1 = 60
    assert checksum_1 == expected_checksum_1, f""Test 1 checksum failed. Expected: {expected_checksum_1}, Got: {checksum_1}""
    print(""Test Case 1 ('12345') Passed. Checksum: 60"", file=sys.stderr)

    # Test case 2: ""2333133121414131402""
    disk_map_2 = ""2333133121414131402""
    checksum_2 = solve_part_one(disk_map_2)
    expected_checksum_2 = 1928
    assert checksum_2 == expected_checksum_2, f""Test 2 checksum failed. Expected: {expected_checksum_2}, Got: {checksum_2}""
    print(""Test Case 2 ('2333133121414131402') Passed. Checksum: 1928"", file=sys.stderr)

    # Test case 3: ""012""
    disk_map_3 = ""012""
    expected_expanded_3 = ['.', '1', '1']
    expanded_3 = expand_disk_map(disk_map_3)
    assert expanded_3 == expected_expanded_3, f""Test 3 expand failed. Expected: {''.join(expected_expanded_3)}, Got: {''.join(expanded_3)}""

    defragmented_3 = defragment_disk(list(expanded_3))
    expected_defragmented_3 = ['1', '1', '.']
    assert defragmented_3 == expected_defragmented_3, f""Test 3 defrag failed. Expected: {''.join(expected_defragmented_3)}, Got: {''.join(defragmented_3)}""

    checksum_3 = calculate_checksum(defragmented_3)
    expected_checksum_3 = 1
    assert checksum_3 == expected_checksum_3, f""Test 3 checksum failed. Expected: {expected_checksum_3}, Got: {checksum_3}""
    print(""Test Case 3 ('012') Passed. Checksum: 1"", file=sys.stderr)

    # Test case 4: ""90909""
    disk_map_4 = ""90909""
    expanded_4 = expand_disk_map(disk_map_4)
    expected_expanded_4 = [str(fid) for fid in [0,1,2] for _ in range(9)]
    assert expanded_4 == expected_expanded_4, f""Test 4 expand failed. Expected: {''.join(expected_expanded_4)}, Got: {''.join(expanded_4)}""

    defragmented_4 = defragment_disk(list(expanded_4))
    assert defragmented_4 == expected_expanded_4, f""Test 4 defrag failed. Expected: {''.join(expected_expanded_4)}, Got: {''.join(defragmented_4)}""

    checksum_4 = calculate_checksum(defragmented_4)
    expected_checksum_4 = 513
    assert checksum_4 == expected_checksum_4, f""Test 4 checksum failed. Expected: {expected_checksum_4}, Got: {checksum_4}""
    print(""Test Case 4 ('90909') Passed. Checksum: 513"", file=sys.stderr)

    # Test case 5: Empty input string
    checksum_5 = solve_part_one("""")
    expected_checksum_5 = 0
    assert checksum_5 == expected_checksum_5, f""Test 5 (empty input) failed. Expected: {expected_checksum_5}, Got: {checksum_5}""
    print(""Test Case 5 (empty input) Passed. Checksum: 0"", file=sys.stderr)

    # Test case 6: Only free space ""05""
    disk_map_6 = ""05""
    expanded_6 = expand_disk_map(disk_map_6)
    expected_expanded_6 = ['.', '.', '.', '.', '.']
    assert expanded_6 == expected_expanded_6, f""Test 6 expand failed. Expected: {''.join(expected_expanded_6)}, Got: {''.join(expanded_6)}""

    defragmented_6 = defragment_disk(list(expanded_6))
    assert defragmented_6 == expected_expanded_6, f""Test 6 defrag failed.""
    checksum_6 = calculate_checksum(defragmented_6)
    expected_checksum_6 = 0
    assert checksum_6 == expected_checksum_6, f""Test 6 checksum failed. Expected: {expected_checksum_6}, Got: {checksum_6}""
    print(""Test Case 6 ('05') Passed. Checksum: 0"", file=sys.stderr)

    print(""All tests passed successfully."", file=sys.stderr)
    # DEBUG = original_debug_state # Restore DEBUG state

def main():
    """"""Main entry point of the script.""""""
    # Run tests first (output to stderr). Comment out if not desired.
    _run_tests()

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    parsed_data = parse_input(input_file)
    part_one_solution = solve_part_one(parsed_data)

    # Print the solution for Part One to STDOUT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
9,system,gemini-2.5-pro-preview-05-06,False,3230.9174048900604,
10,single-model,gemini-2.5-pro-preview-05-06,True,194.74351453781128,"import sys
from typing import List, Tuple, Set, Dict

# Type aliases
Grid = List[List[int]]
Coord = Tuple[int, int]
# Memoization cache: (r,c) -> set of reachable 9-coords
Memo = Dict[Coord, Set[Coord]]

# Constants for neighbor exploration
DELTAS = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, Left, Down, Up

# --- Test Data (for --test flag) ---
# Larger example from problem description
LARGER_EXAMPLE_GRID_STR = [
    ""89010123"", ""78121874"", ""87430965"", ""96549874"",
    ""45678903"", ""32019012"", ""01329801"", ""10456732""
]
LARGER_EXAMPLE_SOLUTION = 36

# Simpler example from problem description
SIMPLE_EXAMPLE_GRID_STR = [""0123"", ""1234"", ""8765"", ""9876""]
SIMPLE_EXAMPLE_SOLUTION = 1
# --- End Test Data ---

def parse_input(input_file: str) -> Grid:
    """"""Parse the puzzle input from file into a 2D grid of integers.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of lists representing the grid of heights.
    """"""
    grid: Grid = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        grid.append([int(char) for char in line])
                    except ValueError:
                        print(f""Error: Line '{line}' in file '{input_file}' contains non-integer characters."", file=sys.stderr)
                        sys.exit(1)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

    if not grid:
        # This can happen if the file is empty or only contains empty lines.
        # solve_puzzle handles this, so it's more of a warning.
        print(f""Warning: Input file '{input_file}' is empty or contains no valid grid data."", file=sys.stderr)

    # Validate that all rows have the same length
    if grid:
        first_row_len = len(grid[0])
        for i, row in enumerate(grid):
            if len(row) != first_row_len:
                print(f""Error: Input file '{input_file}' has inconsistent row lengths. Row {i} has length {len(row)}, expected {first_row_len}."", file=sys.stderr)
                sys.exit(1)

    return grid

def _find_reachable_nines_recursive(
    grid: Grid,
    r: int, c: int,
    memo: Memo,
    R: int, C: int
) -> Set[Coord]:
    """"""
    Recursive helper function to find all 9-height cells reachable from (r, c)
    following hiking trail rules (height increases by 1 at each step). Uses memoization.

    Args:
        grid: The topographic map.
        r, c: Current cell coordinates.
        memo: Memoization table.
        R, C: Dimensions of the grid (rows, columns).

    Returns:
        A set of coordinates (tuples) of 9-height cells reachable from (r,c).
    """"""
    if (r, c) in memo:
        return memo[(r, c)]

    current_height = grid[r][c]

    # Base case: If current cell has height 9, it's a valid trail endpoint.
    if current_height == 9:
        return {(r, c)}

    reachable_nines_from_here: Set[Coord] = set()

    for dr, dc in DELTAS:
        nr, nc = r + dr, c + dc

        if 0 <= nr < R and 0 <= nc < C:  # Check bounds
            neighbor_height = grid[nr][nc]
            # Valid step in a hiking trail if neighbor's height is current_height + 1
            if neighbor_height == current_height + 1:
                nines_from_neighbor = _find_reachable_nines_recursive(
                    grid, nr, nc, memo, R, C
                )
                reachable_nines_from_here.update(nines_from_neighbor)

    memo[(r, c)] = reachable_nines_from_here
    return reachable_nines_from_here

def solve_puzzle(grid: Grid) -> int:
    """"""
    Calculates the sum of scores of all trailheads on the topographic map.

    Args:
        grid: The processed topographic map.

    Returns:
        The sum of scores of all trailheads.
    """"""
    if not grid or not grid[0]: # Handle empty or malformed grid (e.g. [[],[]])
        return 0

    R = len(grid)
    C = len(grid[0])

    # Memoization table, shared across all trailhead calculations.
    # Stores: (r,c) -> set of 9-height Coords reachable from (r,c).
    memo: Memo = {}
    total_score_sum = 0

    # Iterate over all cells to find trailheads (height 0)
    for r_idx in range(R):
        for c_idx in range(C):
            if grid[r_idx][c_idx] == 0:  # Found a trailhead
                # Calculate score for this trailhead.
                # The score is the number of unique 9-height cells reachable.
                # The recursive function needs grid dimensions to avoid repeated len() calls.
                reachable_nines = _find_reachable_nines_recursive(
                    grid, r_idx, c_idx, memo, R, C
                )
                total_score_sum += len(reachable_nines)

    return total_score_sum

def _run_tests():
    """"""Runs test cases and prints results to stderr.""""""
    print(""Running example tests..."", file=sys.stderr)

    # Test with Simple Example
    simple_grid = [[int(c) for c in row] for row in SIMPLE_EXAMPLE_GRID_STR]
    solution_simple = solve_puzzle(simple_grid)
    assert solution_simple == SIMPLE_EXAMPLE_SOLUTION, \
        f""Simple Example failed: expected {SIMPLE_EXAMPLE_SOLUTION}, got {solution_simple}""
    print(f""Simple Example Passed (Expected: {SIMPLE_EXAMPLE_SOLUTION}, Got: {solution_simple})"", file=sys.stderr)

    # Test with Larger Example
    larger_grid = [[int(c) for c in row] for row in LARGER_EXAMPLE_GRID_STR]
    solution_larger = solve_puzzle(larger_grid)
    assert solution_larger == LARGER_EXAMPLE_SOLUTION, \
        f""Larger Example failed: expected {LARGER_EXAMPLE_SOLUTION}, got {solution_larger}""
    print(f""Larger Example Passed (Expected: {LARGER_EXAMPLE_SOLUTION}, Got: {solution_larger})"", file=sys.stderr)

    # Test with empty grid
    empty_grid: Grid = []
    solution_empty = solve_puzzle(empty_grid)
    assert solution_empty == 0, f""Empty grid test failed: expected 0, got {solution_empty}""
    print(f""Empty Grid Test Passed (Expected: 0, Got: {solution_empty})"", file=sys.stderr)

    # Test with grid containing no trailheads (no zeros)
    # Add 1 to all heights of simple_grid, ensuring no zeros (heights become 1-10)
    # (though problem implies heights 0-9, this tests no-trailhead case)
    no_trailheads_grid = [[min(9, int(c) + 1) for c in row] for row in SIMPLE_EXAMPLE_GRID_STR]
    solution_no_trailheads = solve_puzzle(no_trailheads_grid)
    assert solution_no_trailheads == 0, \
        f""No trailheads test failed: expected 0, got {solution_no_trailheads}""
    print(f""No Trailheads Test Passed (Expected: 0, Got: {solution_no_trailheads})"", file=sys.stderr)

    # Test with grid containing no nines
    no_nines_grid_str = [""012"", ""123"", ""234""]
    no_nines_grid = [[int(c) for c in row] for row in no_nines_grid_str]
    solution_no_nines = solve_puzzle(no_nines_grid)
    assert solution_no_nines == 0, \
        f""No nines test failed: expected 0, got {solution_no_nines}""
    print(f""No Nines Test Passed (Expected: 0, Got: {solution_no_nines})"", file=sys.stderr)

    print(""All example tests passed."", file=sys.stderr)


# The docstring for the file itself.
# Placed here as it's easier to manage when the whole code is a string.
FILE_DOCSTRING = """"""
Advent of Code YYYY Day 10: Hoof It
Solution implementation.

This solution finds all trailheads (cells with height 0) in a topographic map.
For each trailhead, it calculates a score, which is the number of unique
9-height cells reachable via 'hiking trails'. A hiking trail is a path
where each step increases height by exactly 1, moving only up, down, left, or right.
The total sum of scores from all trailheads is the final answer.

The core logic uses a recursive Depth First Search (DFS) approach with memoization
to find reachable 9s. The memoization table stores, for each cell (r,c),
the set of 9-height cells reachable from it. This prevents redundant computations,
as the set of reachable 9s from a cell (r,c) is independent of how (r,c) was reached,
as long as it's part of a valid trail. This memoization is shared across calculations
for all trailheads.

Usage: python3 solution.py [input_file]
   or: python3 solution.py --test (to run included test cases)
""""""

def main():
    """"""Main entry point for the script.""""""
    # Assign the file docstring to the module's __doc__ attribute
    # This is a bit of a hack to make it available if imported, common in single-file scripts.
    globals()['__doc__'] = FILE_DOCSTRING

    if len(sys.argv) > 1 and sys.argv[1] == ""--test"":
        _run_tests()
        return

    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""   or: python3 solution.py --test"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Python's default recursion limit is usually 1000 or 3000.
    # Max path length is 10 (0->9), so depth of recursion is at most 10.
    # Default limit is sufficient.
    # For very large grids if this became an issue for some Python versions:
    # current_limit = sys.getrecursionlimit()
    # if current_limit < MAX_PATH_LENGTH * SOME_SAFETY_FACTOR:
    #    sys.setrecursionlimit(NEW_LIMIT)

    grid = parse_input(input_file)
    solution = solve_puzzle(grid)

    # ONLY PRINT THE RESULT, NO OTHER TEXT to STDOUT for the puzzle solution
    print(solution)

if __name__ == ""__main__"":
    main()
"
10,system,gemini-2.5-pro-preview-05-06,True,981.0244319438934,"""""""
Advent of Code 2023 Day 10: Hoof It (Hypothetical problem name)
Solution implementation based on the provided plan.

This script finds trailheads (height 0) on a topographic map
and calculates a score for each based on reachable height-9 cells
via paths of strictly increasing heights (0->1->...->9).
The sum of these scores is the final output.

Usage: python3 solution.py [input_file]
       python3 solution.py --test (to run example test cases)
""""""
import sys
from typing import List, Tuple, Set, Dict

# Constants for neighbor iteration
DELTAS: List[Tuple[int, int]] = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, Left, Down, Up

def parse_input_from_file(input_file: str) -> Tuple[List[List[int]], int, int]:
    """"""Parse the puzzle input from file into a grid and its dimensions.""""""
    grid: List[List[int]] = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line:
                    # Assuming empty lines are not part of the grid definition
                    # or occur only at the end of the file.
                    # For solid grids, this might not be strictly necessary.
                    continue
                grid.append([int(char) for char in line])
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError:
        print(f""Error: Input file '{input_file}' contains non-integer characters."", file=sys.stderr)
        sys.exit(1)

    if not grid:
        num_rows = 0
        num_cols = 0
    else:
        num_rows = len(grid)
        num_cols = len(grid[0])
        # Validate that the grid is rectangular
        for r_idx in range(num_rows):
            if len(grid[r_idx]) != num_cols:
                print(f""Error: Grid is not rectangular in file '{input_file}'. Row {r_idx} has length {len(grid[r_idx])} instead of {num_cols}."", file=sys.stderr)
                sys.exit(1)

    return grid, num_rows, num_cols

def parse_input_from_string(input_str: str) -> Tuple[List[List[int]], int, int]:
    """"""Parses a multi-line string into a grid and its dimensions (for testing).""""""
    grid: List[List[int]] = []
    # Normalize input: strip leading/trailing whitespace, then split by lines
    stripped_input = input_str.strip()
    if not stripped_input: # Handles fully empty or whitespace-only strings
        lines = []
    else:
        lines = stripped_input.split('\n')

    for line_idx, line_content in enumerate(lines):
        # Individual lines should not be empty if the overall string was not empty after strip.
        # However, good to be safe or handle if format allows internal blank lines (unlikely for AoC grids).
        line = line_content.strip() # Not strictly needed if split from stripped_input
        if not line:
            # This case implies an empty line within the grid structure, which is unusual for AoC.
            # For robustness, one might error here or decide how to handle (e.g., skip or treat as error).
            # Assuming valid grid structure from problem, this path might not be hit often.
            print(f""Warning: Empty line detected within test string grid at line index {line_idx}. Skipping."", file=sys.stderr)
            continue
        try:
            grid.append([int(char) for char in line])
        except ValueError:
            print(f""Error: Test input string contains non-integer characters: '{line}'"", file=sys.stderr)
            return [], 0, 0 # Return empty grid on error for tests

    if not grid:
        num_rows = 0
        num_cols = 0
    else:
        num_rows = len(grid)
        num_cols = len(grid[0])
        for r_idx in range(num_rows):
            if len(grid[r_idx]) != num_cols:
                print(f""Error: Test string grid is not rectangular. Row {r_idx} has length {len(grid[r_idx])} instead of {num_cols}."", file=sys.stderr)
                return [], 0, 0 # Return empty grid on error for tests

    return grid, num_rows, num_cols

def find_trailheads(grid: List[List[int]], num_rows: int, num_cols: int) -> List[Tuple[int, int]]:
    """"""Identifies all trailhead locations (cells with height 0).""""""
    trailheads_list: List[Tuple[int, int]] = []
    if num_rows == 0 or num_cols == 0: # Empty grid check
        return trailheads_list

    for r in range(num_rows):
        for c in range(num_cols):
            if grid[r][c] == 0:
                trailheads_list.append((r, c))
    return trailheads_list

def find_reachable_nines_dfs(
    current_r: int,
    current_c: int,
    current_h: int,
    grid: List[List[int]],
    num_rows: int,
    num_cols: int,
    memo: Dict[Tuple[int, int, int], Set[Tuple[int, int]]]
) -> Set[Tuple[int, int]]:
    """"""
    Recursive DFS to find unique height-9 cells reachable from (current_r, current_c)
    assuming the path has arrived at this cell with current_h (i.e. grid[current_r][current_c] == current_h).
    Uses memoization to store results of subproblems.
    """"""
    state = (current_r, current_c, current_h)
    if state in memo:
        return memo[state]

    # Base case: If current_h is 9, this means grid[current_r][current_c] is 9.
    # This cell is a reachable height-9 cell.
    if current_h == 9:
        result = {(current_r, current_c)}
        memo[state] = result
        return result

    all_nines_from_here: Set[Tuple[int, int]] = set()

    for dr, dc in DELTAS:
        next_r, next_c = current_r + dr, current_c + dc

        # Validity checks for the neighbor:
        # 1. Within grid boundaries.
        # 2. Neighbor's height is exactly current_h + 1.
        if 0 <= next_r < num_rows and \
           0 <= next_c < num_cols and \
           grid[next_r][next_c] == current_h + 1:

            # Recursively find nines from this valid neighbor.
            # The neighbor is at height current_h + 1.
            nines_from_neighbor = find_reachable_nines_dfs(
                next_r, next_c, current_h + 1,
                grid, num_rows, num_cols, memo
            )
            all_nines_from_here.update(nines_from_neighbor)

    memo[state] = all_nines_from_here
    return all_nines_from_here

def solve_puzzle(grid_data: Tuple[List[List[int]], int, int]) -> int:
    """"""
    Solves the puzzle: calculates the sum of scores of all trailheads.
    A trailhead's score is the number of unique height-9 cells reachable from it.
    """"""
    grid, num_rows, num_cols = grid_data

    if num_rows == 0 or num_cols == 0: # Handle empty grid early
        return 0

    trailheads = find_trailheads(grid, num_rows, num_cols)
    if not trailheads:
        return 0 # No trailheads, so total score is 0

    total_sum_of_scores = 0
    # Memoization table shared across all DFS calls for this grid instance.
    # Key: (row, col, height_at_cell), Value: set of (r9, c9) of reachable 9s.
    memo: Dict[Tuple[int, int, int], Set[Tuple[int, int]]] = {}

    for trailhead_r, trailhead_c in trailheads:
        # Height at a trailhead is by definition 0.
        # grid[trailhead_r][trailhead_c] must be 0.
        reachable_nines_set = find_reachable_nines_dfs(
            trailhead_r, trailhead_c, 0,  # Start DFS from trailhead (height 0)
            grid, num_rows, num_cols, memo
        )
        total_sum_of_scores += len(reachable_nines_set)

    return total_sum_of_scores

# Test cases definition
EXAMPLE_CASES = [
    {
        ""name"": ""Example 1 from problem"",
        ""input_str"": ""0123\n1234\n8765\n9876"",
        ""expected_output"": 1
    },
    {
        ""name"": ""Example 2 (Larger) from problem"",
        ""input_str"": ""89010123\n78121874\n87430965\n96549874\n45678903\n32019012\n01329801\n10456732"",
        ""expected_output"": 36
    },
    {
        ""name"": ""Empty Grid (test)"",
        ""input_str"": """",
        ""expected_output"": 0
    },
    {
        ""name"": ""No Trailheads (test)"",
        ""input_str"": ""123\n456\n789"",
        ""expected_output"": 0
    },
    {
        ""name"": ""No Height 9 Cells (test)"",
        ""input_str"": ""012\n123\n234"",
        ""expected_output"": 0
    },
    {
        ""name"": ""Trailhead, Height 9 exists, but No Valid Path (test)"",
        ""input_str"": ""09\n18\n27"",
        ""expected_output"": 0
    },
    {
        ""name"": ""Multiple Trailheads, No Valid Full Paths (test)"",
        ""input_str"": ""0129\n0129"",
        ""expected_output"": 0
    },
    {
        ""name"": ""Single Vertical Path (test)"",
        ""input_str"": ""0\n1\n2\n3\n4\n5\n6\n7\n8\n9"",
        ""expected_output"": 1
    },
    {
        ""name"": ""Trailhead cannot start path (no h=1 neighbor)"",
        ""input_str"": ""09\n99"",
        ""expected_output"": 0
    },
    {
        ""name"": ""Two trailheads, one path each to different 9s"",
        ""input_str"": ""0123456789\n0123456789"",
        ""expected_output"": 2
    }
]

def run_tests():
    """"""Runs all defined test cases and prints results to stderr.""""""
    print(""Running test cases..."", file=sys.stderr)
    passed_all = True
    for i, case in enumerate(EXAMPLE_CASES):
        parsed_data = parse_input_from_string(case[""input_str""])
        grid_test, r_test, c_test = parsed_data

        # Check if parsing itself indicated an issue (e.g., returned empty grid for non-empty invalid input)
        if not (r_test and c_test) and case[""input_str""].strip() and case[""name""] != ""Empty Grid (test)"":
            print(f""Test {i+1} '{case['name']}': FAILED (parsing error or invalid test string resulted in empty grid)."", file=sys.stderr)
            passed_all = False
            continue

        actual_output = solve_puzzle(parsed_data)
        if actual_output == case[""expected_output""]:
            print(f""Test {i+1} '{case['name']}': PASSED"", file=sys.stderr)
        else:
            print(f""Test {i+1} '{case['name']}': FAILED. Expected {case['expected_output']}, Got {actual_output}"", file=sys.stderr)
            passed_all = False

    print(""-"" * 30, file=sys.stderr)
    if passed_all:
        print(""All tests passed successfully."", file=sys.stderr)
    else:
        print(""Some tests FAILED."", file=sys.stderr)
    print(""-"" * 30, file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""   or: python3 solution.py --test (to run example test cases)"", file=sys.stderr)
        sys.exit(1)

    if sys.argv[1] == '--test':
        run_tests()
        return

    input_file = sys.argv[1]
    parsed_data = parse_input_from_file(input_file)

    # If parse_input_from_file exits on error, we won't reach here.
    # If it returns an empty grid (e.g. file was empty), solve_puzzle handles it.
    solution = solve_puzzle(parsed_data)

    # ONLY PRINT THE FINAL RESULT to stdout for AoC submission platform
    print(solution)

if __name__ == ""__main__"":
    main()
"
11,single-model,gemini-2.5-pro-preview-05-06,True,155.95032954216003,"import sys
from typing import List

# Number of blinks for the simulation, as per the problem statement.
NUM_BLINKS = 25

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers representing stones.

    Args:
        input_file: Path to the input file. The file should contain a single
                    line of space-separated integers.

    Returns:
        A list of integers representing the initial state of the stones.
        Returns an empty list if the input line is empty.

    Raises:
        ValueError: If the input contains non-integer values.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()

    if not line:
        return []

    try:
        # Handles multiple spaces between numbers correctly due to split() behavior
        stones = [int(x) for x in line.split()]
    except ValueError as e:
        # Catch error if int(x) fails for non-numeric strings
        raise ValueError(f""Invalid number format in input file: {e}"")
    return stones

def apply_rules(stone: int) -> List[int]:
    """"""Applies the transformation rules to a single stone.

    Args:
        stone: The numerical value of the stone.

    Returns:
        A list containing the stone(s) that result from the transformation.
        This list will have one or two elements.
    """"""
    if stone == 0:
        # Rule 1: 0 becomes 1
        return [1]

    s = str(stone)
    if len(s) % 2 == 0:
        # Rule 2: Even number of digits, split
        mid = len(s) // 2
        left_str = s[:mid]
        right_str = s[mid:]

        # int() handles leading zeros correctly for parsing, e.g., int(""00"") is 0.
        # This aligns with ""1000 would become stones 10 and 0"" (from ""10"" and ""00"").
        left_num = int(left_str)
        right_num = int(right_str)
        return [left_num, right_num]
    else:
        # Rule 3: Odd number of digits (and not 0), multiply by 2024
        return [stone * 2024]

def simulate_one_blink(current_stones: List[int]) -> List[int]:
    """"""Simulates one blink, transforming all stones simultaneously.

    Args:
        current_stones: A list of integers representing the stones before the blink.

    Returns:
        A new list of integers representing the stones after the blink.
    """"""
    next_stones: List[int] = []
    # Renamed loop variable to 'stone_val' to avoid potential conflict
    # with a module named 'stone' if it were to be imported.
    for stone_val in current_stones:
        transformed_stones_list = apply_rules(stone_val)
        next_stones.extend(transformed_stones_list)
    return next_stones

def solve_puzzle(initial_stones: List[int]) -> int:
    """"""Solves the puzzle by simulating blinks and returning the final stone count.

    Args:
        initial_stones: The initial list of stones.

    Returns:
        The total number of stones after NUM_BLINKS blinks.
    """"""
    # Work with a copy of the initial list
    stones_current_state = list(initial_stones)

    for i in range(NUM_BLINKS):
        stones_current_state = simulate_one_blink(stones_current_state)
        # Debug print for progress, can be useful for large inputs/blinks
        # print(f""After blink {i + 1}/{NUM_BLINKS}: {len(stones_current_state)} stones"", file=sys.stderr)

    return len(stones_current_state)

def run_tests():
    """"""Runs built-in tests against examples from the problem description.""""""
    print(""Running internal tests..."", file=sys.stderr)

    # Test apply_rules
    assert apply_rules(0) == [1], ""Test apply_rules(0) failed""
    assert apply_rules(1) == [1 * 2024], ""Test apply_rules(1) failed""
    assert apply_rules(10) == [1, 0], ""Test apply_rules(10) failed""
    assert apply_rules(99) == [9, 9], ""Test apply_rules(99) failed""
    assert apply_rules(999) == [999 * 2024], ""Test apply_rules(999) failed""
    assert apply_rules(1000) == [10, 0], ""Test apply_rules(1000) failed""
    print(""apply_rules tests passed."", file=sys.stderr)

    # Test Example 1: 0 1 10 99 999
    # After 1 blink: 1 2024 1 0 9 9 2021976 (7 stones)
    initial_stones1 = [0, 1, 10, 99, 999]
    stones_ex1_b1 = simulate_one_blink(initial_stones1)
    expected_ex1_b1 = [1, 2024, 1, 0, 9, 9, 2021976]
    assert stones_ex1_b1 == expected_ex1_b1, f""Test Example 1 (1 blink) state failed. Expected {expected_ex1_b1}, Got {stones_ex1_b1}""
    assert len(stones_ex1_b1) == 7, ""Test Example 1 (1 blink) count failed.""
    print(""Example 1 (1 blink) test passed."", file=sys.stderr)

    # Test Longer Example: 125 17
    initial_stones2 = [125, 17]

    s = list(initial_stones2) # Current state for multi-blink test

    # Blink 1
    s = simulate_one_blink(s)
    expected_b1 = [253000, 1, 7]
    assert s == expected_b1, f""Longer Example, Blink 1 state failed. Expected {expected_b1}, Got {s}""
    assert len(s) == 3

    # Blink 2
    s = simulate_one_blink(s)
    expected_b2 = [253, 0, 2024, 14168]
    assert s == expected_b2, f""Longer Example, Blink 2 state failed. Expected {expected_b2}, Got {s}""
    assert len(s) == 4

    # Blink 3
    s = simulate_one_blink(s)
    expected_b3 = [512072, 1, 20, 24, 28676032]
    assert s == expected_b3, f""Longer Example, Blink 3 state failed. Expected {expected_b3}, Got {s}""
    assert len(s) == 5

    # Blink 4
    s = simulate_one_blink(s)
    expected_b4 = [512, 72, 2024, 2, 0, 2, 4, 2867, 6032]
    assert s == expected_b4, f""Longer Example, Blink 4 state failed. Expected {expected_b4}, Got {s}""
    assert len(s) == 9
    print(""Longer Example (intermediate blinks 1-4) tests passed."", file=sys.stderr)

    # Test count for 6 blinks (from initial_stones2)
    s_b6 = list(initial_stones2) # Reset
    for _ in range(6):
        s_b6 = simulate_one_blink(s_b6)
    assert len(s_b6) == 22, ""Longer Example (6 blinks) count failed.""
    print(""Longer Example (6 blinks) test passed."", file=sys.stderr)

    # Test count for 25 blinks (from initial_stones2) if NUM_BLINKS matches problem's target
    if NUM_BLINKS == 25:
        count_25_blinks = solve_puzzle(initial_stones2) # Uses global NUM_BLINKS
        assert count_25_blinks == 55312, f""Longer Example (25 blinks) count failed. Expected 55312, Got {count_25_blinks}""
        print(""Longer Example (25 blinks) test passed."", file=sys.stderr)

    print(""All internal tests passed!"", file=sys.stderr)

def main():
    """"""Main execution entry point.""""""

    # To run tests, uncomment the following line.
    # run_tests()
    # For AoC, typically tests are run during development and commented out for submission.

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1) # Indicate an error

    input_file = sys.argv[1]

    try:
        initial_stones = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e: # Catch errors from int() conversion
        print(f""Error: Could not parse input from '{input_file}'. {e}"", file=sys.stderr)
        sys.exit(1)

    final_stone_count = solve_puzzle(initial_stones)

    # Print the final result to STDOUT as required. No other text on STDOUT.
    print(final_stone_count)

if __name__ == ""__main__"":
    main()
"
11,system,gemini-2.5-pro-preview-05-06,True,749.9635002613068,"""""""
Advent of Code Year Undefined Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Simulates the transformation of a list of stones over 25 blinks.
Each stone transforms based on prioritized rules:
1. 0 -> 1
2. Even digit count: splits into two halves (e.g., 1234 -> 12, 34)
3. Odd digit count (and not 0): value * 2024

The goal is the total count of stones after 25 blinks.

Usage: python3 solution.py [input_file]
       python3 solution.py --test (to run example tests)
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
    if not line:
        return [] # Handle empty input file
    return [int(s) for s in line.split()]

def transform_stone(stone_value: int) -> List[int]:
    """"""Transform a single stone based on the prioritized rules.

    Args:
        stone_value: The numerical value of the stone.

    Returns:
        A list containing one or two integers, representing the stone(s)
        it transforms into.
    """"""
    # Rule 1: Zero Check
    if stone_value == 0:
        return [1]

    s = str(stone_value)
    num_digits = len(s)

    # Rule 2: Even Number of Digits Check
    if num_digits % 2 == 0:
        mid_point = num_digits // 2
        left_part_str = s[:mid_point]
        right_part_str = s[mid_point:]

        # int() handles leading zeros correctly, e.g., int(""00"") -> 0
        left_stone_value = int(left_part_str)
        right_stone_value = int(right_part_str)
        return [left_stone_value, right_stone_value]
    else:
        # Rule 3: Fallback (Odd Digits, Non-Zero)
        return [stone_value * 2024]

def _simulate_blinks(initial_stones: List[int], num_blinks: int) -> List[int]:
    """"""Simulate the stone transformations for a given number of blinks.

    Args:
        initial_stones: The list of stones at the start.
        num_blinks: The number of blinks to simulate.

    Returns:
        The list of stones after all blinks.
    """"""
    current_stones = list(initial_stones) # Work on a copy

    for blink_num in range(num_blinks):
        next_stones: List[int] = []
        if not current_stones: # Handle case where all stones might disappear (not per rules, but good practice)
            break
        for stone in current_stones:
            transformed_result = transform_stone(stone)
            next_stones.extend(transformed_result)
        current_stones = next_stones
        # Optional: print debug info for specific blinks for longer examples
        # if (blink_num + 1) <= 6 :
        #     print(f""After {blink_num + 1} blink(s): {' '.join(map(str, current_stones))}"", file=sys.stderr)
        #     print(f""Count: {len(current_stones)}"", file=sys.stderr)

    return current_stones

def solve_part_one(parsed_data: List[int]) -> int:
    """"""Solve part one of the puzzle: count stones after 25 blinks.

    Args:
        parsed_data: Processed input data (initial list of stones).

    Returns:
        Solution for part one (total number of stones after 25 blinks).
    """"""
    if not parsed_data:
        return 0 # No initial stones means 0 stones at the end.

    final_stones = _simulate_blinks(parsed_data, 25)
    return len(final_stones)

def _run_tests():
    """"""Runs test cases based on examples from the problem description.""""""
    print(""Running example tests..."", file=sys.stderr)

    # Test case 1: 0 1 10 99 999 after 1 blink
    # From problem: ""So, after blinking once, your five stones would become an arrangement of seven stones engraved with the numbers 1 2024 1 0 9 9 2021976.""
    initial_stones_1 = [0, 1, 10, 99, 999]
    expected_list_1_blink = [1, 2024, 1, 0, 9, 9, 2021976]
    simulated_list_1_blink = _simulate_blinks(initial_stones_1, 1)
    assert simulated_list_1_blink == expected_list_1_blink, \
        f""Test 1 (1 blink) list failed.\nExpected: {expected_list_1_blink}\nGot:      {simulated_list_1_blink}""
    assert len(simulated_list_1_blink) == 7, \
        f""Test 1 (1 blink count) failed. Expected 7, got {len(simulated_list_1_blink)}""
    print(""Test 1 ('0 1 10 99 999', 1 blink) passed."", file=sys.stderr)

    # Test case 2: 125 17, tracing intermediate and final for 6 blinks
    initial_stones_2 = [125, 17]

    # After 1 blink: 253000 1 7 (Count: 3)
    simulated_list_b1 = _simulate_blinks(initial_stones_2, 1)
    expected_list_b1 = [253000, 1, 7]
    assert simulated_list_b1 == expected_list_b1, f""Test 2 (1 blink) for '125 17' failed. Expected {expected_list_b1}, got {simulated_list_b1}""

    # After 2 blinks: 253 0 2024 14168 (Count: 4)
    simulated_list_b2 = _simulate_blinks(initial_stones_2, 2)
    expected_list_b2 = [253, 0, 2024, 14168]
    assert simulated_list_b2 == expected_list_b2, f""Test 2 (2 blinks) for '125 17' failed. Expected {expected_list_b2}, got {simulated_list_b2}""

    # After 5 blinks (from problem statement): 1036288 7 2 20 24 4048 1 4048 8096 28 67 60 32 (Count: 13)
    simulated_list_b5 = _simulate_blinks(initial_stones_2, 5)
    expected_list_b5_str = ""1036288 7 2 20 24 4048 1 4048 8096 28 67 60 32"".split()
    expected_list_b5 = [int(s) for s in expected_list_b5_str]
    assert simulated_list_b5 == expected_list_b5, f""Test 2 (5 blinks) for '125 17' failed. Expected {expected_list_b5}, got {simulated_list_b5}""

    # After 6 blinks (from problem statement): Count 22
    # List: 2097446912 14168 4048 2 0 2 4 40 48 2024 40 48 80 96 2 8 6 7 6 0 3 2
    expected_list_6_blinks_str = ""2097446912 14168 4048 2 0 2 4 40 48 2024 40 48 80 96 2 8 6 7 6 0 3 2"".split()
    expected_list_6_blinks = [int(s) for s in expected_list_6_blinks_str]
    simulated_list_6_blinks = _simulate_blinks(initial_stones_2, 6)
    assert simulated_list_6_blinks == expected_list_6_blinks, \
        f""Test 2 (6 blinks) list failed.\nExpected: {expected_list_6_blinks}\nGot:      {simulated_list_6_blinks}""
    assert len(simulated_list_6_blinks) == 22, \
        f""Test 2 (6 blinks count) failed. Expected 22, got {len(simulated_list_6_blinks)}""
    print(""Test 2 ('125 17', intermediate and 6 blinks) passed."", file=sys.stderr)

    # Test case 3: 125 17 after 25 blinks (puzzle target for this example)
    # Problem states: ""After blinking 25 times, you would have 55312 stones!""
    expected_count_25_blinks = 55312
    simulated_list_25_blinks = _simulate_blinks(initial_stones_2, 25)
    assert len(simulated_list_25_blinks) == expected_count_25_blinks, \
        f""Test 3 (25 blinks count) failed. Expected {expected_count_25_blinks}, got {len(simulated_list_25_blinks)}""
    print(""Test 3 ('125 17', 25 blinks) passed."", file=sys.stderr)

    print(""All specific example tests passed!"", file=sys.stderr)

def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file | --test]"")
        sys.exit(1)

    if sys.argv[1] == '--test':
        _run_tests()
        sys.exit(0)

    input_file = sys.argv[1]

    # Parse input
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError:
        print(f""Error: Input file '{input_file}' contains non-integer values or is improperly formatted."", file=sys.stderr)
        sys.exit(1)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)

    # ONLY PRINT THE RESULT to STDOUT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
12,single-model,gemini-2.5-pro-preview-05-06,True,141.75640225410461,"""""""
Advent of Code Day 12: Garden Groups
Solution for calculating the total price of fencing for garden regions.

The problem involves a grid map of plant plots. Each character represents a plant type.
Adjacent (horizontal/vertical) plots of the same type form a region.
For each region:
- Area: Number of plots in the region.
- Perimeter: Number of plot sides in the region that don't touch another plot of the
             same type within that region. This includes sides on the map boundary
             or adjacent to plots of a different type.
- Price: Area * Perimeter.
The goal is to find the sum of prices for all regions.

The approach uses a Breadth-First Search (BFS) to identify connected regions.
1. Iterate through each cell (plot) of the grid.
2. If a cell hasn't been visited yet, it's part of a new region.
   a. Perform a BFS starting from this cell to find all plots belonging to this region
      (i.e., connected plots of the same type). Mark these plots as visited globally.
   b. The number of plots found is the region's area.
   c. Calculate the region's perimeter: For each plot in the region, count how many of
      its four sides are adjacent to either the grid boundary or a plot of a
      different type. Sum these counts.
   d. Calculate the price (area * perimeter) for this region.
3. Sum the prices of all regions to get the total price.
A global 'visited' set tracks plots already assigned to a region to ensure each
plot is processed only once.

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple, Set, Deque
import sys
from collections import deque

# Type alias for the grid
Grid = List[str]

# Directions for BFS and perimeter calculation (Right, Left, Down, Up)
DIRECTIONS = [(0, 1), (0, -1), (1, 0), (-1, 0)]

def parse_input(input_file: str) -> Grid:
    """"""Parse the puzzle input from file into a grid of characters (List[str]).

    Args:
        input_file: Path to the input file.

    Returns:
        A list of strings representing the grid. Filters out empty lines.
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f]
    # Filter out any completely empty lines that might be in the input
    return [line for line in lines if line]

def solve_part_one(grid: Grid) -> int:
    """"""Solve the puzzle: calculate total fencing price for all regions.

    Args:
        grid: The garden map as a list of strings.

    Returns:
        The total price for fencing all regions.
    """"""
    if not grid or not grid[0]:
        # Handle empty grid (no rows or no columns in the first row)
        return 0

    rows = len(grid)
    cols = len(grid[0])

    # Set to keep track of visited plots (r, c) across all regions
    visited: Set[Tuple[int, int]] = set()
    total_price = 0

    for r_start in range(rows):
        for c_start in range(cols):
            if (r_start, c_start) in visited:
                # This plot has already been processed as part of another region
                continue

            # New unvisited plot: start of a new region
            plant_type = grid[r_start][c_start]

            # plots_in_current_region will store all (r, c) tuples for this region
            plots_in_current_region: Set[Tuple[int, int]] = set()

            # BFS queue for exploring the current region
            q: Deque[Tuple[int, int]] = deque()

            # Initialize BFS with the starting plot
            q.append((r_start, c_start))
            visited.add((r_start, c_start)) # Mark globally visited
            plots_in_current_region.add((r_start, c_start)) # Add to current region's plot set

            # Perform BFS to find all plots in this connected region
            while q:
                curr_r, curr_c = q.popleft()

                for dr, dc in DIRECTIONS:
                    nr, nc = curr_r + dr, curr_c + dc

                    # Check if neighbor is within bounds
                    if 0 <= nr < rows and 0 <= nc < cols:
                        # Check if neighbor is of the same plant type and not yet visited globally
                        if grid[nr][nc] == plant_type and (nr, nc) not in visited:
                            visited.add((nr, nc)) # Mark globally visited
                            plots_in_current_region.add((nr, nc)) # Add to current region's plot set
                            q.append((nr, nc)) # Add to BFS queue

            # Area is the number of plots in this region
            area = len(plots_in_current_region)

            # This check is mostly a safeguard; area should be at least 1 if we started a BFS.
            if area == 0:
                continue

            # Calculate perimeter for this region
            perimeter = 0
            for r_plot, c_plot in plots_in_current_region:
                for dr, dc in DIRECTIONS:
                    nr_adj, nc_adj = r_plot + dr, c_plot + dc

                    # A side contributes to perimeter if:
                    # 1. The adjacent cell is out of bounds.
                    # 2. The adjacent cell is in bounds but contains a different plant type.
                    if not (0 <= nr_adj < rows and 0 <= nc_adj < cols):
                        perimeter += 1  # Adjacent cell is out of bounds
                    elif grid[nr_adj][nc_adj] != plant_type:
                        perimeter += 1  # Adjacent cell has a different plant type
                    # Otherwise, it's an internal edge (same plant type), does not add to perimeter.

            # Price for this region
            price = area * perimeter
            total_price += price

            # Optional: Debug print for each region's properties
            # print(f""Region type '{plant_type}' @({r_start},{c_start}): Area={area}, Perimeter={perimeter}, Price={price}"", file=sys.stderr)

    return total_price

def run_tests():
    """"""Runs test cases based on examples from the problem description and custom cases.""""""
    print(""Running example tests..."", file=sys.stderr)

    test_cases = [
        {
            ""name"": ""Example 1"",
            ""grid_str"": """"""AAAA
BBCD
BBCC
EEEC"""""",
            ""expected"": 140
        },
        {
            ""name"": ""Example 2"",
            ""grid_str"": """"""OOOOO
OXOXO
OOOOO
OXOXO
OOOOO"""""",
            ""expected"": 772
        },
        {
            ""name"": ""Example 3 (Larger)"",
            ""grid_str"": """"""RRRRIICCFF
RRRRIICCCF
VVRRRCCFFF
VVRCCCJFFF
VVVVCJJCFE
VVIVCCJJEE
VVIIICJJEE
MIIIIIJJEE
MIIISIJEEE
MMMISSJEEE"""""",
            ""expected"": 1930
        },
        {
            ""name"": ""Single Plot"",
            ""grid_str"": ""A"",
            ""expected"": 4 # Area 1, Perimeter 4
        },
        {
            ""name"": ""Empty Grid String"",
            ""grid_str"": """",
            ""expected"": 0
        },
        {
            ""name"": ""Grid with only newline"",
            ""grid_str"": ""\n"",
            ""expected"": 0
        },
        {
            ""name"": ""Two separate regions of same type plus a third type"",
            # Regions:
            # 1. Left 'A's: (0,0), (1,0). Area 2. P: (3+3)=6. Price 12.
            # 2. Right 'A's: (0,2), (1,2). Area 2. P: (3+3)=6. Price 12.
            # 3. Middle '.'s: (0,1), (1,1). Area 2. P: (3+3)=6. Price 12.
            # Total = 12 + 12 + 12 = 36.
            ""grid_str"": """"""A.A
A.A"""""",
            ""expected"": 36
        }
    ]

    for i, tc in enumerate(test_cases):
        grid_lines_raw = tc[""grid_str""].split('\n')
        # Mimic parse_input's filtering of empty lines for consistent test setup
        grid_lines = [line for line in grid_lines_raw if line]

        actual = solve_part_one(grid_lines)
        assert actual == tc[""expected""], \
            f""Test '{tc['name']}' Failed: Expected {tc['expected']}, Got {actual}. Grid:\n{tc['grid_str']}""
        print(f""Test '{tc['name']}' Passed."", file=sys.stderr)

    print(""All example tests passed."", file=sys.stderr)


def main():
    """"""Main execution function.""""""
    # Run tests before processing file input.
    run_tests()
    print(""-"" * 20, file=sys.stderr) # Separator

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        print(""No input file provided. Finished after running tests."", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input from the specified file
    print(f""Processing input file: {input_file}"", file=sys.stderr)
    grid = parse_input(input_file)

    # Solve the puzzle
    solution = solve_part_one(grid)

    # Print the final solution to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
12,system,gemini-2.5-pro-preview-05-06,True,1023.8719718456268,"""""""Advent of Code YYYY Day DD: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
   or: python3 solution.py --test (to run internal test cases)
""""""
import sys

# Ensure this is Python 3 for type hints and other features
if sys.version_info[0] < 3:
    sys.exit(""This script requires Python 3."")

# Standard library imports
from collections import deque
from typing import List, Tuple, Set

# Global constants for directions
DELTAS = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Right, Left, Down, Up

# --- Parsing Function ---
def parse_input(input_file: str) -> Tuple[List[List[str]], int, int]:
    """"""Parse the puzzle input from file into a grid and its dimensions.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - grid: List[List[str]] (the parsed grid).
            - num_rows: int (number of rows in the grid).
            - num_cols: int (number of columns in the grid).
    """"""
    try:
        with open(input_file, 'r') as f:
            # Filter out empty lines that might result from trailing newlines
            lines = [line.strip() for line in f]
            lines = [line for line in lines if line] # Ensure only non-empty lines form the grid
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)

    if not lines:
        return [], 0, 0

    grid = [list(line) for line in lines]
    num_rows = len(grid)
    num_cols = len(grid[0]) if num_rows > 0 else 0

    # Validate grid consistency (all rows same length)
    if num_rows > 0:
        for i, row in enumerate(grid):
            if len(row) != num_cols:
                print(f""Error: Inconsistent row length. Row {i} (0-indexed) has length {len(row)}, expected {num_cols}."", file=sys.stderr)
                sys.exit(1)

    return grid, num_rows, num_cols

# --- Core Logic: Region Processing ---
def _process_single_region(
    start_row: int,
    start_col: int,
    plant_type: str,
    grid: List[List[str]],
    visited: List[List[bool]],
    num_rows: int,
    num_cols: int
) -> int:
    """"""
    Processes a single connected region of a specific plant type.

    Performs a BFS starting from (start_row, start_col) to find all
    connected cells of the given plant_type. Calculates area and perimeter
    for this region, then computes and returns its price.
    Updates the `visited` grid for all cells in this region.

    Args:
        start_row: Row index of the starting cell for BFS.
        start_col: Column index of the starting cell for BFS.
        plant_type: The character representing the plant type of this region.
        grid: The full garden map.
        visited: A 2D boolean grid tracking visited cells (mutated by this function).
        num_rows: Total number of rows in the grid.
        num_cols: Total number of columns in the grid.

    Returns:
        The calculated price (area * perimeter) for the identified region.
    """"""
    q = deque()
    current_region_cells: Set[Tuple[int, int]] = set()

    q.append((start_row, start_col))
    visited[start_row][start_col] = True
    current_region_cells.add((start_row, start_col))

    # BFS to find all cells in the region
    while q:
        curr_r, curr_c = q.popleft()

        for dr, dc in DELTAS:
            next_r, next_c = curr_r + dr, curr_c + dc

            if 0 <= next_r < num_rows and 0 <= next_c < num_cols:  # Check bounds
                if grid[next_r][next_c] == plant_type and not visited[next_r][next_c]:
                    visited[next_r][next_c] = True
                    current_region_cells.add((next_r, next_c))
                    q.append((next_r, next_c))

    # Calculate Area
    area = len(current_region_cells)
    # This case should ideally not be hit if called from main loop correctly
    if area == 0:
        return 0

    # Calculate Perimeter
    perimeter = 0
    for r_cell, c_cell in current_region_cells:
        for dr, dc in DELTAS:
            adj_r, adj_c = r_cell + dr, c_cell + dc

            if not (0 <= adj_r < num_rows and 0 <= adj_c < num_cols):  # Neighbor is outside grid
                perimeter += 1
            else:  # Neighbor is within grid
                if grid[adj_r][adj_c] != plant_type:  # Neighbor is different type or part of a different region
                    perimeter += 1

    region_price = area * perimeter
    return region_price

# --- Main Solver Function ---
def solve_garden_groups(parsed_data: Tuple[List[List[str]], int, int]) -> int:
    """"""
    Calculates the total price of fencing for all regions on the map.

    Args:
        parsed_data: A tuple containing the grid, number of rows, and number of columns.

    Returns:
        The total price for all regions.
    """"""
    grid, num_rows, num_cols = parsed_data

    if num_rows == 0 or num_cols == 0:
        return 0  # Empty grid has no regions, price is 0

    visited = [[False for _ in range(num_cols)] for _ in range(num_rows)]
    total_overall_price = 0

    for r in range(num_rows):
        for c in range(num_cols):
            if not visited[r][c]:
                current_plant_type = grid[r][c]
                region_price = _process_single_region(
                    r, c, current_plant_type, grid, visited, num_rows, num_cols
                )
                total_overall_price += region_price

    return total_overall_price

# --- Test Utilities ---
def _parse_string_input(input_str: str) -> Tuple[List[List[str]], int, int]:
    """"""Helper to parse a multi-line string input into grid format for testing.""""""
    lines = [line.strip() for line in input_str.splitlines()]
    lines = [line for line in lines if line] # Filter out empty lines
    if not lines:
        return [], 0, 0

    grid = [list(line) for line in lines]
    num_rows = len(grid)
    num_cols = len(grid[0]) if num_rows > 0 else 0

    if num_rows > 0:
        for i, row in enumerate(grid):
            if len(row) != num_cols:
                raise ValueError(f""Test string error: Inconsistent row length. Row {i} has {len(row)}, expected {num_cols}."")
    return grid, num_rows, num_cols

def run_tests():
    """"""Runs predefined test cases and prints results to stderr.""""""
    print(""Running test cases..."", file=sys.stderr)

    example_test_cases = [
        (
            ""AAAA\nBBCD\nBBCC\nEEEC"",
            140,
            ""Example 1 from problem""
        ),
        (
            ""OOOOO\nOXOXO\nOOOOO\nOXOXO\nOOOOO"",
            772,
            ""Example 2 (with holes) from problem""
        ),
        (
            ""RRRRIICCFF\nRRRRIICCCF\nVVRRRCCFFF\nVVRCCCJFFF\nVVVVCJJCFE\nVVIVCCJJEE\nVVIIICJJEE\nMIIIIIJJEE\nMIIISIJEEE\nMMMISSJEEE"",
            1930,
            ""Larger Example from problem""
        ),
        (
            """",
            0,
            ""Custom: Empty Input""
        ),
        (
            ""A"",
            4,
            ""Custom: Single Cell 'A'""
        ),
        (
            ""ZZ\nZZ"",
            32,
            ""Custom: All Same Type 2x2 'Z'""
        ),
        (
            ""AB\nCD"",
            16,
            ""Custom: All Different Types 2x2""
        ),
        (
            "".X.\nXXX\n.X."",
            76, # X region: A=5, P=12, Price=60. Each '.' is A=1, P=4, Price=4. Total 60 + 4*4 = 76.
            ""Custom: Cross Shape Region with surrounding '.'""
        )
    ]

    passed_all = True
    for i, (input_str, expected_output, testname) in enumerate(example_test_cases):
        print(f""--- Test Case {i+1}: {testname} ---"", file=sys.stderr)
        try:
            parsed_test_data = _parse_string_input(input_str)
            actual_output = solve_garden_groups(parsed_test_data)

            if actual_output == expected_output:
                print(f""PASS: Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
            else:
                print(f""FAIL: Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
                print(f""Input:\n{input_str}"", file=sys.stderr)
                passed_all = False
        except Exception as e:
            print(f""ERROR during test case \""{testname}\"": {e}"", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            passed_all = False
        print(""-"" * 20, file=sys.stderr)

    if passed_all:
        print(""All example test cases PASSED."", file=sys.stderr)
    else:
        print(""Some example test cases FAILED."", file=sys.stderr)

# --- Main Execution Block ---
def main():
    """"""
    Main entry point for the script. Parses command line arguments,
    reads input, solves the puzzle, and prints the result.
    Allows running internal test cases via '--test' flag.
    """"""
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        print(f""   or: python3 {sys.argv[0]} --test"", file=sys.stderr)
        sys.exit(1)

    if sys.argv[1] == ""--test"":
        run_tests()
        sys.exit(0)

    input_file = sys.argv[1]
    parsed_data = parse_input(input_file)

    solution = solve_garden_groups(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT to STDOUT
    print(solution)

if __name__ == ""__main__"":
    # Set the module docstring dynamically for when script is run directly.
    # Using placeholders as Year/Day are not specified in the problem context for this task.
    __doc__ = __doc__ # Keep the existing docstring at the top of the file.
    main()
"
13,single-model,gemini-2.5-pro-preview-05-06,True,189.88760924339294,"""""""
Advent of Code [Year] Day [Day]: Claw Contraption
Solution for the Claw Contraption puzzle.

This program calculates the minimum total tokens required to win all
winnable prizes from a series of claw machines. Each machine's prize
can be won by a combination of presses of Button A (cost 3, moves (ax, ay))
and Button B (cost 1, moves (bx, by)). Presses are limited to 100 for
each button.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run example tests)
""""""
import sys
import re
from typing import List, Tuple, Optional

# Constants for the game mechanics
COST_A = 3
COST_B = 1
MAX_PRESSES = 100  # Maximum number of presses for each button

# Type alias for machine parameters
# (ax, ay, bx, by, Px, Py)
MachineData = Tuple[int, int, int, int, int, int]

# Pre-compiled regular expressions for parsing
RE_BUTTON_A = re.compile(r""Button A: X\+([0-9]+), Y\+([0-9]+)"")
RE_BUTTON_B = re.compile(r""Button B: X\+([0-9]+), Y\+([0-9]+)"")
RE_PRIZE = re.compile(r""Prize: X=([0-9]+), Y=([0-9]+)"")

def parse_input(input_file: str) -> List[MachineData]:
    """"""Parse the puzzle input from file into a list of machine configurations.

    Args:
        input_file: Path to the input file. Each machine is described by
                    three lines, and machines are separated by a blank line.

    Returns:
        A list of MachineData tuples, where each tuple contains
        (ax, ay, bx, by, Px, Py) for a machine.
    """"""
    machines: List[MachineData] = []
    try:
        with open(input_file, 'r') as f:
            content = f.read().strip()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

    if not content:
        return [] # Handle empty input file gracefully

    # Machines are described in blocks separated by double newlines
    machine_blocks = content.split('\n\n')

    for i, block in enumerate(machine_blocks):
        lines = block.strip().split('\n')
        if len(lines) != 3:
            print(f""Warning: Malformed block #{i+1}. Expected 3 lines, got {len(lines)}. Block content:\n{block}"", file=sys.stderr)
            continue # Skip this malformed block

        match_a = RE_BUTTON_A.fullmatch(lines[0])
        match_b = RE_BUTTON_B.fullmatch(lines[1])
        match_prize = RE_PRIZE.fullmatch(lines[2])

        if not (match_a and match_b and match_prize):
            # Print specific warnings for which line failed to match
            if not match_a: print(f""Warning: Regex mismatch for Button A in block #{i+1}. Line: '{lines[0]}'."", file=sys.stderr)
            if not match_b: print(f""Warning: Regex mismatch for Button B in block #{i+1}. Line: '{lines[1]}'."", file=sys.stderr)
            if not match_prize: print(f""Warning: Regex mismatch for Prize in block #{i+1}. Line: '{lines[2]}'."", file=sys.stderr)
            continue # Skip this block due to regex mismatch

        try:
            # Extract values using matched groups. Regex ensures these are digits.
            ax = int(match_a.group(1))
            ay = int(match_a.group(2))
            bx = int(match_b.group(1))
            by = int(match_b.group(2))
            Px = int(match_prize.group(1))
            Py = int(match_prize.group(2))

            machines.append((ax, ay, bx, by, Px, Py))
        except ValueError:
            # This case should ideally not be reached if regex [0-9]+ is used,
            # as int() conversion of a string of digits should not fail.
            # Included for robustness against unexpected regex group content.
            print(f""Warning: Invalid number format in parsed data in block #{i+1}. Block content:\n{block}"", file=sys.stderr)
            continue # Skip this block if number conversion fails

    return machines

def solve_single_machine(machine_data: MachineData) -> Optional[int]:
    """"""Calculates the minimum cost to win the prize for a single machine.

    The number of presses for button A (na) and button B (nb) are each
    limited by MAX_PRESSES (0 to 100 inclusive).

    Args:
        machine_data: A tuple (ax, ay, bx, by, Px, Py) representing the
                      machine's parameters and prize location.

    Returns:
        The minimum cost to win the prize if possible within the press limits,
        otherwise None.
    """"""
    ax, ay, bx, by, Px, Py = machine_data

    min_total_cost = float('inf')
    solution_found = False

    # Iterate na from 0 to MAX_PRESSES (inclusive)
    for na in range(MAX_PRESSES + 1):
        current_x_a = na * ax  # X-coordinate contribution from Button A presses
        current_y_a = na * ay  # Y-coordinate contribution from Button A presses

        # Optimization: Pruning for the 'na' loop.
        # If 'na' presses alone make Px or Py unreachable, given non-negative bx, by.
        # (Assumes ax, ay, bx, by >= 0, implied by ""X+"", ""Y+"" and parsed by [0-9]+ regex)

        # Check if Px can be achieved with current_x_a and some 'nb' presses
        if bx == 0:  # Button B has no effect on X-coordinate
            if current_x_a != Px: # Px must be achieved by Button A presses alone
                continue # This 'na' cannot lead to Px, try next 'na'
        elif current_x_a > Px: # Button B increases X (bx > 0)
            # If 'na' presses alone already overshoot Px, and Button B only adds to X,
            # then Px cannot be reached with this 'na'.
            continue # This 'na' cannot lead to Px, try next 'na'

        # Check if Py can be achieved with current_y_a and some 'nb' presses
        if by == 0:  # Button B has no effect on Y-coordinate
            if current_y_a != Py: # Py must be achieved by Button A presses alone
                continue # This 'na' cannot lead to Py, try next 'na'
        elif current_y_a > Py: # Button B increases Y (by > 0)
            continue # This 'na' cannot lead to Py, try next 'na'

        # Iterate nb from 0 to MAX_PRESSES (inclusive)
        for nb in range(MAX_PRESSES + 1):
            current_x = current_x_a + nb * bx # Total X-coordinate
            current_y = current_y_a + nb * by # Total Y-coordinate

            # Optimization: Pruning for the 'nb' loop.
            # If current (na, nb) combination overshoots Px (and bx > 0) or Py (and by > 0),
            # then further increases in 'nb' for this 'na' won't help.
            if (bx > 0 and current_x > Px) or \
               (by > 0 and current_y > Py):
                break # This 'nb' and subsequent 'nb's for this 'na' won't work.

            if current_x == Px and current_y == Py:
                # Found a combination (na, nb) that reaches the prize
                cost = COST_A * na + COST_B * nb
                if cost < min_total_cost:
                    min_total_cost = cost
                solution_found = True
                # Optimization: Since COST_B >= 0 (it's 1), for a fixed 'na',
                # the first 'nb' that satisfies the condition will give the minimum cost
                # for that 'na'. So, we can break from the 'nb' loop.
                break # Found cheapest 'nb' for this 'na', move to next 'na'.

    if solution_found:
        return min_total_cost
    else:
        return None # No solution found within MAX_PRESSES limits

def solve_part_one(machines: List[MachineData]) -> int:
    """"""Solve part one of the puzzle. Sums minimum costs for all winnable machines.

    Args:
        machines: A list of MachineData tuples.

    Returns:
        The total minimum tokens required to win all possible prizes.
    """"""
    total_tokens_spent = 0

    for i, machine_data in enumerate(machines):
        # For debugging, can uncomment:
        # print(f""Debug: Processing machine {i+1}/{len(machines)}"", file=sys.stderr)
        cost = solve_single_machine(machine_data)
        if cost is not None:
            # print(f""Debug: Machine {i+1} winnable with cost {cost}"", file=sys.stderr)
            total_tokens_spent += cost
        # else:
            # print(f""Debug: Machine {i+1} not winnable within {MAX_PRESSES} presses."", file=sys.stderr)

    return total_tokens_spent

def run_example_tests():
    """"""Runs tests based on the problem's examples.""""""
    print(""Running example tests..."", file=sys.stderr)

    # Example Machine 1: Winnable
    # Button A: X+94, Y+34; Button B: X+22, Y+67; Prize: X=8400, Y=5400
    # Expected solution: na=80, nb=40. Cost: 80*3 + 40*1 = 240 + 40 = 280
    machine1_data = (94, 34, 22, 67, 8400, 5400)
    cost1 = solve_single_machine(machine1_data)
    assert cost1 == 280, f""Example Machine 1: Expected 280, got {cost1}""

    # Example Machine 2: Not winnable within limits
    # Button A: X+26, Y+66; Button B: X+67, Y+21; Prize: X=12748, Y=12176
    machine2_data = (26, 66, 67, 21, 12748, 12176)
    cost2 = solve_single_machine(machine2_data)
    assert cost2 is None, f""Example Machine 2: Expected None, got {cost2}""

    # Example Machine 3: Winnable
    # Button A: X+17, Y+86; Button B: X+84, Y+37; Prize: X=7870, Y=6450
    # Expected solution: na=38, nb=86. Cost: 38*3 + 86*1 = 114 + 86 = 200
    machine3_data = (17, 86, 84, 37, 7870, 6450)
    cost3 = solve_single_machine(machine3_data)
    assert cost3 == 200, f""Example Machine 3: Expected 200, got {cost3}""

    # Example Machine 4: Not winnable within limits
    # Button A: X+69, Y+23; Button B: X+27, Y+71; Prize: X=18641, Y=10279
    machine4_data = (69, 23, 27, 71, 18641, 10279)
    cost4 = solve_single_machine(machine4_data)
    assert cost4 is None, f""Example Machine 4: Expected None, got {cost4}""

    # Overall test with all example machines
    # Total cost = cost for Machine 1 + cost for Machine 3 = 280 + 200 = 480
    example_machines_list = [machine1_data, machine2_data, machine3_data, machine4_data]
    total_example_cost = solve_part_one(example_machines_list)
    expected_total_cost = 280 + 200
    assert total_example_cost == expected_total_cost, \
        f""Example Total Cost: Expected {expected_total_cost}, got {total_example_cost}""

    print(""All example tests passed."", file=sys.stderr)


def main():
    """"""Main entry point for the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        print(""Alternatively, use 'python3 solution.py test' to run example tests."", file=sys.stderr)
        sys.exit(1)

    input_arg = sys.argv[1]

    if input_arg == ""test"":
        run_example_tests()
        return

    # Parse the input file to get machine data
    parsed_data = parse_input(input_arg)

    # If parsed_data is empty (e.g., due to empty file or all blocks being malformed),
    # solve_part_one will correctly return 0. Warnings for malformed blocks
    # would have been printed to stderr by parse_input.

    # Calculate the solution for Part One
    part_one_solution = solve_part_one(parsed_data)

    # Print the final solution to STDOUT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
13,system,gemini-2.5-pro-preview-05-06,True,847.9790570735931,"import sys
import re
from typing import List, Dict

""""""
Advent of Code [Year] Day [Day]: Claw Contraption
Solution implementation based on the provided plan.

This script calculates the minimum total token cost to win prizes from multiple
claw machines. For each machine, it determines if the prize is winnable by
pressing buttons A (cost 3) and B (cost 1) up to 100 times each. If winnable,
it finds the combination of presses with the minimum cost. The sum of these
minimum costs for all winnable machines is the final result.

The approach involves:
1. Parsing machine parameters (button effects, prize location) from the input file.
2. For each machine, performing an exhaustive search (nA, nB from 0 to 100)
   to find if the prize target (X, Y) can be reached.
3. If reachable, calculating the cost (3*nA + 1*nB) and finding the minimum
   such cost for that machine.
4. Summing the minimum costs for all winnable machines.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run example test cases)
""""""

# Type alias for machine data for clarity
MachineData = Dict[str, int]

# Constants from the problem statement
COST_A = 3
COST_B = 1
MAX_PRESSES = 100 # 0 to 100 inclusive, so range(MAX_PRESSES + 1)

def parse_input(input_file: str) -> List[MachineData]:
    """"""Parse the puzzle input from file into a list of machine configurations.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of dictionaries, where each dictionary represents a machine's parameters.
        Returns an empty list if the file is empty or no valid machines are found.
    """"""
    machines: List[MachineData] = []
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

    content = content.strip()
    if not content:
        return []

    # Split content into blocks; blocks are separated by one or more blank lines.
    machine_blocks_raw = content.split('\n\n')

    for i, block_str_raw in enumerate(machine_blocks_raw):
        block_str = block_str_raw.strip()
        if not block_str: # Skip if block was just whitespace (e.g. multiple blank lines)
            continue

        block_lines = [line.strip() for line in block_str.split('\n')]

        if len(block_lines) != 3:
            print(f""Warning: Machine block {i+1} (1-indexed) is malformed. Expected 3 lines, got {len(block_lines)}. Skipping."", file=sys.stderr)
            continue

        try:
            # Basic format validation for each line prefix
            if not block_lines[0].startswith(""Button A: X+"") or "", Y+"" not in block_lines[0]:
                 raise ValueError(f""Line 1 (Button A) has unexpected format: '{block_lines[0]}'"")
            if not block_lines[1].startswith(""Button B: X+"") or "", Y+"" not in block_lines[1]:
                 raise ValueError(f""Line 2 (Button B) has unexpected format: '{block_lines[1]}'"")
            if not block_lines[2].startswith(""Prize: X="") or "", Y="" not in block_lines[2]:
                 raise ValueError(f""Line 3 (Prize) has unexpected format: '{block_lines[2]}'"")

            # Extract numbers using regex
            nums_A_str = re.findall(r'\d+', block_lines[0])
            nums_B_str = re.findall(r'\d+', block_lines[1])
            nums_Prize_str = re.findall(r'\d+', block_lines[2])

            if len(nums_A_str) != 2:
                raise ValueError(f""Line 1 (Button A) malformed. Expected 2 numbers, got {len(nums_A_str)} in '{block_lines[0]}'"")
            if len(nums_B_str) != 2:
                raise ValueError(f""Line 2 (Button B) malformed. Expected 2 numbers, got {len(nums_B_str)} in '{block_lines[1]}'"")
            if len(nums_Prize_str) != 2:
                raise ValueError(f""Line 3 (Prize) malformed. Expected 2 numbers, got {len(nums_Prize_str)} in '{block_lines[2]}'"")

            machine_data: MachineData = {
                'dX_A': int(nums_A_str[0]), 'dY_A': int(nums_A_str[1]),
                'dX_B': int(nums_B_str[0]), 'dY_B': int(nums_B_str[1]),
                'TargetX': int(nums_Prize_str[0]), 'TargetY': int(nums_Prize_str[1])
            }

            # Validate that all parsed numerical values are positive integers as per problem constraints
            for key, value in machine_data.items():
                if value <= 0: # ""positive integers"" typically means > 0
                    raise ValueError(f""Parsed value for {key} is {value}, but must be a positive integer."")

            machines.append(machine_data)

        except ValueError as e:
            print(f""Warning: Error parsing machine block {i+1} (1-indexed): {e}. Skipping."", file=sys.stderr)
            continue

    return machines

def solve_single_machine(machine_params: MachineData) -> float:
    """"""Calculates the minimum cost to win the prize for a single claw machine.

    Args:
        machine_params: A dictionary containing the parameters for the machine
                        (dX_A, dY_A, dX_B, dY_B, TargetX, TargetY).

    Returns:
        The minimum cost (as a float) to win the prize for this machine.
        Returns float('inf') if the prize is unwinnable under the given constraints.
    """"""
    dX_A = machine_params['dX_A']
    dY_A = machine_params['dY_A']
    dX_B = machine_params['dX_B']
    dY_B = machine_params['dY_B']
    target_X = machine_params['TargetX']
    target_Y = machine_params['TargetY']

    min_cost_for_this_machine = float('inf')

    # Iterate nA from 0 to MAX_PRESSES (inclusive)
    for nA in range(MAX_PRESSES + 1):
        # Iterate nB from 0 to MAX_PRESSES (inclusive)
        for nB in range(MAX_PRESSES + 1):
            current_X = nA * dX_A + nB * dX_B
            current_Y = nA * dY_A + nB * dY_B

            if current_X == target_X and current_Y == target_Y:
                current_cost = (nA * COST_A) + (nB * COST_B)
                if current_cost < min_cost_for_this_machine:
                    min_cost_for_this_machine = float(current_cost)

    return min_cost_for_this_machine

def solve_part_one(machines: List[MachineData]) -> int:
    """"""Solve part one of the puzzle.
    Calculates the total minimum token cost to win prizes from all winnable machines.

    Args:
        machines: A list of parsed machine data.

    Returns:
        The total minimum cost as an integer.
    """"""
    total_min_cost_sum = 0
    for machine_data in machines:
        cost = solve_single_machine(machine_data)
        if cost != float('inf'):
            total_min_cost_sum += int(cost) # Cost will be an integer if not inf

    return total_min_cost_sum

# Test cases from the problem description or provided JSON
TEST_CASES_PROVIDED = [
    (
      ""Button A: X+94, Y+34\nButton B: X+22, Y+67\nPrize: X=8400, Y=5400\n\n""
      ""Button A: X+26, Y+66\nButton B: X+67, Y+21\nPrize: X=12748, Y=12176\n\n""
      ""Button A: X+17, Y+86\nButton B: X+84, Y+37\nPrize: X=7870, Y=6450\n\n""
      ""Button A: X+69, Y+23\nButton B: X+27, Y+71\nPrize: X=18641, Y=10279"",
      ""480""
    )
]

def run_tests():
    """"""Runs all defined test cases using input strings and expected output strings.""""""
    print(""Running example tests..."", file=sys.stderr)
    all_passed = True
    for i, (test_input_str, expected_output_str) in enumerate(TEST_CASES_PROVIDED):
        print(f""--- Test Case {i+1} ---"", file=sys.stderr)
        # Use a temporary file to simulate file input for parse_input
        import tempfile
        import os

        # delete=False is necessary on Windows to allow re-opening by parse_input
        # It's good practice to ensure the file is explicitly closed before parse_input reads it.
        with tempfile.NamedTemporaryFile(mode=""w"", delete=False, encoding='utf-8', suffix="".txt"") as tmp_file:
            tmp_file.write(test_input_str)
            tmp_file_path = tmp_file.name

        try:
            parsed_data = parse_input(tmp_file_path)
            actual_output = solve_part_one(parsed_data)
            expected_output = int(expected_output_str)

            if actual_output == expected_output:
                print(f""Test Case {i+1} PASSED: Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
            else:
                print(f""Test Case {i+1} FAILED: Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
                all_passed = False
        except Exception as e:
            print(f""Test Case {i+1} ERRORED: {e}"", file=sys.stderr)
            all_passed = False
        finally:
            # Clean up the temporary file
            os.remove(tmp_file_path)
        print(""--------------------"", file=sys.stderr)

    if all_passed:
        print(""All example tests passed!"", file=sys.stderr)
    else:
        print(""Some example tests FAILED or ERRORED."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) == 2 and sys.argv[1].lower() == ""test"":
        run_tests()
        return

    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        print(f""   or: python3 {sys.argv[0]} test"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    parsed_data = parse_input(input_file)

    part_one_solution = solve_part_one(parsed_data)
    # ONLY print the final result to STDOUT, no other text.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
14,single-model,gemini-2.5-pro-preview-05-06,True,148.25468921661377,"""""""
Advent of Code [Year] Day 14: Restroom Redoubt
Solution implementation for Day 14: Restroom Redoubt.

The problem involves simulating robots moving on a 2D grid with wraparound.
Each robot has an initial position (px, py) and velocity (vx, vy).
Positions are updated each second: new_px = (old_px + vx) % grid_width, new_py = (old_py + vy) % grid_height.
After 100 seconds, we need to count how many robots are in each of the four quadrants of the grid.
Robots on the exact horizontal or vertical midlines are not counted in any quadrant.
The ""safety factor"" is the product of the counts of robots in these four quadrants.

The puzzle input defines the initial state of robots.
The grid dimensions for the main puzzle are 101x103.
An example is provided with a 11x7 grid.

The solution approach:
1. Parse the input to get a list of Robot objects, storing their p_x, p_y, v_x, v_y.
2. Simulate the movement for 100 seconds. In each second, update each robot's position
   using its velocity and the wraparound logic.
3. After 100 seconds, determine the final position of each robot.
4. Count robots in each quadrant (Top-Left, Top-Right, Bottom-Left, Bottom-Right),
   excluding those on midlines.
   - Midlines are at x = grid_width // 2 and y = grid_height // 2.
   - TL: x < mid_x, y < mid_y
   - TR: x > mid_x, y < mid_y
   - BL: x < mid_x, y > mid_y
   - BR: x > mid_x, y > mid_y
5. Calculate the safety factor by multiplying the four quadrant counts.

This implementation uses a Robot class to store state and provides methods
for parsing, simulation, and counting.

Usage: python3 solution.py [input_file]
       python3 solution.py --test (to run the example)
""""""
import sys
import re
from typing import List, Tuple

# Constants for the main puzzle
PUZZLE_GRID_WIDTH: int = 101
PUZZLE_GRID_HEIGHT: int = 103
PUZZLE_SIMULATION_DURATION: int = 100

# Regex for parsing input lines like ""p=x,y v=dx,dy""
# Example: p=0,4 v=3,-3
ROBOT_PATTERN = re.compile(r""p=(-?\d+),(-?\d+) v=(-?\d+),(-?\d+)"")

class Robot:
    """"""Represents a robot with position (px, py) and velocity (vx, vy).""""""
    px: int
    py: int
    vx: int
    vy: int

    def __init__(self, px: int, py: int, vx: int, vy: int):
        """"""Initializes a Robot instance.

        Args:
            px: Initial x-coordinate.
            py: Initial y-coordinate.
            vx: Velocity in x-direction.
            vy: Velocity in y-direction.
        """"""
        self.px = px
        self.py = py
        self.vx = vx
        self.vy = vy

    def __repr__(self) -> str:
        """"""Returns a string representation of the robot.""""""
        return f""Robot(p=({self.px},{self.py}), v=({self.vx},{self.vy}))""

    def step(self, grid_width: int, grid_height: int) -> None:
        """"""Updates the robot's position for one time step, with wraparound.

        Args:
            grid_width: The width of the grid.
            grid_height: The height of the grid.
        """"""
        self.px = (self.px + self.vx) % grid_width
        self.py = (self.py + self.vy) % grid_height


def parse_input_lines(lines: List[str]) -> List[Robot]:
    """"""Parses lines of robot data into a list of Robot objects.

    Args:
        lines: A list of strings, each describing a robot.

    Returns:
        A list of Robot objects.

    Raises:
        ValueError: If a line has an invalid format.
    """"""
    robots: List[Robot] = []
    for line_num, line_content in enumerate(lines):
        line = line_content.strip()
        if not line:  # Skip empty lines
            continue
        match = ROBOT_PATTERN.match(line)
        if match:
            px, py, vx, vy = map(int, match.groups())
            robots.append(Robot(px, py, vx, vy))
        else:
            raise ValueError(f""Invalid input line format on line {line_num + 1}: {line_content}"")
    return robots


def parse_input(input_file: str) -> List[Robot]:
    """"""Parses the puzzle input from a file into a list of Robot objects.

    Args:
        input_file: Path to the input file.

    Returns:
        A list of Robot objects representing the initial state of all robots.
    """"""
    with open(input_file, 'r') as f:
        lines = f.readlines()
    return parse_input_lines(lines)


def simulate_robots_for_duration(
    robots: List[Robot],
    duration: int,
    grid_width: int,
    grid_height: int
) -> None:
    """"""Simulates robot movements for a given duration. Modifies Robot objects in-place.

    Args:
        robots: A list of Robot objects to simulate.
        duration: The number of time steps to simulate.
        grid_width: The width of the simulation grid.
        grid_height: The height of the simulation grid.
    """"""
    for _ in range(duration):
        for robot in robots:
            robot.step(grid_width, grid_height)


def count_robots_in_quadrants(
    robots: List[Robot],
    grid_width: int,
    grid_height: int
) -> Tuple[int, int, int, int]:
    """"""Counts robots in each of the four quadrants, excluding midlines.

    The quadrants are: Top-Left (TL), Top-Right (TR), Bottom-Left (BL), Bottom-Right (BR).
    Robots on midlines (x = grid_width // 2 or y = grid_height // 2) are excluded.

    Args:
        robots: A list of Robot objects after simulation.
        grid_width: The width of the grid.
        grid_height: The height of the grid.

    Returns:
        A tuple containing counts for (TL, TR, BL, BR) quadrants.
    """"""
    mid_x = grid_width // 2
    mid_y = grid_height // 2

    tl_count, tr_count, bl_count, br_count = 0, 0, 0, 0

    for robot in robots:
        x, y = robot.px, robot.py

        if x == mid_x or y == mid_y:  # Robot is on a midline
            continue

        if x < mid_x:  # Left half
            if y < mid_y:  # Top half
                tl_count += 1
            else:  # Bottom half (y > mid_y)
                bl_count += 1
        else:  # Right half (x > mid_x)
            if y < mid_y:  # Top half
                tr_count += 1
            else:  # Bottom half (y > mid_y)
                br_count += 1

    return tl_count, tr_count, bl_count, br_count


def calculate_safety_factor(quadrant_counts: Tuple[int, int, int, int]) -> int:
    """"""Calculates the safety factor by multiplying quadrant counts.

    Args:
        quadrant_counts: A tuple (TL, TR, BL, BR) of robot counts in quadrants.

    Returns:
        The calculated safety factor.
    """"""
    tl, tr, bl, br = quadrant_counts
    return tl * tr * bl * br


def solve_part_one(robots: List[Robot]) -> int:
    """"""Solves Part One of the puzzle.

    This function simulates the robots using the puzzle-specific parameters
    (grid size 101x103, duration 100s) and calculates the safety factor.

    Args:
        robots: A list of Robot objects, parsed from the input.
                These objects will be modified during simulation.

    Returns:
        The safety factor for Part One.
    """"""
    simulate_robots_for_duration(
        robots,
        PUZZLE_SIMULATION_DURATION,
        PUZZLE_GRID_WIDTH,
        PUZZLE_GRID_HEIGHT
    )

    quadrant_counts = count_robots_in_quadrants(
        robots,
        PUZZLE_GRID_WIDTH,
        PUZZLE_GRID_HEIGHT
    )

    safety_factor = calculate_safety_factor(quadrant_counts)
    return safety_factor

# Example Data and Test function
EXAMPLE_INPUT_STR = """"""
p=0,4 v=3,-3
p=6,3 v=-1,-3
p=10,3 v=-1,2
p=2,0 v=2,-1
p=0,0 v=1,3
p=3,0 v=-2,-2
p=7,6 v=-1,-3
p=3,0 v=-1,-2
p=9,3 v=2,3
p=7,3 v=-1,2
p=2,4 v=2,-3
p=9,5 v=-3,-3
"""""".strip()

EXAMPLE_GRID_WIDTH = 11
EXAMPLE_GRID_HEIGHT = 7
EXAMPLE_SIMULATION_DURATION = 100
EXAMPLE_EXPECTED_SAFETY_FACTOR = 12

def _run_example_test() -> None:
    """"""Runs the provided example and verifies its output.

    This function is intended for development and testing.
    Output from this function is directed to stderr.
    """"""
    print(""Running example test..."", file=sys.stderr)

    example_robots_initial = parse_input_lines(EXAMPLE_INPUT_STR.split('\n'))

    example_robots_to_simulate = [Robot(r.px, r.py, r.vx, r.vy) for r in example_robots_initial]

    simulate_robots_for_duration(
        example_robots_to_simulate,
        EXAMPLE_SIMULATION_DURATION,
        EXAMPLE_GRID_WIDTH,
        EXAMPLE_GRID_HEIGHT
    )

    quadrant_counts = count_robots_in_quadrants(
        example_robots_to_simulate,
        EXAMPLE_GRID_WIDTH,
        EXAMPLE_GRID_HEIGHT
    )

    safety_factor = calculate_safety_factor(quadrant_counts)

    print(f""Example quadrant counts (TL, TR, BL, BR): {quadrant_counts}"", file=sys.stderr)
    print(f""Calculated example safety factor: {safety_factor}"", file=sys.stderr)

    assert safety_factor == EXAMPLE_EXPECTED_SAFETY_FACTOR, \
        f""Example failed: Expected {EXAMPLE_EXPECTED_SAFETY_FACTOR}, got {safety_factor}""
    print(""Example test passed."", file=sys.stderr)


def main() -> None:
    """"""Main entry point for the solution.

    Parses command-line arguments, reads input, solves the puzzle, and prints the result.
    Includes an option to run a self-test with example data via '--test'.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""You can also run 'python3 solution.py --test' to run the example."", file=sys.stderr)
        sys.exit(1)

    if sys.argv[1] == '--test':
        _run_example_test()
        return

    input_file = sys.argv[1]

    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    if not parsed_data:
        # Handle an input file that is empty or contains no valid robot data.
        # For this problem, 0 robots means 0 in all quadrants, safety factor is 0.
        print(0)
        return

    part_one_solution = solve_part_one(parsed_data)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
14,system,gemini-2.5-pro-preview-05-06,True,1032.1396048069,"""""""
Advent of Code [Year] Day 14: Restroom Redoubt
Solution implementation for simulating robot movement and calculating a safety factor.

Robots move on a 2D grid with wrap-around edges. Their final positions after
100 seconds are calculated directly. Robots on grid center lines are excluded.
The safety factor is the product of robot counts in four quadrants (TL, TR, BL, BR).

Usage: python3 solution.py [input_file]
""""""

import sys
import re
from typing import List, Tuple, NamedTuple, Dict, Optional

# --- Configuration Constants ---
SIMULATION_TIME: int = 100

# For the main puzzle
MAIN_GRID_WIDTH: int = 101
MAIN_GRID_HEIGHT: int = 103

# For the example test case
EXAMPLE_GRID_WIDTH: int = 11
EXAMPLE_GRID_HEIGHT: int = 7

# --- Data Structures ---
class Robot(NamedTuple):
    """"""
    Represents a robot with its initial position and velocity.
    """"""
    initial_x: int
    initial_y: int
    velocity_x: int
    velocity_y: int

    def calculate_final_position(self, time: int, grid_width: int, grid_height: int) -> Tuple[int, int]:
        """"""
        Calculates the robot's final (x, y) position after a given time,
        considering wrap-around grid behavior.

        Args:
            time: The duration of movement in seconds.
            grid_width: The width of the grid.
            grid_height: The height of the grid.

        Returns:
            A tuple (final_x, final_y) representing the robot's final coordinates.
        """"""
        final_x = (self.initial_x + self.velocity_x * time) % grid_width
        final_y = (self.initial_y + self.velocity_y * time) % grid_height
        return final_x, final_y

# --- Input Parsing ---
# Regex to parse lines like ""p=x,y v=vx,vy""
ROBOT_PATTERN: re.Pattern = re.compile(r""p=(-?\d+),(-?\d+) v=(-?\d+),(-?\d+)"")

def parse_input_lines(lines: List[str]) -> List[Robot]:
    """"""
    Parses a list of strings, each representing a robot's state, into Robot objects.

    Args:
        lines: A list of strings from the input.

    Returns:
        A list of Robot objects.
    """"""
    robots: List[Robot] = []
    for i, line in enumerate(lines):
        line = line.strip()
        if not line:
            continue  # Skip empty lines

        match = ROBOT_PATTERN.match(line)
        if match:
            try:
                ix, iy, vx, vy = map(int, match.groups())
                robots.append(Robot(initial_x=ix, initial_y=iy, velocity_x=vx, velocity_y=vy))
            except ValueError:
                print(f""Warning: Invalid number format in line {i+1}: {line}"", file=sys.stderr)
        else:
            print(f""Warning: Malformed line {i+1} ignored: {line}"", file=sys.stderr)
    return robots

def parse_input_file(input_file_path: str) -> List[Robot]:
    """"""
    Reads an input file and parses its content into a list of Robot objects.

    Args:
        input_file_path: Path to the input file.

    Returns:
        A list of Robot objects. Returns an empty list if file cannot be read
        or contains no valid robot data.
    """"""
    try:
        with open(input_file_path, 'r') as f:
            return parse_input_lines(f.readlines())
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file_path}"", file=sys.stderr)
        return []
    except Exception as e:
        print(f""Error reading or parsing file {input_file_path}: {e}"", file=sys.stderr)
        return []

# --- Core Logic: Calculating Safety Factor ---
def calculate_safety_factor(
    robots: List[Robot],
    grid_width: int,
    grid_height: int,
    simulation_time: int
) -> int:
    """"""
    Calculates the safety factor based on robot distribution after simulation.

    Args:
        robots: A list of Robot objects.
        grid_width: The width of the simulation grid.
        grid_height: The height of the simulation grid.
        simulation_time: The duration of the simulation in seconds.

    Returns:
        The calculated safety factor (product of robots in each quadrant).
    """"""
    if not robots:
        return 0 # No robots means 0 in all quadrants, product is 0.

    # Calculate final positions for all robots
    final_positions: List[Tuple[int, int]] = []
    for robot in robots:
        final_pos = robot.calculate_final_position(simulation_time, grid_width, grid_height)
        final_positions.append(final_pos)

    # Determine center lines (0-indexed)
    # Grid dimensions are odd, so (size - 1) / 2 is an integer.
    x_center = (grid_width - 1) // 2
    y_center = (grid_height - 1) // 2

    # Initialize quadrant counts
    quadrant_counts: Dict[str, int] = {""TL"": 0, ""TR"": 0, ""BL"": 0, ""BR"": 0}

    # Classify each robot's final position
    for fx, fy in final_positions:
        # Exclude robots on center lines
        if fx == x_center or fy == y_center:
            continue

        if fx < x_center and fy < y_center:
            quadrant_counts[""TL""] += 1
        elif fx > x_center and fy < y_center:
            quadrant_counts[""TR""] += 1
        elif fx < x_center and fy > y_center:
            quadrant_counts[""BL""] += 1
        elif fx > x_center and fy > y_center:
            quadrant_counts[""BR""] += 1

    # Debugging information (optional, to stderr)
    # print(f""Debug: Grid: {grid_width}x{grid_height}, Center: ({x_center}, {y_center})"", file=sys.stderr)
    # print(f""Debug: Total final positions: {len(final_positions)}"", file=sys.stderr)
    # print(f""Debug: Quadrant counts: {quadrant_counts}"", file=sys.stderr)

    # Calculate safety factor (product of counts)
    safety_factor = (
        quadrant_counts[""TL""] *
        quadrant_counts[""TR""] *
        quadrant_counts[""BL""] *
        quadrant_counts[""BR""]
    )
    return safety_factor

# --- Test Cases ---
# This structure matches the ""test_cases"" field in the input JSON to this agent.
# It's a list of [input_string, expected_output_string] pairs.
PROVIDED_TEST_CASES: List[Tuple[str, str]] = [
    (
        ""p=0,4 v=3,-3\n""
        ""p=6,3 v=-1,-3\n""
        ""p=10,3 v=-1,2\n""
        ""p=2,0 v=2,-1\n""
        ""p=0,0 v=1,3\n""
        ""p=3,0 v=-2,-2\n""
        ""p=7,6 v=-1,-3\n""
        ""p=3,0 v=-1,-2\n""
        ""p=9,3 v=2,3\n""
        ""p=7,3 v=-1,2\n""
        ""p=2,4 v=2,-3\n""
        ""p=9,5 v=-3,-3"",
        ""12""
    )
]

def run_tests(test_cases: List[Tuple[str, str]]):
    """"""
    Runs defined test cases and prints results to stderr.
    Uses example grid dimensions for these tests.
    """"""
    print(""--- Running Provided Example Test(s) ---"", file=sys.stderr)
    all_passed = True
    for i, (input_str, expected_output_str) in enumerate(test_cases):
        print(f""\nRunning Test Case #{i+1}"", file=sys.stderr)

        example_robots = parse_input_lines(input_str.strip().split('\n'))
        # Check if parsing failed for a non-empty input string
        if not example_robots and input_str.strip():
             print(f""Error: No robots parsed from example input string for Test Case #{i+1}. Check input format or parse_input_lines function."", file=sys.stderr)
             all_passed = False
             continue

        print(f""Test Case #{i+1}: Parsed {len(example_robots)} robots."", file=sys.stderr)

        try:
            expected_output = int(expected_output_str)
        except ValueError:
            print(f""Error: Invalid expected output format for Test Case #{i+1}: '{expected_output_str}' (must be an integer)."", file=sys.stderr)
            all_passed = False
            continue

        # Use example dimensions for the example test
        actual_output = calculate_safety_factor(
            example_robots,
            EXAMPLE_GRID_WIDTH,
            EXAMPLE_GRID_HEIGHT,
            SIMULATION_TIME
        )

        print(f""Test Case #{i+1}: Calculated Result: {actual_output}"", file=sys.stderr)
        print(f""Test Case #{i+1}: Expected Result: {expected_output}"", file=sys.stderr)

        if actual_output == expected_output:
            print(f""Test Case #{i+1}: PASSED!"", file=sys.stderr)
        else:
            print(f""Test Case #{i+1}: FAILED! Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
            all_passed = False

    if all_passed:
        print(""\nAll provided example tests PASSED."", file=sys.stderr)
    else:
        print(""\nSome provided example tests FAILED."", file=sys.stderr)
    print(""--- End of Example Test(s) ---"", file=sys.stderr)

# --- Main Execution ---
def main():
    """"""
    Main function to parse input, solve the puzzle, and print the result.
    """"""
    # Run embedded example tests first. Output to stderr.
    run_tests(PROVIDED_TEST_CASES)

    # Check command line arguments for the puzzle input file
    if len(sys.argv) < 2:
        print(""\nUsage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""Please provide the path to the puzzle input file."", file=sys.stderr)
        return # Exit if no input file is provided after tests.

    input_file_path = sys.argv[1]

    # Parse robots from the specified input file
    # These robots will be simulated on the MAIN grid dimensions.
    parsed_robots = parse_input_file(input_file_path)

    if not parsed_robots:
        # parse_input_file handles FileNotFoundError and prints an error to stderr.
        # If file was valid but empty or all lines malformed, it also returns [].
        # In such cases, the safety factor is 0.
        print(""No valid robot data found in input file. Assuming safety factor is 0."", file=sys.stderr)
        print(0) # Print 0 to STDOUT as the result
        return

    # Solve the puzzle using main grid dimensions
    solution = calculate_safety_factor(
        parsed_robots,
        MAIN_GRID_WIDTH,
        MAIN_GRID_HEIGHT,
        SIMULATION_TIME
    )

    # Print the final solution for the puzzle to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
15,single-model,gemini-2.5-pro-preview-05-06,False,153.96831822395325,"""""""
Advent of Code [Year] Day 15: Warehouse Woes
Solution implementation for Day 15 of Advent of Code.

The problem involves simulating a robot moving in a warehouse grid.
The robot can push boxes. If a move would cause the robot or a pushed box
to hit a wall, or a pushed box to hit another box, the move fails and nothing changes.
The goal is to calculate the sum of GPS coordinates of all boxes after a sequence of moves.
A GPS coordinate is 100 * row + column.

The approach uses sets to store positions of walls and boxes for efficient collision checking.
A Warehouse class encapsulates the state (robot position, box positions, wall positions)
and the logic for performing moves.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run embedded tests)
""""""
import sys
from typing import List, Set, Tuple, Optional

# Type alias for a point (row, col)
Point = Tuple[int, int]

# Global constant for move deltas (dr, dc)
MOVES_DELTA = {'^': (-1, 0), 'v': (1, 0), '<': (0, -1), '>': (0, 1)}

# --- Warehouse Simulation Class ---
class Warehouse:
    """"""
    Represents the state of the warehouse and handles robot/box movements.
    """"""
    def __init__(self, robot_pos: Point, boxes: Set[Point], walls: Set[Point],
                 map_dims: Tuple[int, int]):
        self.robot_pos: Point = robot_pos
        self.boxes: Set[Point] = boxes  # This set will be mutated
        self.walls: Set[Point] = walls
        self.map_height: int = map_dims[0]
        self.map_width: int = map_dims[1]

    def perform_move(self, move_char: str) -> None:
        """"""
        Attempts to perform a single move for the robot.
        Updates robot and box positions if the move is valid according to problem rules.
        """"""
        if move_char not in MOVES_DELTA:
            # Invalid move character, could raise error or ignore
            # For AoC, inputs are usually well-formed, so this might not be strictly necessary
            print(f""Warning: Invalid move character '{move_char}' encountered."", file=sys.stderr)
            return

        dr, dc = MOVES_DELTA[move_char]

        current_robot_pos = self.robot_pos

        # Calculate potential next robot position
        next_robot_r, next_robot_c = current_robot_pos[0] + dr, current_robot_pos[1] + dc
        next_robot_pos: Point = (next_robot_r, next_robot_c)

        # Case 1: Robot attempts to move into a wall
        if next_robot_pos in self.walls:
            # Nothing moves
            return

        # Case 2: Robot attempts to move into an empty space (not a wall, not a box)
        if next_robot_pos not in self.boxes:
            self.robot_pos = next_robot_pos # Robot moves
            return

        # Case 3: Robot attempts to move into a box (tries to push it)
        # At this point, next_robot_pos is the position of the box being pushed.
        pushed_box_original_pos: Point = next_robot_pos

        # Calculate potential next position of the pushed box
        next_box_r, next_box_c = pushed_box_original_pos[0] + dr, pushed_box_original_pos[1] + dc
        next_box_pos: Point = (next_box_r, next_box_c)

        # Subcase 3.1: Pushed box hits a wall or another box
        if next_box_pos in self.walls or next_box_pos in self.boxes:
            # Nothing moves (robot and pushed box are blocked)
            return
        # Subcase 3.2: Pushed box can move into an empty space
        else:
            # Robot moves, and box moves
            self.robot_pos = next_robot_pos

            # Update box positions: remove from old, add to new
            self.boxes.remove(pushed_box_original_pos)
            self.boxes.add(next_box_pos)

    def calculate_gps_sum(self) -> int:
        """"""
        Calculates the sum of GPS coordinates for all boxes.
        GPS coordinate = 100 * row + col (0-indexed).
        """"""
        total_gps = 0
        for r, c in self.boxes:
            total_gps += (100 * r + c)
        return total_gps

    def get_state_for_debug(self) -> Tuple[Point, Set[Point], Set[Point], Tuple[int, int]]:
        """"""Returns current state components for debugging purposes.""""""
        return self.robot_pos, self.boxes, self.walls, (self.map_height, self.map_width)

# --- Parsing Functions ---
def parse_input(input_file: str) -> Tuple[Point, Set[Point], Set[Point], str, Tuple[int, int]]:
    """"""
    Parses the puzzle input from a file.
    The input file contains a map, then an empty line, then a sequence of moves.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - robot_initial_pos (Point): Initial (row, col) of the robot '@'.
            - initial_boxes (Set[Point]): Set of initial (row, col) of boxes 'O'.
            - walls (Set[Point]): Set of (row, col) of walls '#'.
            - move_sequence (str): String of concatenated robot moves (^, v, <, >).
            - map_dims (Tuple[int, int]): (height, width) of the map.
    Raises:
        ValueError: If robot is not found or map format is unexpected.
        FileNotFoundError: If input_file does not exist.
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f.readlines()]

    map_str_lines: List[str] = []
    move_sequence_parts: List[str] = []
    parsing_map_section = True

    for line in lines:
        if not line:  # Empty line separates map from moves
            parsing_map_section = False
            continue

        if parsing_map_section:
            map_str_lines.append(line)
        else:
            move_sequence_parts.append(line) # Collect all move lines

    # Concatenate move lines to form a single sequence string
    move_sequence = """".join(move_sequence_parts)

    robot_pos: Optional[Point] = None
    boxes: Set[Point] = set()
    walls: Set[Point] = set()

    if not map_str_lines:
        raise ValueError(""Map data is empty."")

    map_height = len(map_str_lines)
    # Assume rectangular map based on the width of the first line
    map_width = len(map_str_lines[0]) if map_height > 0 else 0

    for r, row_str in enumerate(map_str_lines):
        if len(row_str) != map_width:
            # This could be an issue if map rows have varying lengths.
            # AoC maps are typically rectangular.
            print(f""Warning: Map row {r} has length {len(row_str)}, expected {map_width}."", file=sys.stderr)
        for c, char in enumerate(row_str):
            if char == '@':
                if robot_pos is not None:
                    raise ValueError(""Multiple robots '@' found in map."")
                robot_pos = (r, c)
            elif char == 'O':
                boxes.add((r, c))
            elif char == '#':
                walls.add((r, c))
            elif char == '.':
                pass # Empty space, no specific storage needed
            else:
                print(f""Warning: Unknown character '{char}' at ({r},{c}) in map."", file=sys.stderr)

    if robot_pos is None:
        raise ValueError(""Robot '@' not found in the map."")

    return robot_pos, boxes, walls, move_sequence, (map_height, map_width)

def parse_string_input_for_tests(map_data_str: str, moves_data_str: str) -> Tuple[Point, Set[Point], Set[Point], str, Tuple[int, int]]:
    """"""Helper to parse map and moves from strings for testing purposes.""""""
    map_str_lines = [line for line in map_data_str.split('\n')]

    robot_pos: Optional[Point] = None
    boxes: Set[Point] = set()
    walls: Set[Point] = set()

    if not map_str_lines:
        raise ValueError(""Test map data is empty."")

    map_height = len(map_str_lines)
    map_width = len(map_str_lines[0]) if map_height > 0 else 0

    for r, row_str in enumerate(map_str_lines):
        for c, char in enumerate(row_str):
            if char == '@':
                robot_pos = (r, c)
            elif char == 'O':
                boxes.add((r, c))
            elif char == '#':
                walls.add((r, c))

    if robot_pos is None:
        raise ValueError(""Robot '@' not found in map data for tests."")

    return robot_pos, boxes, walls, moves_data_str, (map_height, map_width)

# --- Solution Logic ---
def solve_part_one(parsed_data: Tuple[Point, Set[Point], Set[Point], str, Tuple[int, int]]) -> int:
    """"""
    Solves part one of the puzzle: simulates robot movement and calculates GPS sum.

    Args:
        parsed_data: A tuple containing initial robot position, box positions,
                     wall positions, the move sequence, and map dimensions.

    Returns:
        The sum of GPS coordinates of all boxes after all moves.
    """"""
    robot_initial_pos, initial_boxes, walls, move_sequence, map_dims = parsed_data

    # Create a Warehouse instance. It's crucial to pass a copy of initial_boxes
    # because the Warehouse object will mutate its 'boxes' set. If parsed_data is
    # reused (e.g., in tests or for a potential Part Two), this prevents unintended side effects.
    warehouse = Warehouse(robot_initial_pos, initial_boxes.copy(), walls, map_dims)

    for i, move_char in enumerate(move_sequence):
        warehouse.perform_move(move_char)
        # For step-by-step debugging of complex inputs:
        # if i < 5: # Print first few moves for quick check
        #    print(f""State after move {i+1} ('{move_char}'):"", file=sys.stderr)
        #    debug_print_state(*warehouse.get_state_for_debug())

    return warehouse.calculate_gps_sum()

# --- Debugging and Testing ---
def debug_print_state(robot_pos: Point, boxes: Set[Point], walls: Set[Point], map_dims: Tuple[int, int]) -> None:
    """"""Prints a visual representation of the warehouse state to stderr.""""""
    height, width = map_dims
    # Initialize an empty grid
    grid = [['.' for _ in range(width)] for _ in range(height)]

    # Place walls
    for r_wall, c_wall in walls:
        if 0 <= r_wall < height and 0 <= c_wall < width:
             grid[r_wall][c_wall] = '#'
    # Place boxes
    for r_box, c_box in boxes:
        if 0 <= r_box < height and 0 <= c_box < width:
            grid[r_box][c_box] = 'O'

    # Place robot
    if 0 <= robot_pos[0] < height and 0 <= robot_pos[1] < width:
        grid[robot_pos[0]][robot_pos[1]] = '@'

    print(f""Robot at: {robot_pos}"", file=sys.stderr)
    # Printing sorted list of boxes can be helpful for deterministic debug output:
    # print(f""Boxes: {sorted(list(boxes))}"", file=sys.stderr)
    for r in range(height):
        print("""".join(grid[r]), file=sys.stderr)
    print(""-"" * width, file=sys.stderr)

# Example data for tests, from the problem description
EXAMPLE_MAP_SMALL_STR = """"""
########
#..O.O.#
##@.O..#
#...O..#
#.#.O..#
#...O..#
#......#
########
"""""".strip()
EXAMPLE_MOVES_SMALL_STR = ""<^^>>>vv<v>>v<<""
EXAMPLE_SMALL_EXPECTED_GPS_SUM = 2028

def run_tests() -> None:
    """"""Runs all defined tests for the solution.""""""
    print(""Running tests..."", file=sys.stderr)

    # --- Test Small Example ---
    parsed_small_example_data = parse_string_input_for_tests(EXAMPLE_MAP_SMALL_STR, EXAMPLE_MOVES_SMALL_STR)

    # Optional: Print initial state for the small example
    # print(""Initial state for small example:"", file=sys.stderr)
    # debug_print_state(
    #     parsed_small_example_data[0], # robot_pos
    #     parsed_small_example_data[1], # boxes
    #     parsed_small_example_data[2], # walls
    #     parsed_small_example_data[4]  # map_dims
    # )

    result_small = solve_part_one(parsed_small_example_data)
    assert result_small == EXAMPLE_SMALL_EXPECTED_GPS_SUM, \
        f""Small example FAILED: Expected {EXAMPLE_SMALL_EXPECTED_GPS_SUM}, Got {result_small}""
    print(f""Small example PASSED (Result: {result_small})"", file=sys.stderr)

    # Note: The larger example from the problem description would typically be tested
    # by providing its input as a file, e.g.:
    # python3 solution.py path/to/large_example_input.txt
    # The expected GPS sum for the large example is 10092.

    print(""All defined tests passed."", file=sys.stderr)

# --- Main Execution Logic ---
def main() -> None:
    """"""
    Main function to execute the solution.
    Parses command line arguments for the input file.
    If no file is specified or 'test' is given as argument, runs embedded tests.
    Otherwise, solves the puzzle using the provided input file.
    """"""
    if len(sys.argv) < 2:
        print(""No input file specified. Running tests instead."", file=sys.stderr)
        run_tests()
        return

    input_file_arg = sys.argv[1]

    if input_file_arg.lower() == ""test"":
        print(""Test mode activated. Running tests."", file=sys.stderr)
        run_tests()
        return

    try:
        parsed_data = parse_input(input_file_arg)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file_arg}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    # Optional: Print initial state from file for debugging
    # print(""Initial state from file:"", file=sys.stderr)
    # initial_r, initial_b, initial_w, _, initial_dims = parsed_data
    # debug_print_state(initial_r, initial_b, initial_w, initial_dims)

    solution = solve_part_one(parsed_data)

    # Print the final solution to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
15,system,gemini-2.5-pro-preview-05-06,True,1584.4192469120026,"import sys
from typing import List, Tuple, Dict, Optional, Iterable

# Constants for grid elements and movements
WALL = '#'
BOX = 'O'
EMPTY = '.'
ROBOT_CHAR_PARSE = '@'  # Character representing robot in input map

DELTAS: Dict[str, Tuple[int, int]] = {
    '^': (-1, 0),  # Up
    'v': (1, 0),   # Down
    '<': (0, -1),  # Left
    '>': (0, 1)    # Right
}

def parse_input_from_lines(lines_iterable: Iterable[str]) -> Tuple[List[List[str]], Tuple[int, int], str]:
    """"""Parses map and command sequence from lines of text.

    Args:
        lines_iterable: An iterable of strings, each representing a line from the input.

    Returns:
        A tuple containing:
        - grid: A list of lists of characters representing the map.
        - robot_pos: A tuple (row, col) of the robot's initial 0-indexed position.
        - commands: A single string of all concatenated movement commands.
    """"""
    map_char_lines: List[List[str]] = []
    robot_pos_temp: Optional[Tuple[int, int]] = None
    command_str_parts: List[str] = []

    # Normalize lines by stripping trailing newlines primarily
    # Keep leading/trailing spaces on the line if they are part of map content, though problem examples don't show this.
    # .strip() is generally safer for parsing line-based data.
    lines_list = [line.rstrip('\n') for line in lines_iterable]

    map_section_parsing_complete = False
    current_map_row_idx = 0

    for line_content in lines_list:
        stripped_line = line_content.strip() # Handles empty lines and fully whitespace lines

        if not stripped_line: # Skip empty lines, may act as separator
            # If we were parsing map and have some map data, this might be a separator
            if not map_section_parsing_complete and map_char_lines:
                 # Heuristic: if an empty line appears after some map lines, assume map is done.
                 # This might not be strictly necessary if command lines are distinctly identifiable.
                 pass # Keep map_section_parsing_complete as is, let command line detection handle it.
            continue

        if not map_section_parsing_complete:
            # Check if this line looks like a command line (only contains ^v<>)
            is_command_line = True
            if not stripped_line: # An empty line is not a command line
                is_command_line = False
            else:
                for char_in_line in stripped_line:
                    if char_in_line not in DELTAS:
                        is_command_line = False
                        break

            if is_command_line:
                map_section_parsing_complete = True
                command_str_parts.append(stripped_line)
            else: # Assume it's a map line
                # Use original line_content for map row to preserve potential leading/trailing spaces if they are part of map structure
                # The problem description implies map is rectangular block. So using line_content vs stripped_line matters for cols.
                # For AoC, typically lines are used as is, or fully stripped. Let's use line_content for map rows.
                current_row_chars = []
                for col_idx, char_in_map_line in enumerate(line_content): # Use non-stripped line_content for map structure
                    if char_in_map_line == ROBOT_CHAR_PARSE:
                        if robot_pos_temp is not None:
                            raise ValueError(""Multiple robot starting positions '@' found."")
                        robot_pos_temp = (current_map_row_idx, col_idx)
                        current_row_chars.append(EMPTY) # Robot stands on an empty spot
                    else:
                        current_row_chars.append(char_in_map_line)
                map_char_lines.append(current_row_chars)
                current_map_row_idx += 1
        else: # map_section_parsing_complete is True, so this must be a command line
            # Only add non-empty stripped lines to commands
            if stripped_line: # Ensures we only add lines with command characters
                 is_command_line_check = all(c in DELTAS for c in stripped_line)
                 if is_command_line_check:
                    command_str_parts.append(stripped_line)
                 # else: print(f""Warning: Line '{stripped_line}' in command section contains non-command chars, skipping."", file=sys.stderr)

    if robot_pos_temp is None:
        raise ValueError(""Robot starting position '@' not found in map."")
    if not map_char_lines:
        raise ValueError(""Map is empty."")
    if not command_str_parts:
        raise ValueError(""No command sequence found."")

    final_commands = """".join(command_str_parts)
    return map_char_lines, robot_pos_temp, final_commands

def simulate_moves(initial_grid: List[List[str]],
                   initial_robot_pos: Tuple[int, int],
                   commands: str) -> Tuple[List[List[str]], Tuple[int, int]]:
    """"""Simulates robot and box movements on the grid.

    Args:
        initial_grid: The starting layout of the warehouse.
        initial_robot_pos: The robot's starting (row, col) coordinates.
        commands: A string of movement commands.

    Returns:
        A tuple containing:
        - final_grid: The grid state after all commands.
        - final_robot_pos: The robot's final (row, col) coordinates.
    """"""
    grid = [row[:] for row in initial_grid] # Work on a mutable copy
    robot_pos = initial_robot_pos

    num_rows = len(grid)
    num_cols = len(grid[0]) if num_rows > 0 else 0

    for command_char in commands:
        dr, dc = DELTAS[command_char]

        current_robot_r, current_robot_c = robot_pos
        next_robot_r, next_robot_c = current_robot_r + dr, current_robot_c + dc

        # Check 1: Robot tries to move out of bounds
        if not (0 <= next_robot_r < num_rows and 0 <= next_robot_c < num_cols):
            # Action fails, nothing moves
            continue

        target_cell_content = grid[next_robot_r][next_robot_c]

        # Check 2: Robot tries to move into a wall
        if target_cell_content == WALL:
            # Action fails, nothing moves
            continue

        # Check 3: Robot tries to move into an empty cell
        if target_cell_content == EMPTY:
            robot_pos = (next_robot_r, next_robot_c)
            # Action succeeds
            continue

        # Check 4: Robot tries to move into a box (potential push)
        if target_cell_content == BOX:
            pushed_boxes_original_coords: List[Tuple[int, int]] = []
            current_check_r, current_check_c = next_robot_r, next_robot_c # Position of the first box

            can_push = False
            final_empty_spot_for_chain: Optional[Tuple[int, int]] = None

            # Trace the chain of boxes
            while True:
                pushed_boxes_original_coords.append((current_check_r, current_check_c))

                pos_beyond_current_r, pos_beyond_current_c = current_check_r + dr, current_check_c + dc

                # Check if spot beyond current box is out of bounds
                if not (0 <= pos_beyond_current_r < num_rows and 0 <= pos_beyond_current_c < num_cols):
                    can_push = False # Chain hits boundary
                    break

                cell_beyond_content = grid[pos_beyond_current_r][pos_beyond_current_c]

                if cell_beyond_content == WALL:
                    can_push = False # Chain hits wall
                    break
                if cell_beyond_content == EMPTY:
                    can_push = True
                    final_empty_spot_for_chain = (pos_beyond_current_r, pos_beyond_current_c)
                    break
                if cell_beyond_content == BOX:
                    # Chain continues, move to check the next box
                    current_check_r, current_check_c = pos_beyond_current_r, pos_beyond_current_c
                    # Continue loop

            if can_push and final_empty_spot_for_chain is not None:
                # Perform the push: update grid from the end of the chain
                # 1. The last box in the chain moves into the final_empty_spot_for_chain
                grid[final_empty_spot_for_chain[0]][final_empty_spot_for_chain[1]] = BOX

                # 2. Shift all other boxes in the chain one step forward
                # Iterate from the second-to-last box in pushed_boxes_original_coords down to the first box.
                # pushed_boxes_original_coords[i] is the new position for pushed_boxes_original_coords[i-1]
                for i in range(len(pushed_boxes_original_coords) - 1, 0, -1):
                    box_original_r, box_original_c = pushed_boxes_original_coords[i-1]
                    new_pos_for_this_box_r, new_pos_for_this_box_c = pushed_boxes_original_coords[i]
                    grid[new_pos_for_this_box_r][new_pos_for_this_box_c] = BOX

                # 3. The cell where the first pushed box was originally located becomes empty.
                # This is where the robot will move.
                first_box_original_r, first_box_original_c = pushed_boxes_original_coords[0]
                grid[first_box_original_r][first_box_original_c] = EMPTY

                # 4. Update robot's position (moves into the spot vacated by the first box)
                robot_pos = (next_robot_r, next_robot_c) # which is first_box_original_r, first_box_original_c
            # else (can_push is False): Action fails, nothing moves. Loop to next command.

    return grid, robot_pos

def calculate_gps_sum(grid: List[List[str]]) -> int:
    """"""Calculates the sum of GPS coordinates for all boxes on the grid.

    Args:
        grid: The final state of the warehouse grid.

    Returns:
        The total sum of GPS coordinates.
    """"""
    total_gps_sum = 0
    for r_idx, row_content in enumerate(grid):
        for c_idx, cell_content in enumerate(row_content):
            if cell_content == BOX:
                gps_coordinate = (100 * r_idx) + c_idx
                total_gps_sum += gps_coordinate
    return total_gps_sum

def solve_puzzle(input_lines: Iterable[str]) -> int:
    """"""Solves the puzzle from parsed input.

    Args:
        input_lines: Iterable of strings from the input source.

    Returns:
        The sum of GPS coordinates of all boxes after simulation.
    """"""
    initial_grid, initial_robot_pos, commands = parse_input_from_lines(input_lines)

    # Optional: Print initial state for debugging
    # print_grid_debug(initial_grid, initial_robot_pos, ""Initial State"")
    # print(f""Commands: {commands[:50]}{'...' if len(commands) > 50 else ''}"", file=sys.stderr)

    final_grid, _ = simulate_moves(initial_grid, initial_robot_pos, commands)

    # Optional: Print final state for debugging
    # print_grid_debug(final_grid, final_robot_pos, ""Final State"")

    return calculate_gps_sum(final_grid)


def print_grid_debug(grid: List[List[str]], robot_pos: Optional[Tuple[int, int]], title: str = ""Grid""):
    """"""Helper function to print the grid and robot position for debugging.""""""
    print(f""--- {title} ---"", file=sys.stderr)
    # Create a temporary copy to overlay robot for printing, if robot_pos is provided
    # The main grid should always have EMPTY where the robot is.
    grid_to_print = [row[:] for row in grid]
    if robot_pos:
        r, c = robot_pos
        if 0 <= r < len(grid_to_print) and 0 <= c < len(grid_to_print[0]):
            grid_to_print[r][c] = ROBOT_CHAR_PARSE # Show robot char for visualization

    for row in grid_to_print:
        print("""".join(row), file=sys.stderr)
    print(""-"" * (len(grid[0]) if grid else 0), file=sys.stderr)


EXAMPLE_TEST_CASES = [
    (""########\n#..O.O.#\n##@.O..#\n#...O..#\n#.#.O..#\n#...O..#\n#......#\n########\n<^^>>>vv<v>>v<<"", 2028),
    (""##########\n#..O..O.O#\n#......O.#\n#.OO..O.O#\n#..O@..O.#\n#O#..O...#\n#O..O..O.#\n#.OO.O.OO#\n#....O...#\n##########\n<vv>^<v^>v>^vv^v>v<>v^v<v<^vv<<<^><<><>>v<vvv<>^v^>^<<<><<v<<<v^vv^v>^\nvvv<<^>^v^^><<>>><>^<<><^vv^^<>vvv<>><^^v>^>vv<>v<<<<v<^v>^<^^>>>^<v<v\n><>vv>v^v^<>><>>>><^^>vv>v<^^^>>v^v^<^^>v^^>v^<^v>v<>>v^v^<v>v^^<^^vv<\n<<v<^>>^^^^>>>v^<>vvv^><v<<<>^^^vv^<vvv>^>v<^^^^v<>^>vvvv><>>v^<<^^^^^\n^><^><>>><>^^<<^^v>>><^<v>^<vv>>v>>>^v><>^v><<<<v>>v<v<v>vvv>^<><<>^><\n^>><>^v<><^vvv<^^<><v<<<<<><^v<<<><<<^^<v<^^^><^>>^<v^><<<^>>^v<v^v<v^\n>^>>^v>vv>^<<^v<>><<><<v<<v><>v<^vv<<<>^^v^>^^>>><<^v>>v^v><^^>>^<>vv^\n<><^^>^^^<><vvvvv^v<v<<>^v<v>v<<^><<><<><<<^^<<<^<<>><<><^^^>^^<>^>v<>\n^^>vv<^v^v<vv>^<><v<^v>^^^>>>^^vvv^>vvv<>>>^<^>>>>>^<<^v>^vvv<>^<><<v>\nv^^>>><<^^<>>^v^<v^vv<>v^<<>^<^v^v><^<<<><<^<v><v<>vv>>v><v^<vv<>v^<<^"", 10092)
]

def run_tests():
    print(""Running example tests..."", file=sys.stderr)
    for i, (input_str, expected_output) in enumerate(EXAMPLE_TEST_CASES):
        print(f""--- Test Case {i+1} --- Input hash: {hash(input_str[:100])}"", file=sys.stderr)
        input_lines = input_str.splitlines()
        try:
            actual_output = solve_puzzle(input_lines)
            if actual_output == expected_output:
                print(f""Example {i+1}: PASS. Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
            else:
                print(f""Example {i+1}: FAIL. Expected {expected_output}, Got {actual_output}"", file=sys.stderr)
        except Exception as e:
            print(f""Example {i+1}: ERROR. {e}"", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
        print(""--- End Test Case ---"", file=sys.stderr)

def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file] | test"", file=sys.stderr)
        return

    if sys.argv[1].lower() == ""test"":
        run_tests()
        return

    input_file = sys.argv[1]
    try:
        with open(input_file, 'r') as f:
            input_lines = f.readlines()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        return
    except Exception as e:
        print(f""Error reading file: {e}"", file=sys.stderr)
        return

    try:
        solution = solve_puzzle(input_lines)
        print(solution) # ONLY PRINT THE RESULT TO STDOUT
    except ValueError as e:
        print(f""Error processing input: {e}"", file=sys.stderr)
    except Exception as e:
        print(f""An unexpected error occurred: {e}"", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)

if __name__ == ""__main__"":
    main()
"
16,single-model,gemini-2.5-pro-preview-05-06,False,180.17356610298157,"""""""
Advent of Code [Year] Day 16: Reindeer Maze
Solution implementation for Day 16 of Advent of Code.
This program finds the lowest-score path in a maze for a Reindeer.
The Reindeer can move forward (cost 1) or turn 90 degrees (cost 1000).
It starts at 'S' facing East and must reach 'E'.
The solution uses Dijkstra's algorithm to find the shortest path in terms of score.

Usage: python3 solution.py [input_file]
""""""
import sys
import heapq
from typing import List, Tuple, Dict, Optional

# Constants for directions
EAST = 0
SOUTH = 1
WEST = 2
NORTH = 3

# (dr, dc) for E, S, W, N respectively
# For grid[row][col]: row index increases downwards, col index increases to the right
# DR[EAST] = 0, DC[EAST] = 1
# DR[SOUTH] = 1, DC[SOUTH] = 0
# DR[WEST] = 0, DC[WEST] = -1
# DR[NORTH] = -1, DC[NORTH] = 0
DR = [0, 1, 0, -1]  # Delta_row for EAST, SOUTH, WEST, NORTH
DC = [1, 0, -1, 0]  # Delta_col for EAST, SOUTH, WEST, NORTH

# Costs
COST_MOVE = 1
COST_TURN = 1000

def parse_input(input_file: str) -> Tuple[List[str], Tuple[int, int], Tuple[int, int]]:
    """"""Parse the puzzle input from file into grid, start_pos, end_pos.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing the grid (List[str]),
        start coordinates (Tuple[int, int] as (row, col)),
        and end coordinates (Tuple[int, int] as (row, col)).

    Raises:
        ValueError: If 'S' or 'E' are missing or duplicated, or if grid is empty.
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out empty lines that might result from trailing newlines in file
    grid = [line for line in lines if line]

    if not grid:
        raise ValueError(""Input grid is empty."")

    start_pos: Optional[Tuple[int, int]] = None
    end_pos: Optional[Tuple[int, int]] = None

    for r, row_str in enumerate(grid):
        if not row_str: # Skip empty lines if they weren't filtered, or if grid is ragged
            continue
        if len(row_str) != len(grid[0]):
             raise ValueError(""Grid is not rectangular."")
        for c, char_val in enumerate(row_str):
            if char_val == 'S':
                if start_pos is not None:
                    raise ValueError(""Multiple 'S' found in grid."")
                start_pos = (r, c)
            elif char_val == 'E':
                if end_pos is not None:
                    raise ValueError(""Multiple 'E' found in grid."")
                end_pos = (r, c)

    if start_pos is None:
        raise ValueError(""Start 'S' not found in grid."")
    if end_pos is None:
        raise ValueError(""End 'E' not found in grid."")

    return grid, start_pos, end_pos

def solve_part_one(parsed_data: Tuple[List[str], Tuple[int, int], Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle using Dijkstra's algorithm.
    Finds the lowest score path from 'S' (facing East) to 'E'.

    Args:
        parsed_data: A tuple (grid, start_pos, end_pos).
                     grid: List of strings representing the maze.
                     start_pos: (row, col) of 'S'.
                     end_pos: (row, col) of 'E'.

    Returns:
        The lowest score to reach the end tile.
        Returns a large number (effectively infinity) if no path is found.
    """"""
    grid, start_pos, end_pos = parsed_data

    rows = len(grid)
    cols = len(grid[0]) # Assumes grid is not empty and all rows have same length (checked by parse_input)

    start_r, start_c = start_pos
    end_r, end_c = end_pos

    # Priority queue stores tuples of (score, r, c, direction)
    # Start facing East
    pq: List[Tuple[int, int, int, int]] = [(0, start_r, start_c, EAST)]

    # dist stores minimum score to reach (r, c, direction)
    dist: Dict[Tuple[int, int, int], int] = {}
    dist[(start_r, start_c, EAST)] = 0

    while pq:
        score, r, c, current_dir = heapq.heappop(pq)

        if score > dist.get((r, c, current_dir), float('inf')):
            continue

        if r == end_r and c == end_c:
            return score

        # Action 1: Move Forward
        nr, nc = r + DR[current_dir], c + DC[current_dir]
        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':
            new_score_move = score + COST_MOVE
            state_key_move = (nr, nc, current_dir)
            if new_score_move < dist.get(state_key_move, float('inf')):
                dist[state_key_move] = new_score_move
                heapq.heappush(pq, (new_score_move, nr, nc, current_dir))

        # Action 2: Turn Clockwise
        new_dir_cw = (current_dir + 1) % 4
        new_score_turn = score + COST_TURN
        state_key_cw = (r, c, new_dir_cw)
        if new_score_turn < dist.get(state_key_cw, float('inf')):
            dist[state_key_cw] = new_score_turn
            heapq.heappush(pq, (new_score_turn, r, c, new_dir_cw))

        # Action 3: Turn Counter-Clockwise
        new_dir_ccw = (current_dir - 1 + 4) % 4
        # new_score_turn is the same as for CW turn
        state_key_ccw = (r, c, new_dir_ccw)
        if new_score_turn < dist.get(state_key_ccw, float('inf')):
            dist[state_key_ccw] = new_score_turn
            heapq.heappush(pq, (new_score_turn, r, c, new_dir_ccw))

    return int(float('inf')) # No path found, return large int

def _create_test_data_from_string(s: str) -> Tuple[List[str], Tuple[int, int], Tuple[int, int]]:
    """"""Helper function to parse a multiline string into grid, start_pos, end_pos.
    Used for internal testing with example strings.
    """"""
    lines = [line for line in s.strip().split('\n')]
    grid = lines

    if not grid or not grid[0]:
        raise ValueError(""Test grid string is empty or malformed."")

    start_pos: Optional[Tuple[int, int]] = None
    end_pos: Optional[Tuple[int, int]] = None

    for r_idx, row_str in enumerate(grid):
        if len(row_str) != len(grid[0]):
            raise ValueError(""Test grid string is not rectangular."")
        for c_idx, char_val in enumerate(row_str):
            if char_val == 'S':
                if start_pos is not None:
                    raise ValueError(""Multiple 'S' found in test grid string."")
                start_pos = (r_idx, c_idx)
            elif char_val == 'E':
                if end_pos is not None:
                    raise ValueError(""Multiple 'E' found in test grid string."")
                end_pos = (r_idx, c_idx)

    if start_pos is None:
        raise ValueError(""Start 'S' not found in the provided test grid string."")
    if end_pos is None:
        raise ValueError(""End 'E' not found in the provided test grid string."")

    return grid, start_pos, end_pos

def run_tests():
    """"""Runs test cases based on problem examples. Prints status to stderr.
    Raises AssertionError if a test fails.
    """"""
    print(""Running example tests..."", file=sys.stderr)

    example1_str = """"""###############\n#.......#....E#\n#.#.###.#.###.#\n#.....#.#...#.#\n#.###.#####.#.#\n#.#.#.......#.#\n#.#.#####.###.#\n#...........#.#\n###.#.#####.#.#\n#...#.....#.#.#\n#.#.#.###.#.#.#\n#.....#...#.#.#\n#.###.#.#.#.#.#\n#S..#.....#...#\n###############""""""
    parsed_example1 = _create_test_data_from_string(example1_str)
    result1 = solve_part_one(parsed_example1)
    expected1 = 7036
    assert result1 == expected1, f""Example 1 Failed: Expected {expected1}, Got {result1}""
    print(f""Example 1 Passed. Result: {result1}"", file=sys.stderr)

    example2_str = """"""#################\n#...#...#...#..E#\n#.#.#.#.#.#.#.#.#\n#.#.#.#...#...#.#\n#.#.#.#.###.#.#.#\n#...#.#.#.....#.#\n#.#.#.#.#.#####.#\n#.#...#.#.#.....#\n#.#.#####.#.###.#\n#.#.#.......#...#\n#.#.###.#####.###\n#.#.#...#.....#.#\n#.#.#.#####.###.#\n#.#.#.........#.#\n#.#.#.#########.#\n#S#.............#\n#################""""""
    parsed_example2 = _create_test_data_from_string(example2_str)
    result2 = solve_part_one(parsed_example2)
    expected2 = 11048
    assert result2 == expected2, f""Example 2 Failed: Expected {expected2}, Got {result2}""
    print(f""Example 2 Passed. Result: {result2}"", file=sys.stderr)

    example_SE_adj_str = ""SE""
    parsed_SE_adj = _create_test_data_from_string(example_SE_adj_str)
    result_SE_adj = solve_part_one(parsed_SE_adj)
    expected_SE_adj = 1
    assert result_SE_adj == expected_SE_adj, f""Example S adjacent E Failed: Expected {expected_SE_adj}, Got {result_SE_adj}""
    print(f""Example S adjacent E Passed. Result: {result_SE_adj}"", file=sys.stderr)

    print(""All example tests passed."", file=sys.stderr)

def main():
    """"""Main entry point for the script.""""""
    try:
        run_tests()
    except AssertionError as e:
        print(f""A test case failed: {e}"", file=sys.stderr)
        # sys.exit(1) # Optionally exit if tests must pass before solving main input
    except ValueError as e:
        print(f""Error in test data setup: {e}"", file=sys.stderr)
        # sys.exit(1)

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    solution = solve_part_one(parsed_data)

    if solution == int(float('inf')):
        print(""No path found to the end tile. This might indicate an issue or a peculiar map."", file=sys.stderr)
        sys.exit(1)
    else:
        print(solution) # To stdout

if __name__ == ""__main__"":
    main()
"
16,system,gemini-2.5-pro-preview-05-06,True,984.6039550304413,"""""""
Advent of Code - Reindeer Maze Solver
Solution implementation based on the provided plan for a maze navigation problem.
The agent (Reindeer) navigates a 2D grid from 'S' to 'E' with costs for moving and turning.
The algorithm used is Dijkstra's to find the minimum cost path.

Usage: python3 solution.py [input_file]
""""""
import sys
import heapq
from typing import List, Tuple, Dict

# --- Constants based on the plan ---
# Orientations
EAST = 0
SOUTH = 1
WEST = 2
NORTH = 3

# Delta row and column for movement, indexed by orientation
# E.g., DELTA_ROW[EAST] is row change for moving East
# For EAST (0): (row_change=0, col_change=1)
# For SOUTH (1): (row_change=1, col_change=0)
# For WEST (2): (row_change=0, col_change=-1)
# For NORTH (3): (row_change=-1, col_change=0)
DELTA_ROW = [0, 1, 0, -1]  # Corresponds to E, S, W, N
DELTA_COL = [1, 0, -1, 0]  # Corresponds to E, S, W, N

# Costs
COST_MOVE_FORWARD = 1
COST_TURN = 1000
# --- End Constants ---


def parse_input(input_file: str) -> Tuple[List[str], Tuple[int, int], Tuple[int, int], int, int]:
    """"""
    Parse the puzzle input from file.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
        - grid: List of strings representing the maze.
        - start_coordinates: (row, col) of 'S'.
        - end_coordinates: (row, col) of 'E'.
        - num_rows: Number of rows in the grid.
        - num_cols: Number of columns in the grid.
    Raises:
        ValueError: If input is malformed (e.g., empty, not rectangular, S/E missing/multiple).
        FileNotFoundError: If input_file does not exist.
    """"""
    with open(input_file, 'r') as f:
        # Read lines, strip whitespace, and filter out empty lines
        grid = [line.strip() for line in f.readlines() if line.strip()]

    if not grid or not grid[0]:
        raise ValueError(""Input grid is empty or malformed."")

    num_rows = len(grid)
    num_cols = len(grid[0])

    start_coordinates: Tuple[int, int] | None = None
    end_coordinates: Tuple[int, int] | None = None

    for r_idx, row_str in enumerate(grid):
        if len(row_str) != num_cols:
            raise ValueError(f""Grid is not rectangular. Row {r_idx} has length {len(row_str)}, expected {num_cols}."")
        for c_idx, char_in_row in enumerate(row_str):
            if char_in_row == 'S':
                if start_coordinates is not None:
                    raise ValueError(""Multiple 'S' tiles found."")
                start_coordinates = (r_idx, c_idx)
            elif char_in_row == 'E':
                if end_coordinates is not None:
                    raise ValueError(""Multiple 'E' tiles found."")
                end_coordinates = (r_idx, c_idx)

    if start_coordinates is None:
        raise ValueError(""'S' tile not found."")
    if end_coordinates is None:
        raise ValueError(""'E' tile not found."")

    return grid, start_coordinates, end_coordinates, num_rows, num_cols


def solve_reindeer_maze(
    grid: List[str],
    start_coords: Tuple[int, int],
    end_coords: Tuple[int, int],
    num_rows: int,
    num_cols: int
) -> int:
    """"""
    Solve the Reindeer Maze using Dijkstra's algorithm.

    Args:
        grid: The maze map.
        start_coords: (row, col) of the start tile 'S'.
        end_coords: (row, col) of the end tile 'E'.
        num_rows: Number of rows in the grid.
        num_cols: Number of columns in the grid.

    Returns:
        The minimum cost to reach the 'E' tile, or -1 if no path is found.
    """"""
    # Priority queue stores tuples of (cost, row, col, orientation)
    priority_queue: List[Tuple[int, int, int, int]] = []

    # min_costs stores the minimum cost found so far to reach a state (row, col, orientation)
    min_costs: Dict[Tuple[int, int, int], int] = {}

    start_r, start_c = start_coords
    initial_orientation = EAST  # Starts facing East
    initial_cost = 0

    # Initialize with the starting state
    heapq.heappush(priority_queue, (initial_cost, start_r, start_c, initial_orientation))
    min_costs[(start_r, start_c, initial_orientation)] = initial_cost

    while priority_queue:
        current_cost, r, c, current_orientation = heapq.heappop(priority_queue)

        # If a shorter path to this state (r, c, current_orientation) was already found and processed,
        # this entry in the priority queue is stale. Skip it.
        if current_cost > min_costs[(r, c, current_orientation)]:
            continue

        # Goal condition: if current tile is 'E'
        if (r, c) == end_coords:
            return current_cost  # Found the shortest path to 'E'

        # Explore actions: Move Forward, Turn Clockwise, Turn Counter-Clockwise

        # 1. Action: Move Forward
        next_r_move = r + DELTA_ROW[current_orientation]
        next_c_move = c + DELTA_COL[current_orientation]

        # Check validity of moving forward (within bounds and not a wall)
        if 0 <= next_r_move < num_rows and 0 <= next_c_move < num_cols and \
           grid[next_r_move][next_c_move] != '#':

            new_cost_move = current_cost + COST_MOVE_FORWARD
            next_state_key_move = (next_r_move, next_c_move, current_orientation)

            if new_cost_move < min_costs.get(next_state_key_move, float('inf')):
                min_costs[next_state_key_move] = new_cost_move
                heapq.heappush(priority_queue, (new_cost_move, next_r_move, next_c_move, current_orientation))

        # 2. Action: Turn Clockwise
        clockwise_orientation = (current_orientation + 1) % 4
        new_cost_turn_cw = current_cost + COST_TURN
        next_state_key_turn_cw = (r, c, clockwise_orientation)

        if new_cost_turn_cw < min_costs.get(next_state_key_turn_cw, float('inf')):
            min_costs[next_state_key_turn_cw] = new_cost_turn_cw
            heapq.heappush(priority_queue, (new_cost_turn_cw, r, c, clockwise_orientation))

        # 3. Action: Turn Counter-Clockwise
        counter_clockwise_orientation = (current_orientation - 1 + 4) % 4
        new_cost_turn_ccw = current_cost + COST_TURN
        next_state_key_turn_ccw = (r, c, counter_clockwise_orientation)

        if new_cost_turn_ccw < min_costs.get(next_state_key_turn_ccw, float('inf')):
            min_costs[next_state_key_turn_ccw] = new_cost_turn_ccw
            heapq.heappush(priority_queue, (new_cost_turn_ccw, r, c, counter_clockwise_orientation))

    return -1 # Should not be reached if a path always exists as per problem implication


def main():
    """"""
    Main entry point for the solution.
    Parses command-line arguments, reads input, solves the puzzle, and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        grid, start_coords, end_coords, num_rows, num_cols = parse_input(input_file)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)

    solution = solve_reindeer_maze(grid, start_coords, end_coords, num_rows, num_cols)

    if solution == -1:
        # This case implies no path was found, which contradicts problem assumption.
        print(""Error: No path found to the end tile 'E'."", file=sys.stderr)
        sys.exit(1)
    else:
        # ONLY PRINT THE RESULT, NO OTHER TEXT
        print(solution)

if __name__ == ""__main__"":
    main()
"
17,single-model,gemini-2.5-pro-preview-05-06,True,231.13579487800598,"""""""
Advent of Code [AoC Year] Day 17: Chronospatial Computer
Solution implementation for simulating the 3-bit computer described in the puzzle.

The program simulates a custom 3-bit computer with three general-purpose integer
registers (A, B, C), an instruction pointer (IP), and a program consisting of
3-bit numbers. It parses initial register values and the program from an input
file, then executes the program according to a specific instruction set.
The primary goal is to collect and return the comma-separated string of values
produced by the 'out' instruction.

The instruction set includes arithmetic (division, XOR), register manipulation,
conditional jumps (jump-if-not-zero), and output. Operands can be literal
values or 'combo' values derived from literals or register contents.

The simulation proceeds instruction by instruction, updating registers and the IP
as defined by each opcode and its operand. It halts if the IP moves beyond
the program's bounds or if a predefined instruction execution limit is reached
(as a safeguard).

Usage: python3 solution.py [input_file_path]
       python3 solution.py test (to run built-in examples)
""""""
from typing import List, Dict, Tuple
import sys
import re

# Define a type for registers for clarity
Registers = Dict[str, int]

def parse_input(input_file: str) -> Tuple[Registers, List[int]]:
    """"""Parse the puzzle input from file into initial registers and program.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - A dictionary for initial register values (A, B, C).
            - A list of integers representing the program.

    Raises:
        SystemExit: If file not found, read error, or critical parsing error.
    """"""
    initial_registers: Registers = {'A': 0, 'B': 0, 'C': 0}
    program: List[int] = []

    try:
        with open(input_file, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)

    parsed_regs_count = 0 # To ensure all A, B, C are found
    program_found = False

    for line_num, line_content in enumerate(lines):
        line = line_content.strip()
        if not line:
            continue

        match_reg_a = re.fullmatch(r""Register A: (-?\d+)"", line)
        if match_reg_a:
            initial_registers['A'] = int(match_reg_a.group(1))
            parsed_regs_count +=1
            continue

        match_reg_b = re.fullmatch(r""Register B: (-?\d+)"", line)
        if match_reg_b:
            initial_registers['B'] = int(match_reg_b.group(1))
            parsed_regs_count +=1
            continue

        match_reg_c = re.fullmatch(r""Register C: (-?\d+)"", line)
        if match_reg_c:
            initial_registers['C'] = int(match_reg_c.group(1))
            parsed_regs_count +=1
            continue

        match_program = re.fullmatch(r""Program: ([\d,]*)"", line) # Allow empty program string
        if match_program:
            program_str = match_program.group(1)
            if not program_str: # Handle ""Program: "" which means empty program list
                 program = []
            else:
                try:
                    program = [int(x) for x in program_str.split(',')]
                except ValueError:
                    print(f""Error: Malformed program string on line {line_num+1}: '{program_str}' contains non-integer."", file=sys.stderr)
                    sys.exit(1)
            program_found = True
            continue

        print(f""Warning: Unrecognized line {line_num+1} in input: '{line}'"", file=sys.stderr)

    if parsed_regs_count != 3 or not program_found:
        err_msg = ""Error: Input file format incorrect. ""
        if parsed_regs_count != 3:
            err_msg += f""Expected 3 register definitions, found {parsed_regs_count}. ""
        if not program_found:
            err_msg += ""Program definition line not found or malformed.""
        print(err_msg, file=sys.stderr)
        sys.exit(1)

    return initial_registers, program


def get_combo_operand_value(operand_raw: int, registers: Registers) -> int:
    """"""Resolves the value of a combo operand.

    Args:
        operand_raw: The raw 3-bit combo operand (0-6).
        registers: The current state of registers A, B, C.

    Returns:
        The resolved value of the combo operand.

    Raises:
        ValueError: If the operand_raw is invalid (e.g., 7 or outside 0-6 range).
    """"""
    if not (0 <= operand_raw <= 6):
        if operand_raw == 7:
             raise ValueError(""Combo operand 7 is reserved"")
        raise ValueError(f""Invalid combo operand raw value: {operand_raw}. Expected 0-6."")

    if 0 <= operand_raw <= 3:
        return operand_raw
    elif operand_raw == 4:
        return registers['A']
    elif operand_raw == 5:
        return registers['B']
    elif operand_raw == 6:
        return registers['C']
    else: # Should be unreachable due to the check at the start
        raise AssertionError(f""Internal error in get_combo_operand_value with {operand_raw}"")


def solve_part_one(parsed_data: Tuple[Registers, List[int]]) -> str:
    """"""Simulate the Chronospatial Computer and return its output.

    Args:
        parsed_data: A tuple containing initial registers and the program.

    Returns:
        A string of comma-separated output values produced by the 'out' instruction.

    Raises:
        ValueError, Exception: If runtime errors occur during simulation.
    """"""
    initial_registers, program_code = parsed_data
    registers = initial_registers.copy()
    ip = 0
    output_values: List[str] = []

    program_len = len(program_code)
    max_instructions_to_execute = 5_000_000
    instructions_executed_count = 0

    while 0 <= ip < program_len and instructions_executed_count < max_instructions_to_execute:
        instructions_executed_count += 1

        if ip + 1 >= program_len: # Need opcode and operand
            break

        opcode = program_code[ip]
        operand_raw = program_code[ip+1]

        jumped = False

        try:
            if opcode == 0:  # adv
                combo_val = get_combo_operand_value(operand_raw, registers)
                denominator = 2 ** combo_val
                registers['A'] = registers['A'] // denominator
            elif opcode == 1:  # bxl
                literal_operand_value = operand_raw
                registers['B'] = registers['B'] ^ literal_operand_value
            elif opcode == 2:  # bst
                combo_val = get_combo_operand_value(operand_raw, registers)
                registers['B'] = combo_val % 8
            elif opcode == 3:  # jnz
                literal_operand_value = operand_raw
                if registers['A'] != 0:
                    ip = literal_operand_value
                    jumped = True
            elif opcode == 4:  # bxc
                registers['B'] = registers['B'] ^ registers['C']
            elif opcode == 5:  # out
                combo_val = get_combo_operand_value(operand_raw, registers)
                output_values.append(str(combo_val % 8))
            elif opcode == 6:  # bdv
                combo_val = get_combo_operand_value(operand_raw, registers)
                denominator = 2 ** combo_val
                registers['B'] = registers['A'] // denominator
            elif opcode == 7:  # cdv
                combo_val = get_combo_operand_value(operand_raw, registers)
                denominator = 2 ** combo_val
                registers['C'] = registers['A'] // denominator
            else:
                raise ValueError(f""Unknown opcode {opcode} at IP {ip}."")

        except ValueError as e:
            if ""Combo operand 7 is reserved"" in str(e):
                 raise ValueError(f""Combo operand 7 is reserved and used at IP {ip}."") from e
            raise ValueError(f""Instruction error at IP {ip} (Opcode: {opcode}, RawOperand: {operand_raw}): {e}"") from e
        except Exception as e:
            print(f""An unexpected error occurred during instruction execution: {e}"", file=sys.stderr)
            print(f""IP={ip}, Opcode={opcode}, RawOperand={operand_raw}, Regs={registers}"", file=sys.stderr)
            raise

        if not jumped:
            ip += 2

    if instructions_executed_count >= max_instructions_to_execute:
        print(f""Warning: Program halted due to exceeding maximum instruction execution limit ({max_instructions_to_execute})."", file=sys.stderr)
        print(f""Current IP={ip}, Registers={registers}"", file=sys.stderr)

    return "","".join(output_values)

def run_tests():
    """"""Runs the provided examples to verify correctness.""""""
    print(""Running tests..."", file=sys.stderr)

    test_cases = [
        {
            ""name"": ""Test 1: bst"", ""initial_registers"": {'A': 0, 'B': 0, 'C': 9}, ""program"": [2, 6],
            ""expected_output"": """", ""final_registers_check"": {'A': 0, 'B': 1, 'C': 9}
        },
        {
            ""name"": ""Test 2: out multiple"", ""initial_registers"": {'A': 10, 'B': 0, 'C': 0}, ""program"": [5, 0, 5, 1, 5, 4],
            ""expected_output"": ""0,1,2"", ""final_registers_check"": {'A': 10, 'B': 0, 'C': 0}
        },
        {
            ""name"": ""Test 3: adv, out, jnz loop"", ""initial_registers"": {'A': 2024, 'B': 0, 'C': 0}, ""program"": [0, 1, 5, 4, 3, 0],
            ""expected_output"": ""4,2,5,6,7,7,7,7,3,1,0"", ""final_registers_check"": {'A': 0, 'B': 0, 'C': 0}
        },
        {
            ""name"": ""Test 4: bxl"", ""initial_registers"": {'A': 0, 'B': 29, 'C': 0}, ""program"": [1, 7],
            ""expected_output"": """", ""final_registers_check"": {'A': 0, 'B': 26, 'C': 0}
        },
        {
            ""name"": ""Test 5: bxc"", ""initial_registers"": {'A': 0, 'B': 2024, 'C': 43690}, ""program"": [4, 0],
            ""expected_output"": """", ""final_registers_check"": {'A': 0, 'B': 44354, 'C': 43690}
        },
        {
            ""name"": ""Problem Example: Full run"", ""initial_registers"": {'A': 729, 'B': 0, 'C': 0}, ""program"": [0,1,5,4,3,0],
            ""expected_output"": ""4,6,3,5,6,3,5,2,1,0"", ""final_registers_check"": {'A': 0, 'B': 0, 'C': 0}
        }
    ]

    all_passed = True
    for test_spec in test_cases:
        print(f""  Running {test_spec['name']}..."", file=sys.stderr)

        actual_output_str = solve_part_one((test_spec[""initial_registers""].copy(), test_spec[""program""]))

        _registers_for_check = test_spec[""initial_registers""].copy()
        _ip_for_check = 0
        _prog_for_check = test_spec[""program""]
        _instr_count_for_check = 0
        max_instr_test = 100000

        while 0 <= _ip_for_check < len(_prog_for_check) and _instr_count_for_check < max_instr_test:
            _instr_count_for_check +=1
            if _ip_for_check + 1 >= len(_prog_for_check): break

            _opcode, _operand_raw = _prog_for_check[_ip_for_check], _prog_for_check[_ip_for_check+1]
            _jumped_for_check = False

            try:
                if _opcode == 0: _registers_for_check['A'] //= (2 ** get_combo_operand_value(_operand_raw, _registers_for_check))
                elif _opcode == 1: _registers_for_check['B'] ^= _operand_raw
                elif _opcode == 2: _registers_for_check['B'] = get_combo_operand_value(_operand_raw, _registers_for_check) % 8
                elif _opcode == 3:
                    if _registers_for_check['A'] != 0: _ip_for_check = _operand_raw; _jumped_for_check = True
                elif _opcode == 4: _registers_for_check['B'] ^= _registers_for_check['C']
                elif _opcode == 5: get_combo_operand_value(_operand_raw, _registers_for_check)
                elif _opcode == 6: _registers_for_check['B'] = _registers_for_check['A'] // (2 ** get_combo_operand_value(_operand_raw, _registers_for_check))
                elif _opcode == 7: _registers_for_check['C'] = _registers_for_check['A'] // (2 ** get_combo_operand_value(_operand_raw, _registers_for_check))
                else: raise ValueError(f""Test sim: Unknown opcode {_opcode}"")
            except Exception as e_test_sim:
                print(f""      ERROR IN TEST REGISTER SIMULATION for {test_spec['name']}: {e_test_sim}"", file=sys.stderr)
                all_passed = False; break
            if not _jumped_for_check: _ip_for_check += 2

        output_ok = actual_output_str == test_spec[""expected_output""]
        regs_ok = True
        if ""final_registers_check"" in test_spec:
            regs_ok = _registers_for_check == test_spec[""final_registers_check""]

        if output_ok and regs_ok:
            print(f""    PASSED: {test_spec['name']}"", file=sys.stderr)
        else:
            all_passed = False
            print(f""    FAILED: {test_spec['name']}"", file=sys.stderr)
            if not output_ok:
                print(f""      Expected output: '{test_spec['expected_output']}'"", file=sys.stderr)
                print(f""      Actual output:   '{actual_output_str}'"", file=sys.stderr)
            if ""final_registers_check"" in test_spec and not regs_ok:
                print(f""      Expected regs: {test_spec['final_registers_check']}"", file=sys.stderr)
                print(f""      Actual regs:   {_registers_for_check}"", file=sys.stderr)

    if all_passed: print(""All tests passed!"", file=sys.stderr)
    else: print(""Some tests FAILED."", file=sys.stderr)
    print(""-"" * 20, file=sys.stderr)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file_path]"", file=sys.stderr)
        print(""       python3 solution.py test (to run built-in examples)"", file=sys.stderr)
        sys.exit(1)

    input_arg = sys.argv[1]

    if input_arg.lower() == ""test"":
        run_tests()
        return

    try:
        parsed_data = parse_input(input_arg)
    except SystemExit:
        return
    except Exception as e:
        print(f""An unexpected error occurred during input parsing: {e}"", file=sys.stderr)
        sys.exit(1)

    try:
        solution = solve_part_one(parsed_data)
        print(solution) # Output to STDOUT
    except Exception as e:
        print(f""An error occurred during program execution: {e}"", file=sys.stderr)
        sys.exit(1)

if __name__ == ""__main__"":
    main()
"
17,system,gemini-2.5-pro-preview-05-06,True,1338.5254645347595,"""""""
Advent of Code Day 17: Chronospatial Computer
Solution implementation based on the provided plan.

Simulates a custom 3-bit computer. The computer has three integer registers (A, B, C),
an instruction pointer (IP), and executes a program consisting of 3-bit numbers (0-7).
Each instruction is defined by a 3-bit opcode and a 3-bit operand.
The simulation processes these instructions, updates register values and the IP,
and collects all values produced by 'out' instructions. The final result is a single
string of these collected outputs, separated by commas.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Dict, Tuple

def parse_input(input_data: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from string into initial registers and program code.

    Args:
        input_data: Raw multi-line puzzle input string.

    Returns:
        A tuple containing:
            - initial_registers: Dictionary of initial register values {'A': val, 'B': val, 'C': val}.
            - program_code: List of integers representing the program instructions.
    """"""
    initial_registers: Dict[str, int] = {}
    program_code: List[int] = []

    lines = input_data.strip().split('\n')

    for line in lines:
        line = line.strip()
        if not line: # Skip empty lines
            continue

        if line.startswith(""Register A:""):
            initial_registers['A'] = int(line.split(':')[1].strip())
        elif line.startswith(""Register B:""):
            initial_registers['B'] = int(line.split(':')[1].strip())
        elif line.startswith(""Register C:""):
            initial_registers['C'] = int(line.split(':')[1].strip())
        elif line.startswith(""Program:""):
            program_str = line.split(':', 1)[1].strip()
            if program_str: # Handle case of empty program list string
                try:
                    program_code = [int(x) for x in program_str.split(',')]
                except ValueError as e:
                    raise ValueError(f""Invalid number in program string: {program_str}. Error: {e}"")
            else:
                program_code = [] # Program string is empty, so program is empty

    # Ensure all registers A, B, C are present. Problem implies they will be.
    # If they could be missing, one might default them here, e.g. to 0.
    # For this problem, we assume valid input provides all initial register values.
    if not all(reg in initial_registers for reg in ['A', 'B', 'C']):
        raise ValueError(""Initial values for registers A, B, C must all be provided."")

    return initial_registers, program_code

def resolve_combo_operand(operand_code: int, registers: Dict[str, int]) -> int:
    """"""Resolve the value of a combo operand.

    Args:
        operand_code: The 3-bit combo operand (0-6).
        registers: Current state of registers A, B, C.

    Returns:
        The resolved integer value of the operand.
    """"""
    if 0 <= operand_code <= 3:
        return operand_code  # Literal values 0-3
    elif operand_code == 4:
        return registers['A']
    elif operand_code == 5:
        return registers['B']
    elif operand_code == 6:
        return registers['C']
    else:
        # Combo operand 7 is reserved and should not appear in valid programs.
        raise ValueError(f""Invalid or reserved combo operand code: {operand_code}"")

def simulate_computer(initial_registers: Dict[str, int], program_code: List[int]) -> str:
    """"""Simulate the Chronospatial Computer and return its output string.

    Args:
        initial_registers: Initial values for registers A, B, C.
        program_code: The list of instructions (3-bit numbers).

    Returns:
        A comma-separated string of values produced by the 'out' instruction.
    """"""
    registers = initial_registers.copy()
    program = program_code
    ip = 0
    collected_outputs: List[int] = []

    program_len = len(program)

    while True:
        # Halt condition: IP out of bounds for fetching opcode
        if not (0 <= ip < program_len):
            break

        opcode = program[ip]

        # Halt condition: IP out of bounds for fetching operand
        if not (0 <= ip + 1 < program_len):
            break

        operand_param = program[ip + 1]

        ip_increment = 2  # Default IP advancement (opcode + operand)
        jumped = False      # Flag for jnz instruction

        # Execute Instruction (Opcode Dispatch)
        if opcode == 0:  # adv (divide A)
            combo_val = resolve_combo_operand(operand_param, registers)
            denominator = 2 ** combo_val
            # Python's int() truncates towards zero, e.g., int(2.7)=2, int(-2.7)=-2
            registers['A'] = int(registers['A'] / denominator)
        elif opcode == 1:  # bxl (B = B XOR literal_operand)
            literal_operand_val = operand_param
            registers['B'] = registers['B'] ^ literal_operand_val
        elif opcode == 2:  # bst (B = combo_operand % 8)
            combo_val = resolve_combo_operand(operand_param, registers)
            registers['B'] = combo_val % 8
        elif opcode == 3:  # jnz (jump if A != 0)
            literal_operand_val = operand_param
            if registers['A'] != 0:
                ip = literal_operand_val
                jumped = True # Prevents default IP increment
        elif opcode == 4:  # bxc (B = B XOR C)
            # Operand operand_param is read from program but ignored
            registers['B'] = registers['B'] ^ registers['C']
        elif opcode == 5:  # out (output combo_operand % 8)
            combo_val = resolve_combo_operand(operand_param, registers)
            output_value = combo_val % 8
            collected_outputs.append(output_value)
        elif opcode == 6:  # bdv (divide A, store in B)
            combo_val = resolve_combo_operand(operand_param, registers)
            denominator = 2 ** combo_val
            registers['B'] = int(registers['A'] / denominator)
        elif opcode == 7:  # cdv (divide A, store in C)
            combo_val = resolve_combo_operand(operand_param, registers)
            denominator = 2 ** combo_val
            registers['C'] = int(registers['A'] / denominator)
        # else: No other opcodes are possible as they are 3-bit numbers.

        # Update Instruction Pointer
        if not jumped:
            ip += ip_increment

    return "","".join(map(str, collected_outputs))

def solve_part_one(parsed_data: Tuple[Dict[str, int], List[int]]) -> str:
    """"""Solve part one of the puzzle.

    Args:
        parsed_data: Processed input data (initial registers and program code).

    Returns:
        Solution for part one (the comma-separated output string).
    """"""
    initial_registers, program_code = parsed_data
    return simulate_computer(initial_registers, program_code)

def run_tests():
    """"""Runs test cases provided in the problem description or specification.
    Outputs test results to stderr.
    """"""
    test_cases = [
        (
            ""Register A: 10\nRegister B: 0\nRegister C: 0\n\nProgram: 5,0,5,1,5,4"",
            ""0,1,2""
        ),
        (
            ""Register A: 2024\nRegister B: 0\nRegister C: 0\n\nProgram: 0,1,5,4,3,0"",
            ""4,2,5,6,7,7,7,7,3,1,0""
        ),
        (
            ""Register A: 729\nRegister B: 0\nRegister C: 0\n\nProgram: 0,1,5,4,3,0"",
            ""4,6,3,5,6,3,5,2,1,0""
        )
    ]

    print(""\nRunning internal tests..."", file=sys.stderr)
    all_passed = True
    for i, (test_input_str, expected_output) in enumerate(test_cases):
        print(f""Test Case {i+1}:"", file=sys.stderr)
        try:
            parsed_test_input = parse_input(test_input_str)
            actual_output = solve_part_one(parsed_test_input)

            # Debug print for more detailed inspection if needed:
            # print(f""  Input String:\n{test_input_str}"", file=sys.stderr)
            # print(f""  Parsed Input: {parsed_test_input}"", file=sys.stderr)
            print(f""  Expected Output: {expected_output}"", file=sys.stderr)
            print(f""  Actual Output:   {actual_output}"", file=sys.stderr)

            assert actual_output == expected_output, f""Test Case {i+1} Failed!""
            print(f""Test Case {i+1} Passed.\n"", file=sys.stderr)
        except Exception as e:
            print(f""Test Case {i+1} Errored: {e}\n"", file=sys.stderr)
            all_passed = False

    if all_passed:
        print(""All internal tests passed successfully."", file=sys.stderr)
    else:
        print(""Some internal tests failed."", file=sys.stderr)

def main():
    """"""Main entry point for the solution.
    Parses command-line arguments, reads input, solves the puzzle, and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""Error: Input file path not provided."", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        with open(input_file, 'r') as f:
            file_content = f.read()
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file '{input_file}': {e}"", file=sys.stderr)
        sys.exit(1)

    try:
        parsed_data = parse_input(file_content)
    except ValueError as e:
        print(f""Error parsing input data: {e}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""An unexpected error occurred during parsing: {e}"", file=sys.stderr)
        sys.exit(1)

    try:
        solution = solve_part_one(parsed_data)
        # ONLY PRINT THE FINAL RESULT TO STDOUT
        print(solution)
    except Exception as e:
        print(f""An unexpected error occurred during simulation: {e}"", file=sys.stderr)
        sys.exit(1)

    # Run example tests (output to stderr)
    # This is included as per the agent's responsibilities.
    run_tests()

if __name__ == ""__main__"":
    main()
"
18,single-model,gemini-2.5-pro-preview-05-06,True,141.6358287334442,"""""""
Advent of Code [Year] Day 18: RAM Run
Solution implementation based on the provided plan.
Finds the shortest path in a grid where cells become blocked over time.

Usage: python3 solution.py [input_file]
""""""
import sys
from collections import deque
from typing import List, Tuple, Set, Optional

# Constants for the puzzle (Part One)
DEFAULT_MAX_COORD_PUZZLE = 70  # Grid coordinates range from 0 to 70
SIMULATION_BYTE_COUNT_PUZZLE = 1024  # Simulate the first kilobyte (1024 bytes)

# Constants for the example provided in the problem description
EXAMPLE_MAX_COORD = 6  # Example grid coordinates 0 to 6
EXAMPLE_SIMULATION_BYTE_COUNT = 12  # Example simulates first 12 bytes
EXAMPLE_INPUT_STR = """"""5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1
1,2
5,5
2,5
6,5
1,4
0,4
6,4
1,1
6,1
1,0
0,5
1,6
2,0
""""""
EXPECTED_EXAMPLE_OUTPUT = 22


def parse_coordinates_from_string(input_str: str) -> List[Tuple[int, int]]:
    """"""
    Parses a string containing byte coordinates, one 'X,Y' per line.
    Each coordinate represents a cell that becomes corrupted.

    Args:
        input_str: The string data, with each line formatted as ""X,Y"".

    Returns:
        A list of (X, Y) integer tuples.
    """"""
    coords: List[Tuple[int, int]] = []
    for line in input_str.strip().split('\n'):
        line = line.strip()
        if not line:  # Skip empty lines
            continue
        try:
            x_str, y_str = line.split(',')
            coords.append((int(x_str.strip()), int(y_str.strip())))
        except ValueError:
            print(f""Warning: Could not parse coordinate line '{line}'"", file=sys.stderr)
    return coords


def parse_input_file(input_file_path: str) -> List[Tuple[int, int]]:
    """"""
    Reads byte coordinates from the specified file.

    Args:
        input_file_path: Path to the input file. Each line should be ""X,Y"".

    Returns:
        A list of (X, Y) integer tuples representing corrupted byte locations.
    """"""
    with open(input_file_path, 'r') as f:
        content = f.read()
    return parse_coordinates_from_string(content)


def find_shortest_path(
    all_corrupted_byte_coords: List[Tuple[int, int]],
    max_coord: int,
    num_bytes_to_simulate: int
) -> Optional[int]:
    """"""
    Finds the shortest path from (0,0) to (max_coord, max_coord) on a grid
    using Breadth-First Search (BFS). Cells corrupted by the first
    `num_bytes_to_simulate` bytes are considered impassable.

    Args:
        all_corrupted_byte_coords: A list of all (X,Y) coordinates of
                                   falling bytes, in the order they fall.
        max_coord: The maximum coordinate value for X and Y. The grid spans
                   from (0,0) to (max_coord, max_coord).
        num_bytes_to_simulate: The number of initial bytes from
                               `all_corrupted_byte_coords` to consider as corrupted.

    Returns:
        The minimum number of steps (path length) to reach the destination,
        or None if no path exists.
    """"""
    start_pos: Tuple[int, int] = (0, 0)
    end_pos: Tuple[int, int] = (max_coord, max_coord)

    blocked_cells: Set[Tuple[int, int]] = set()
    effective_bytes_to_simulate = min(num_bytes_to_simulate, len(all_corrupted_byte_coords))
    for i in range(effective_bytes_to_simulate):
        blocked_cells.add(all_corrupted_byte_coords[i])

    if start_pos in blocked_cells:
        return None

    if start_pos == end_pos:
        return 0

    queue: deque[Tuple[Tuple[int, int], int]] = deque([(start_pos, 0)])
    visited: Set[Tuple[int, int]] = {start_pos}
    moves: List[Tuple[int, int]] = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        current_pos, dist = queue.popleft()
        curr_x, curr_y = current_pos

        for dx, dy in moves:
            next_x, next_y = curr_x + dx, curr_y + dy
            next_pos = (next_x, next_y)

            if not (0 <= next_x <= max_coord and 0 <= next_y <= max_coord):
                continue
            if next_pos in blocked_cells:
                continue
            if next_pos in visited:
                continue

            if next_pos == end_pos:
                return dist + 1

            visited.add(next_pos)
            queue.append((next_pos, dist + 1))

    return None


def run_tests():
    """"""Runs tests, including the example from the problem description and edge cases.""""""
    print(""Running tests..."", file=sys.stderr)
    # Example from problem description
    example_coords = parse_coordinates_from_string(EXAMPLE_INPUT_STR)
    example_result = find_shortest_path(
        all_corrupted_byte_coords=example_coords,
        max_coord=EXAMPLE_MAX_COORD,
        num_bytes_to_simulate=EXAMPLE_SIMULATION_BYTE_COUNT
    )
    print(f""  Example result: {example_result}"", file=sys.stderr)
    assert example_result == EXPECTED_EXAMPLE_OUTPUT, f""Example test FAILED: Expected {EXPECTED_EXAMPLE_OUTPUT}, got {example_result}""
    print(""  Example test PASSED."", file=sys.stderr)

    # Test case: No path (target (1,0) is blocked on a 2x1 grid for path (0,0) -> (1,0))
    no_path_coords = [(1,0)] # Target (1,0) blocked
    no_path_result = find_shortest_path(no_path_coords, max_coord=1, num_bytes_to_simulate=1) # Target is (1,1) if max_coord=1 but here we simplify target as (1,0)
    # To test (0,0) to (1,0) path, max_coord_x=1, max_coord_y=0.
    # For simplicity, let's use a square grid (0,0) to (1,1), block (0,1) and (1,0) to isolate (0,0)
    isolated_coords = [(0,1), (1,0)]
    isolated_result = find_shortest_path(isolated_coords, max_coord=1, num_bytes_to_simulate=2)
    assert isolated_result is None, f""No path test (isolated start) FAILED: Expected None, got {isolated_result}""
    print(""  No path test (isolated start) PASSED."", file=sys.stderr)

    # Test case: Start is blocked
    start_blocked_coords = [(0,0)]
    start_blocked_result = find_shortest_path(start_blocked_coords, max_coord=1, num_bytes_to_simulate=1)
    assert start_blocked_result is None, f""Start blocked test FAILED: Expected None, got {start_blocked_result}""
    print(""  Start blocked test PASSED."", file=sys.stderr)

    # Test case: End is blocked (target (1,1) is blocked)
    end_blocked_coords = [(1,1)]
    end_blocked_result = find_shortest_path(end_blocked_coords, max_coord=1, num_bytes_to_simulate=1)
    assert end_blocked_result is None, f""End blocked test FAILED: Expected None, got {end_blocked_result}""
    print(""  End blocked test PASSED."", file=sys.stderr)

    # Test case: Empty grid (no blocked cells), path (0,0) to (1,1)
    empty_grid_result = find_shortest_path([], max_coord=1, num_bytes_to_simulate=0)
    assert empty_grid_result == 2, f""Empty grid test FAILED: Expected 2, got {empty_grid_result}""
    print(""  Empty grid test PASSED."", file=sys.stderr)

    # Test case: max_coord = 0 (start is end)
    zero_dim_result = find_shortest_path([], max_coord=0, num_bytes_to_simulate=0)
    assert zero_dim_result == 0, f""Zero dimension test FAILED: Expected 0, got {zero_dim_result}""
    print(""  Zero dimension test PASSED."", file=sys.stderr)

    # Test case: max_coord = 0, start (which is also end) is blocked
    zero_dim_blocked_result = find_shortest_path([(0,0)], max_coord=0, num_bytes_to_simulate=1)
    assert zero_dim_blocked_result is None, f""Zero dimension (blocked) test FAILED: Expected None, got {zero_dim_blocked_result}""
    print(""  Zero dimension (blocked) test PASSED."", file=sys.stderr)
    print(""All tests finished."", file=sys.stderr)


def main():
    """"""
    Main execution function. Sets up tests, parses input, solves the puzzle,
    and prints the result to standard output.
    """"""
    run_tests() # Run self-tests, output to stderr
    print(""-"" * 20, file=sys.stderr) # Separator

    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file_path]"", file=sys.stderr)
        print(""Error: Input file path not provided."", file=sys.stderr)
        sys.exit(1)

    input_file_path = sys.argv[1]

    try:
        parsed_data = parse_input_file(input_file_path)
    except FileNotFoundError:
        print(f""Error: Input file not found at '{input_file_path}'"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error parsing input file '{input_file_path}': {e}"", file=sys.stderr)
        sys.exit(1)

    if not parsed_data and SIMULATION_BYTE_COUNT_PUZZLE > 0:
        print(f""Warning: Input data from '{input_file_path}' is empty. ""
              f""Proceeding with no initially corrupted cells."", file=sys.stderr)

    solution = find_shortest_path(
        all_corrupted_byte_coords=parsed_data,
        max_coord=DEFAULT_MAX_COORD_PUZZLE,
        num_bytes_to_simulate=SIMULATION_BYTE_COUNT_PUZZLE
    )

    if solution is None:
        print(""-1"")
    else:
        print(solution)

if __name__ == ""__main__"":
    main()
"
18,system,gemini-2.5-pro-preview-05-06,True,888.7357442378998,"""""""
Advent of Code [Year] Day 18: RAM Run
Solution implementation based on the provided plan.
This program simulates byte corruption on a grid and finds the shortest
path from a start to an end point using Breadth-First Search (BFS).

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple, Set
import sys
from collections import deque

# Constants for the main problem
GRID_WIDTH = 71
GRID_HEIGHT = 71
START_POS = (0, 0)
END_POS = (70, 70)
NUM_CORRUPTED_BYTES = 1024

# Constants for the example test case from the problem description
EXAMPLE_GRID_WIDTH = 7
EXAMPLE_GRID_HEIGHT = 7
EXAMPLE_START_POS = (0, 0)
EXAMPLE_END_POS = (6, 6)
EXAMPLE_NUM_CORRUPTED_BYTES = 12
EXAMPLE_COORDS_STR = """"""5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1""""""
EXAMPLE_EXPECTED_OUTPUT = 22

def parse_input(input_file_path: str) -> List[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of (X,Y) coordinates.

    Args:
        input_file_path: Path to the input file. Each line should be ""X,Y"".

    Returns:
        A list of (X,Y) integer tuples representing corrupted coordinates.
    """"""
    coords: List[Tuple[int, int]] = []
    with open(input_file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                x_str, y_str = line.split(',')
                coords.append((int(x_str), int(y_str)))
            except ValueError:
                # As per typical AoC, malformed lines might indicate an issue
                # or could be skipped if the problem implies robustness to them.
                # Here, we print a warning and skip.
                print(f""Warning: Malformed line in input, skipping: '{line}'"", file=sys.stderr)
    return coords

def find_shortest_path(
    start_pos: Tuple[int, int],
    end_pos: Tuple[int, int],
    grid_width: int,
    grid_height: int,
    all_corrupted_coords_ordered: List[Tuple[int, int]],
    num_bytes_to_corrupt: int
) -> int:
    """"""
    Finds the shortest path from start_pos to end_pos on a grid using BFS.

    Args:
        start_pos: (X,Y) tuple for the starting position.
        end_pos: (X,Y) tuple for the target position.
        grid_width: The width of the grid (number of columns, X-dimension size).
                    Coordinates are 0 to grid_width-1.
        grid_height: The height of the grid (number of rows, Y-dimension size).
                     Coordinates are 0 to grid_height-1.
        all_corrupted_coords_ordered: A list of all (X,Y) coordinates that
                                      become corrupted, in order of corruption.
        num_bytes_to_corrupt: The number of initial coordinates from
                              all_corrupted_coords_ordered to consider as corrupted.

    Returns:
        The minimum number of steps to reach end_pos from start_pos.
        Returns -1 if no path exists, or if start/end positions are corrupted.
    """"""
    corrupted_cells: Set[Tuple[int, int]] = set()
    # Determine the actual corrupted cells based on the first num_bytes_to_corrupt
    for i in range(min(num_bytes_to_corrupt, len(all_corrupted_coords_ordered))):
        corrupted_cells.add(all_corrupted_coords_ordered[i])

    # Check if start or end positions are themselves corrupted, as per plan
    if start_pos in corrupted_cells:
        print(f""Debug: Start position {start_pos} is corrupted."", file=sys.stderr)
        return -1
    if end_pos in corrupted_cells:
        print(f""Debug: End position {end_pos} is corrupted."", file=sys.stderr)
        return -1

    queue = deque([(start_pos, 0)])  # Stores ((x, y), steps)
    visited: Set[Tuple[int, int]] = {start_pos}

    # Cardinal moves: (dx, dy) relative to (X,Y) or (col, row)
    # (0, 1)  -> Down (Y increases, e.g., row+1)
    # (0, -1) -> Up (Y decreases, e.g., row-1)
    # (1, 0)  -> Right (X increases, e.g., col+1)
    # (-1, 0) -> Left (X decreases, e.g., col-1)
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        (current_x, current_y), steps = queue.popleft()

        if (current_x, current_y) == end_pos:
            return steps

        for dx, dy in moves:
            next_x, next_y = current_x + dx, current_y + dy
            next_pos = (next_x, next_y)

            # Boundary Check: Ensure movement is within grid limits (0 to N-1)
            if not (0 <= next_x < grid_width and 0 <= next_y < grid_height):
                continue

            # Corruption Check: Ensure cell is not impassable
            if next_pos in corrupted_cells:
                continue

            # Visited Check: Ensure cell has not been visited already in this search
            if next_pos in visited:
                continue

            visited.add(next_pos)
            queue.append((next_pos, steps + 1))

    print(f""Debug: No path found from {start_pos} to {end_pos} with current obstacles."", file=sys.stderr)
    return -1 # No path found

def solve_part_one(parsed_data: List[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle using the main problem's parameters.

    Args:
        parsed_data: List of (X,Y) corrupted coordinates from input file.

    Returns:
        Solution for part one (minimum steps, or -1 if no path).
    """"""
    return find_shortest_path(
        START_POS,
        END_POS,
        GRID_WIDTH,
        GRID_HEIGHT,
        parsed_data,
        NUM_CORRUPTED_BYTES
    )

def run_tests():
    """"""Runs test cases to validate the implementation. Output is to stderr.""""""
    print(""Running example test case..."", file=sys.stderr)

    # Parse example coordinates from the multi-line string constant
    example_coords_list: List[Tuple[int, int]] = []
    for line in EXAMPLE_COORDS_STR.strip().split('\n'):
        line = line.strip()
        if not line: continue
        try:
            x_str, y_str = line.split(',')
            example_coords_list.append((int(x_str), int(y_str)))
        except ValueError:
            print(f""Error parsing example coordinates: '{line}'"", file=sys.stderr)
            # This should not happen for hardcoded examples
            return # Abort tests

    print(f""Test Case: Simulating {EXAMPLE_NUM_CORRUPTED_BYTES} bytes on a ""
          f""{EXAMPLE_GRID_WIDTH}x{EXAMPLE_GRID_HEIGHT} grid."", file=sys.stderr)
    print(f""Start: {EXAMPLE_START_POS}, End: {EXAMPLE_END_POS}"", file=sys.stderr)

    result = find_shortest_path(
        EXAMPLE_START_POS,
        EXAMPLE_END_POS,
        EXAMPLE_GRID_WIDTH,
        EXAMPLE_GRID_HEIGHT,
        example_coords_list,
        EXAMPLE_NUM_CORRUPTED_BYTES
    )

    print(f""Test Case Result: {result}"", file=sys.stderr)
    assert result == EXAMPLE_EXPECTED_OUTPUT, \
        f""Test Case Failed: Expected {EXAMPLE_EXPECTED_OUTPUT}, got {result}""
    print(""Example test case passed!"", file=sys.stderr)


def main():
    """"""Main execution entry point. Handles argument parsing, calls solver, and prints result.""""""
    # Run tests before processing actual input. Test output goes to stderr.
    run_tests()

    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"", file=sys.stderr)
        print(""Error: Input file path not provided."", file=sys.stderr)
        sys.exit(1) # Exit with an error code if no input file given

    input_file = sys.argv[1]

    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        # Catch other potential errors during parsing, e.g., permission issues
        print(f""Error parsing input file '{input_file}': {e}"", file=sys.stderr)
        sys.exit(1)

    part_one_solution = solve_part_one(parsed_data)

    # As per AoC, ONLY PRINT THE FINAL RESULT for the part to STDOUT.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
19,single-model,gemini-2.5-pro-preview-05-06,False,140.01181030273438,"""""""
Advent of Code Day 19: Linen Layout
Solution for determining how many designs are possible to make
from a given set of towel patterns.

This solution uses dynamic programming. For each design, it determines
if the design can be formed by concatenating available towel patterns.
dp[i] is True if the prefix of the design of length i can be formed.
dp[0] is True (empty prefix).
To compute dp[k], we check if there's a pattern P such that
design ends with P (i.e., design[k-len(P):k] == P) and
dp[k-len(P)] is True.
Alternatively, using a forward DP (which is implemented): if dp[j] is True,
and a pattern P matches design[j:j+len(P)], then dp[j+len(P)] can be True.

Usage: python3 solution.py [input_file]
       python3 solution.py example (to run example tests only)
""""""
import sys
from typing import List, Tuple

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file.

    The input consists of a line of comma-separated towel patterns,
    a blank line, and then multiple lines each representing a desired design.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - A list of available towel patterns (strings).
            - A list of desired designs (strings).
    """"""
    try:
        with open(input_file, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except IOError as e:
        print(f""Error reading file '{input_file}': {e}"", file=sys.stderr)
        sys.exit(1)

    parts = content.split('\n\n', 1)

    if not parts:
        # File is empty or malformed in a way split fails (e.g. just newlines)
        print(f""Warning: Input file '{input_file}' appears to be empty or malformed."", file=sys.stderr)
        return [], []

    patterns_line = parts[0].strip()
    # Filter out empty strings that might result from ""a,,b"" or trailing commas.
    available_patterns = [p for p in patterns_line.split(',') if p]

    designs: List[str] = []
    if len(parts) > 1 and parts[1].strip():
        # Filter out empty lines that might be in the designs block.
        designs = [d for d in parts[1].strip().splitlines() if d]

    if not available_patterns and any(d for d in designs if d):
        # If there are non-empty designs but no patterns.
        print(""Warning: No patterns provided in the input, but designs are present."", file=sys.stderr)

    return available_patterns, designs

def can_form_design(design: str, patterns: List[str]) -> bool:
    """"""Determine if a given design can be formed using the available patterns.

    This function uses dynamic programming. dp[i] is True if the prefix of
    the design of length 'i' can be formed.

    Args:
        design: The design string to check.
        patterns: A list of available towel patterns.

    Returns:
        True if the design can be formed, False otherwise.
    """"""
    n = len(design)
    if n == 0: # An empty design is considered formable (by using no towels).
        return True

    if not patterns: # If no patterns are available, no non-empty design can be formed.
        return False

    # dp[i] will be True if design[:i] (prefix of length i) can be formed.
    dp = [False] * (n + 1)
    dp[0] = True  # Base case: an empty prefix can always be formed.

    # Using the ""forward"" DP approach:
    # If dp[i] is True (meaning design[:i] can be formed),
    # try to extend it with each pattern.
    for i in range(n + 1):
        if dp[i]:
            for pattern in patterns:
                pattern_len = len(pattern)
                # Patterns should be non-empty (guaranteed by parse_input filtering)
                # but as a safeguard for direct calls to can_form_design:
                if pattern_len == 0:
                    continue

                # Check if pattern fits and matches at the current position
                if i + pattern_len <= n and design[i : i + pattern_len] == pattern:
                    dp[i + pattern_len] = True
                    # Optimization: if we have already successfully formed the full design,
                    # we can mark dp[n] and potentially break early if only dp[n] is needed.
                    # However, other dp[k] where k < n might still be needed by later iterations of i.
                    # If dp[n] is set, we don't need to check more patterns for this i for dp[n],
                    # but other dp[i+pattern_len] might be set. So, this inner break isn't generally useful.

    return dp[n]

def solve_part_one(parsed_data: Tuple[List[str], List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Counts how many of the desired designs can be formed using the
    available towel patterns.

    Args:
        parsed_data: A tuple containing the list of patterns and list of designs.

    Returns:
        The number of designs that are possible.
    """"""
    patterns, designs = parsed_data

    possible_designs_count = 0
    for design_str in designs:
        if can_form_design(design_str, patterns):
            possible_designs_count += 1

    return possible_designs_count

def run_example_tests():
    """"""Runs tests against the examples provided in the problem description.""""""
    print(""Running example tests..."", file=sys.stderr)

    example_patterns = [""r"", ""wr"", ""b"", ""g"", ""bwu"", ""rb"", ""gb"", ""br""]
    example_cases = [
        (""brwrr"", True),
        (""bggr"", True),
        (""gbbr"", True),
        (""rrbgbr"", True),
        (""ubwu"", False),
        (""bwurrg"", True),
        (""brgr"", True),
        (""bbrgwb"", False),
    ]

    all_tests_passed = True
    for i, (design_str, expected_result) in enumerate(example_cases):
        actual_result = can_form_design(design_str, example_patterns)
        if actual_result == expected_result:
            print(f""  Test case {i+1} ('{design_str}'): PASSED"", file=sys.stderr)
        else:
            print(f""  Test case {i+1} ('{design_str}'): FAILED. Expected {expected_result}, got {actual_result}"", file=sys.stderr)
            all_tests_passed = False

    example_designs_list = [case[0] for case in example_cases]
    expected_total_possible = 6 # As per problem statement: ""6 of the eight designs are possible""

    actual_total_possible = 0
    # Re-use solve_part_one logic for this aggregate check if desired, or manual loop:
    for design_str in example_designs_list:
        if can_form_design(design_str, example_patterns):
            actual_total_possible +=1

    if actual_total_possible == expected_total_possible:
        print(f""  Example aggregate count: PASSED (got {actual_total_possible}, expected {expected_total_possible})"", file=sys.stderr)
    else:
        print(f""  Example aggregate count: FAILED. Expected {expected_total_possible}, got {actual_total_possible}"", file=sys.stderr)
        all_tests_passed = False

    if all_tests_passed:
        print(""All example tests PASSED."", file=sys.stderr)
    else:
        print(""Some example tests FAILED."", file=sys.stderr)
    print(""-"" * 30, file=sys.stderr)


if __name__ == ""__main__"":
    # Run example tests first, as per common AoC practice and problem requirements.
    run_example_tests()

    # Check command line arguments
    if len(sys.argv) < 2:
        print(""No input file provided. Example tests complete (run at script start)."", file=sys.stderr)
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""       python3 solution.py example (to re-run example tests only and exit)"", file=sys.stderr)
        sys.exit(1) # Exit indicating usage error or lack of input for solving

    input_file_arg = sys.argv[1]

    if input_file_arg.lower() == ""example"":
        # 'example' keyword means only tests are run (which they already have been)
        print(""Example tests complete. To solve an input, provide its path instead of 'example'."", file=sys.stderr)
        sys.exit(0) # Successfully indicated tests ran

    # Proceed to parse and solve the puzzle input file
    parsed_data = parse_input(input_file_arg)
    # parse_input handles its own file errors (FileNotFound, IOError) and exits if critical

    solution = solve_part_one(parsed_data)

    # Print the final solution for part one to STDOUT
    print(solution)
"
19,system,gemini-2.5-pro-preview-05-06,True,985.4911658763885,"""""""
Advent of Code [Year] Day 19: Linen Layout
Solution implementation based on the provided plan.

This script determines how many desired towel designs can be formed by
concatenating available towel patterns. It uses dynamic programming to check
each design.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Tuple

def parse_input_from_string(content: str) -> Tuple[List[str], List[str]]:
    """"""Parses the puzzle input from a string into available patterns and desired designs.

    Args:
        content: The raw string content of the input.

    Returns:
        A tuple containing:
            - A list of available towel patterns (strings).
            - A list of desired designs (strings).
    """"""
    # Normalize content (e.g. if from Windows, convert CRLF to LF) and strip leading/trailing whitespace.
    # Actual newlines are expected, not literal '\n' characters.
    normalized_content = content.replace('\r\n', '\n').strip()

    # Split the content into two parts: patterns part and designs part, separated by a blank line.
    # A blank line in parsing means two consecutive newlines \n\n.
    parts = normalized_content.split('\n\n', 1)

    available_patterns_line = """"
    if parts: # Handle case where content might be empty or only whitespace leading to empty parts[0]
        available_patterns_line = parts[0]

    # Parse available patterns: split by comma, strip whitespace from each, filter out empty strings.
    available_patterns_list = [p.strip() for p in available_patterns_line.split(',') if p.strip()]

    desired_designs_list: List[str] = []
    # If there is a second part (after the blank line) and it's not just whitespace.
    if len(parts) > 1 and parts[1].strip():
        desired_designs_lines_str = parts[1]
        # Parse desired designs: split by newline, strip whitespace from each, filter out empty strings.
        desired_designs_list = [line.strip() for line in desired_designs_lines_str.split('\n') if line.strip()]

    return available_patterns_list, desired_designs_list

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into available patterns and desired designs.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - A list of available towel patterns (strings).
            - A list of desired designs (strings).
    """"""
    with open(input_file, 'r') as f:
        content = f.read()
    return parse_input_from_string(content)

def can_form_design(design_string: str, patterns_list: List[str]) -> bool:
    """"""Determines if a design_string can be formed by concatenating one or more patterns from patterns_list.

    Args:
        design_string: The target design string to check.
        patterns_list: The list of available towel patterns.

    Returns:
        True if design_string can be formed, False otherwise.
    """"""
    n = len(design_string)

    # Per plan (Step 3.2.2) and problem constraint ""one or more available towel patterns"":
    # An empty design string cannot be formed by one or more patterns.
    if n == 0:
        return False

    # dp[i] will be True if the prefix design_string[0...i-1] (of length i) is formable.
    # Initialize dp[0] = True (representing that an empty prefix can be formed by zero patterns).
    # All other dp elements are initialized to False.
    dp = [False] * (n + 1)
    dp[0] = True

    # Iterate i from 1 to n (inclusive). i represents the current length of the prefix of design_string.
    for i in range(1, n + 1):
        for current_pattern in patterns_list:
            pattern_len = len(current_pattern)

            # Per plan (Step 3.2.4): Skip empty patterns.
            # (Our parsing already filters out empty patterns, but this is a safeguard).
            if pattern_len == 0:
                continue

            # Check if:
            # 1. The current prefix design_string[0...i-1] is long enough to end with current_pattern (i.e., i >= pattern_len).
            # 2. The sub-prefix design_string[0...i-pattern_len-1] was formable (i.e., dp[i - pattern_len] is True).
            # 3. The suffix of design_string[0...i-1] of length pattern_len (which is design_string[i-pattern_len : i])
            #    matches current_pattern.
            if i >= pattern_len and dp[i - pattern_len]:
                if design_string[i - pattern_len : i] == current_pattern:
                    dp[i] = True
                    # Found a way to form design_string[0...i-1], so break from inner loop (patterns_list)
                    # and move to check the next prefix length (i+1).
                    break

    # After filling the dp table, dp[n] holds whether the entire design_string can be formed.
    return dp[n]

def solve_part_one(parsed_data: Tuple[List[str], List[str]]) -> int:
    """"""Solve part one of the puzzle: Count how many desired designs are formable.

    Args:
        parsed_data: A tuple containing (available_patterns_list, desired_designs_list).

    Returns:
        The total count of desired designs that can be formed.
    """"""
    available_patterns_list, desired_designs_list = parsed_data

    formable_designs_count = 0
    for design in desired_designs_list:
        if can_form_design(design, available_patterns_list):
            formable_designs_count += 1

    return formable_designs_count

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        # Run example from problem description if no input file specified for easy testing.
        # Output for this will go to stderr, and the final answer to stdout (if an answer is generated).
        print(""No input file provided. Running internal example from problem description:"", file=sys.stderr)
        example_input_content = """"""r,wr,b,g,bwu,rb,gb,br\n\nbrwrr\nbggr\ngbbr\nrrbgbr\nubwu\nbwurrg\nbrgr\nbbrgwb""""""
        example_expected_output = 6

        # Must use parse_input_from_string for multi-line string literal
        example_parsed_data = parse_input_from_string(example_input_content.replace('\\n', '\n'))
        example_solution = solve_part_one(example_parsed_data)

        if example_solution == example_expected_output:
            print(f""Internal example PASSED: Expected {example_expected_output}, Got {example_solution}"", file=sys.stderr)
        else:
            print(f""Internal example FAILED: Expected {example_expected_output}, Got {example_solution}"", file=sys.stderr)
        # To adhere to ""only print result to STDOUT"", print the example solution to STDOUT too.
        # Or, more strictly, exit if no file given. The current setup is for convenience.
        # For strict AoC, if no file, exit(1). Let's adjust for that.
        # print(f""Solution for internal example: {example_solution}"") # This would be to STDOUT.
        sys.exit(1) # Exit if no file provided, after printing usage and example status.

    input_file = sys.argv[1]

    # Parse input from file
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error parsing input file: {e}"", file=sys.stderr)
        sys.exit(1)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT to stdout for the actual puzzle input
    print(part_one_solution)

    # Optional: Run test cases provided in the prompt JSON (if any)
    # This part should be conditional and its output should go to stderr.
    # test_cases_raw_str = ""..."" # This would be loaded from the agent's input JSON
    # Example test_cases_raw_str is hardcoded here for demonstration.
    test_cases_raw_str = ""[[ \""r,wr,b,g,bwu,rb,gb,br\\n\\nbrwrr\\nbggr\\ngbbr\\nrrbgbr\\nubwu\\nbwurrg\\nbrgr\\nbbrgwb\"", \""6\"" ]]""
    if test_cases_raw_str:
        try:
            import json # Import locally as it's only for tests
            all_tests = json.loads(test_cases_raw_str)
            if not isinstance(all_tests, list):
                 print(""Warning: Test cases JSON is not a list."", file=sys.stderr)
                 all_tests = [] # Avoid error later

            if all_tests: # Proceed only if there are tests after loading
                print(""\nRunning provided example tests from JSON:"", file=sys.stderr)
            for i, test_case in enumerate(all_tests):
                if not (isinstance(test_case, list) and len(test_case) == 2):
                    print(f""Skipping malformed test case {i+1} (not a list of 2 elements): {test_case}"", file=sys.stderr)
                    continue

                test_input_str, expected_output_str = test_case
                if not (isinstance(test_input_str, str) and isinstance(expected_output_str, str)):
                    print(f""Skipping malformed test case {i+1} (elements not (str, str)): {test_case}"", file=sys.stderr)
                    continue

                print(f""Running example test {i+1} from JSON..."", file=sys.stderr)
                # parse_input_from_string expects actual newlines; json.loads handles '\n' in strings.
                test_parsed_data = parse_input_from_string(test_input_str)
                test_solution = solve_part_one(test_parsed_data)

                if str(test_solution) == expected_output_str:
                    print(f""Example test {i+1} PASSED: Expected {expected_output_str}, Got {test_solution}"", file=sys.stderr)
                else:
                    print(f""Example test {i+1} FAILED: Expected {expected_output_str}, Got {test_solution}"", file=sys.stderr)
        except ImportError:
            print(""Warning: 'json' module not available, skipping JSON test cases."", file=sys.stderr)
        except Exception as e:
            print(f""Error processing JSON test cases: {e}"", file=sys.stderr)

if __name__ == ""__main__"":
    main()
"
20,single-model,gemini-2.5-pro-preview-05-06,False,193.5400779247284,threw-error
21,single-model,gemini-2.5-pro-preview-05-06,False,298.122789144516,...
21,system,gemini-2.5-pro-preview-05-06,False,2455.1510531902313,threw-error
21,system,gemini-2.5-pro-preview-05-06,True,2455.1520466804504,"""""""
Advent of Code [Year] Day 19: Linen Layout
Solution implementation based on the provided plan.

This script determines how many desired towel designs can be formed by
concatenating available towel patterns. It uses dynamic programming to check
each design.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Tuple

def parse_input_from_string(content: str) -> Tuple[List[str], List[str]]:
    """"""Parses the puzzle input from a string into available patterns and desired designs.

    Args:
        content: The raw string content of the input.

    Returns:
        A tuple containing:
            - A list of available towel patterns (strings).
            - A list of desired designs (strings).
    """"""
    # Normalize content (e.g. if from Windows, convert CRLF to LF) and strip leading/trailing whitespace.
    # Actual newlines are expected, not literal '\n' characters.
    normalized_content = content.replace('\r\n', '\n').strip()

    # Split the content into two parts: patterns part and designs part, separated by a blank line.
    # A blank line in parsing means two consecutive newlines \n\n.
    parts = normalized_content.split('\n\n', 1)

    available_patterns_line = """"
    if parts: # Handle case where content might be empty or only whitespace leading to empty parts[0]
        available_patterns_line = parts[0]

    # Parse available patterns: split by comma, strip whitespace from each, filter out empty strings.
    available_patterns_list = [p.strip() for p in available_patterns_line.split(',') if p.strip()]

    desired_designs_list: List[str] = []
    # If there is a second part (after the blank line) and it's not just whitespace.
    if len(parts) > 1 and parts[1].strip():
        desired_designs_lines_str = parts[1]
        # Parse desired designs: split by newline, strip whitespace from each, filter out empty strings.
        desired_designs_list = [line.strip() for line in desired_designs_lines_str.split('\n') if line.strip()]

    return available_patterns_list, desired_designs_list

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into available patterns and desired designs.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - A list of available towel patterns (strings).
            - A list of desired designs (strings).
    """"""
    with open(input_file, 'r') as f:
        content = f.read()
    return parse_input_from_string(content)

def can_form_design(design_string: str, patterns_list: List[str]) -> bool:
    """"""Determines if a design_string can be formed by concatenating one or more patterns from patterns_list.

    Args:
        design_string: The target design string to check.
        patterns_list: The list of available towel patterns.

    Returns:
        True if design_string can be formed, False otherwise.
    """"""
    n = len(design_string)

    # Per plan (Step 3.2.2) and problem constraint ""one or more available towel patterns"":
    # An empty design string cannot be formed by one or more patterns.
    if n == 0:
        return False

    # dp[i] will be True if the prefix design_string[0...i-1] (of length i) is formable.
    # Initialize dp[0] = True (representing that an empty prefix can be formed by zero patterns).
    # All other dp elements are initialized to False.
    dp = [False] * (n + 1)
    dp[0] = True

    # Iterate i from 1 to n (inclusive). i represents the current length of the prefix of design_string.
    for i in range(1, n + 1):
        for current_pattern in patterns_list:
            pattern_len = len(current_pattern)

            # Per plan (Step 3.2.4): Skip empty patterns.
            # (Our parsing already filters out empty patterns, but this is a safeguard).
            if pattern_len == 0:
                continue

            # Check if:
            # 1. The current prefix design_string[0...i-1] is long enough to end with current_pattern (i.e., i >= pattern_len).
            # 2. The sub-prefix design_string[0...i-pattern_len-1] was formable (i.e., dp[i - pattern_len] is True).
            # 3. The suffix of design_string[0...i-1] of length pattern_len (which is design_string[i-pattern_len : i])
            #    matches current_pattern.
            if i >= pattern_len and dp[i - pattern_len]:
                if design_string[i - pattern_len : i] == current_pattern:
                    dp[i] = True
                    # Found a way to form design_string[0...i-1], so break from inner loop (patterns_list)
                    # and move to check the next prefix length (i+1).
                    break

    # After filling the dp table, dp[n] holds whether the entire design_string can be formed.
    return dp[n]

def solve_part_one(parsed_data: Tuple[List[str], List[str]]) -> int:
    """"""Solve part one of the puzzle: Count how many desired designs are formable.

    Args:
        parsed_data: A tuple containing (available_patterns_list, desired_designs_list).

    Returns:
        The total count of desired designs that can be formed.
    """"""
    available_patterns_list, desired_designs_list = parsed_data

    formable_designs_count = 0
    for design in desired_designs_list:
        if can_form_design(design, available_patterns_list):
            formable_designs_count += 1

    return formable_designs_count

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        # Run example from problem description if no input file specified for easy testing.
        # Output for this will go to stderr, and the final answer to stdout (if an answer is generated).
        print(""No input file provided. Running internal example from problem description:"", file=sys.stderr)
        example_input_content = """"""r,wr,b,g,bwu,rb,gb,br\n\nbrwrr\nbggr\ngbbr\nrrbgbr\nubwu\nbwurrg\nbrgr\nbbrgwb""""""
        example_expected_output = 6

        # Must use parse_input_from_string for multi-line string literal
        example_parsed_data = parse_input_from_string(example_input_content.replace('\\n', '\n'))
        example_solution = solve_part_one(example_parsed_data)

        if example_solution == example_expected_output:
            print(f""Internal example PASSED: Expected {example_expected_output}, Got {example_solution}"", file=sys.stderr)
        else:
            print(f""Internal example FAILED: Expected {example_expected_output}, Got {example_solution}"", file=sys.stderr)
        # To adhere to ""only print result to STDOUT"", print the example solution to STDOUT too.
        # Or, more strictly, exit if no file given. The current setup is for convenience.
        # For strict AoC, if no file, exit(1). Let's adjust for that.
        # print(f""Solution for internal example: {example_solution}"") # This would be to STDOUT.
        sys.exit(1) # Exit if no file provided, after printing usage and example status.

    input_file = sys.argv[1]

    # Parse input from file
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error parsing input file: {e}"", file=sys.stderr)
        sys.exit(1)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT to stdout for the actual puzzle input
    print(part_one_solution)

    # Optional: Run test cases provided in the prompt JSON (if any)
    # This part should be conditional and its output should go to stderr.
    # test_cases_raw_str = ""..."" # This would be loaded from the agent's input JSON
    # Example test_cases_raw_str is hardcoded here for demonstration.
    test_cases_raw_str = ""[[ \""r,wr,b,g,bwu,rb,gb,br\\n\\nbrwrr\\nbggr\\ngbbr\\nrrbgbr\\nubwu\\nbwurrg\\nbrgr\\nbbrgwb\"", \""6\"" ]]""
    if test_cases_raw_str:
        try:
            import json # Import locally as it's only for tests
            all_tests = json.loads(test_cases_raw_str)
            if not isinstance(all_tests, list):
                 print(""Warning: Test cases JSON is not a list."", file=sys.stderr)
                 all_tests = [] # Avoid error later

            if all_tests: # Proceed only if there are tests after loading
                print(""\nRunning provided example tests from JSON:"", file=sys.stderr)
            for i, test_case in enumerate(all_tests):
                if not (isinstance(test_case, list) and len(test_case) == 2):
                    print(f""Skipping malformed test case {i+1} (not a list of 2 elements): {test_case}"", file=sys.stderr)
                    continue

                test_input_str, expected_output_str = test_case
                if not (isinstance(test_input_str, str) and isinstance(expected_output_str, str)):
                    print(f""Skipping malformed test case {i+1} (elements not (str, str)): {test_case}"", file=sys.stderr)
                    continue

                print(f""Running example test {i+1} from JSON..."", file=sys.stderr)
                # parse_input_from_string expects actual newlines; json.loads handles '\n' in strings.
                test_parsed_data = parse_input_from_string(test_input_str)
                test_solution = solve_part_one(test_parsed_data)

                if str(test_solution) == expected_output_str:
                    print(f""Example test {i+1} PASSED: Expected {expected_output_str}, Got {test_solution}"", file=sys.stderr)
                else:
                    print(f""Example test {i+1} FAILED: Expected {expected_output_str}, Got {test_solution}"", file=sys.stderr)
        except ImportError:
            print(""Warning: 'json' module not available, skipping JSON test cases."", file=sys.stderr)
        except Exception as e:
            print(f""Error processing JSON test cases: {e}"", file=sys.stderr)

if __name__ == ""__main__"":
    main()
"
22,single-model,gemini-2.5-pro-preview-05-06,True,197.26499581336975,"""""""
Advent of Code [Advent of Code Year] Day 22: Monkey Market
Solution implementation for Day 22 of Advent of Code.

This script simulates a pseudorandom secret number generation process for multiple buyers.
Each buyer starts with an initial secret number. The generation process involves three steps,
each consisting of an arithmetic operation (multiply/divide), a bitwise XOR mix, and a modulo prune.
The goal is to find the 2000th generated secret for each buyer and sum these values.

Usage: python3 solution.py [input_file]
       python3 solution.py --test (to run example tests)
""""""
from typing import List
import sys

# Constants for the generation process
MULTIPLIER_1: int = 64
DIVISOR_2: int = 32
MULTIPLIER_3: int = 2048
MODULO_VALUE: int = 16777216  # 2^24

# Constants for the problem
NUM_ITERATIONS: int = 2000

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of initial secret numbers.

    Args:
        input_file: Path to the input file. Each line should contain an integer.

    Returns:
        A list of initial secret numbers.
    """"""
    initial_secrets: List[int] = []
    with open(input_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if line:  # Ensure not an empty line
                try:
                    initial_secrets.append(int(line))
                except ValueError:
                    print(f""Warning: Could not parse line {line_num} ('{line}') as integer. Skipping."", file=sys.stderr)
    return initial_secrets

def _mix(secret: int, value: int) -> int:
    """"""Mixes a value into the secret number using bitwise XOR.""""""
    return secret ^ value

def _prune(secret: int) -> int:
    """"""Prunes the secret number using modulo operation.""""""
    return secret % MODULO_VALUE

def generate_next_secret(current_secret: int) -> int:
    """"""Generates the next secret number from the current one using the defined 3-step process.

    Args:
        current_secret: The current secret number.

    Returns:
        The next secret number in the sequence.
    """"""
    secret = current_secret

    # Step 1: Multiply by MULTIPLIER_1, mix, prune
    # ""Calculate the result of multiplying the secret number by 64.
    #  Then, mix this result into the secret number. Finally, prune the secret number.""
    op_result_1 = secret * MULTIPLIER_1
    secret = _mix(secret, op_result_1)
    secret = _prune(secret)

    # Step 2: Divide by DIVISOR_2, mix, prune
    # ""Calculate the result of dividing the secret number by 32. Round the result down...
    #  Then, mix this result into the secret number. Finally, prune the secret number.""
    op_result_2 = secret // DIVISOR_2  # Integer division for rounding down
    secret = _mix(secret, op_result_2)
    secret = _prune(secret)

    # Step 3: Multiply by MULTIPLIER_3, mix, prune
    # ""Calculate the result of multiplying the secret number by 2048.
    #  Then, mix this result into the secret number. Finally, prune the secret number.""
    op_result_3 = secret * MULTIPLIER_3
    secret = _mix(secret, op_result_3)
    secret = _prune(secret)

    return secret

def simulate_n_secrets(initial_secret: int, n: int) -> int:
    """"""Simulates n generations of secret numbers.

    Args:
        initial_secret: The starting secret number.
        n: The number of generations to simulate.

    Returns:
        The n-th generated secret number.
    """"""
    secret = initial_secret
    for _ in range(n):
        secret = generate_next_secret(secret)
    return secret

def solve_part_one(initial_secrets: List[int]) -> int:
    """"""Solves the puzzle by simulating and summing the 2000th secret for each buyer.

    Args:
        initial_secrets: A list of initial secret numbers for each buyer.

    Returns:
        The sum of the 2000th secret number generated by each buyer.
    """"""
    total_sum_of_2000th_secrets = 0
    if not initial_secrets:
        return 0

    for i, secret_seed in enumerate(initial_secrets):
        final_secret = simulate_n_secrets(secret_seed, NUM_ITERATIONS)
        total_sum_of_2000th_secrets += final_secret
        # Debug print for progress on large inputs, can be commented out
        # if (i + 1) % 100 == 0:
        #     print(f""Processed {i+1}/{len(initial_secrets)} buyers..."", file=sys.stderr)

    return total_sum_of_2000th_secrets

def run_tests():
    """"""Runs tests based on examples provided in the problem description.""""""
    print(""Running example tests for generate_next_secret (123 sequence):"", file=sys.stderr)
    s_123 = 123
    example_123_sequence_from_problem = [
        15887950, 16495136, 527345, 704524, 1553684,
        12683156, 11100544, 12249484, 7753432, 5908254
    ]
    print(""  Sequence for 123 (calculated vs problem's example values):"", file=sys.stderr)
    for i in range(10):
        s_123_calc = generate_next_secret(s_123 if i == 0 else s_123_calc) # Use s_123 for first, then chain
        problem_example_val = example_123_sequence_from_problem[i]
        print(f""    Step {i+1}: Initial={(s_123 if i == 0 else example_123_sequence_from_problem[i-1])}, Calculated={s_123_calc}, Problem's Example={problem_example_val}"", file=sys.stderr)
        if s_123_calc != problem_example_val:
            print(f""      NOTE: Mismatch for 123 sequence at step {i+1}. This might be an issue with the problem's specific 123-sequence example or my interpretation."", file=sys.stderr)

    print(""\nRunning CRITICAL example tests for N=2000 iterations:"", file=sys.stderr)
    example_initial_secrets = [1, 10, 100, 2024]
    expected_2000th_secrets = [8685429, 4700978, 15273692, 8667524]

    calculated_sum_for_examples = 0
    all_critical_tests_passed = True

    for i, initial_secret_val in enumerate(example_initial_secrets):
        result_2000th = simulate_n_secrets(initial_secret_val, NUM_ITERATIONS)
        calculated_sum_for_examples += result_2000th
        expected_val = expected_2000th_secrets[i]
        print(f""  Initial: {initial_secret_val}, 2000th: Calculated={result_2000th}, Expected={expected_val}"", file=sys.stderr)
        if result_2000th != expected_val:
            print(f""    ERROR: CRITICAL MISMATCH for initial_secret {initial_secret_val}! Expected {expected_val}, got {result_2000th}"", file=sys.stderr)
            all_critical_tests_passed = False

    expected_total_sum = sum(expected_2000th_secrets)
    print(f""Example sum: Calculated={calculated_sum_for_examples}, Expected={expected_total_sum}"", file=sys.stderr)
    if calculated_sum_for_examples != expected_total_sum:
        print(f""    ERROR: CRITICAL MISMATCH for total sum! Expected {expected_total_sum}, got {calculated_sum_for_examples}"", file=sys.stderr)
        all_critical_tests_passed = False

    if all_critical_tests_passed:
        print(""All critical N=2000 example tests PASSED."", file=sys.stderr)
    else:
        print(""One or more critical N=2000 example tests FAILED. The solution might be incorrect."", file=sys.stderr)

def main():
    """"""Main execution function.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file] OR python3 solution.py --test"", file=sys.stderr)
        print(""No input file provided. Running tests by default."", file=sys.stderr)
        run_tests()
        return

    input_arg = sys.argv[1]

    if input_arg == ""--test"":
        run_tests()
        return

    input_file = input_arg
    try:
        parsed_data = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    if not parsed_data:
        # If file was specified but was empty or all lines unparseable
        print(f""No valid data parsed from input file '{input_file}'. Result is 0."", file=sys.stderr)
        print(0) # Output 0 if no data
        return

    # Solve the puzzle
    solution = solve_part_one(parsed_data)

    # Print the solution for Part One
    # Per instruction: ONLY PRINT THE RESULT, NO OTHER TEXT to STDOUT
    print(solution)

if __name__ == ""__main__"":
    main()
"
22,system,gemini-2.5-pro-preview-05-06,True,990.016087770462,"""""""
Advent of Code [Year] Day 22: Monkey Market
Solution implementation based on the provided plan.

Each buyer's secret number evolves via a three-step process:
1. Multiply by 64, XOR with secret, prune (modulo 16777216).
2. Integer divide by 32, XOR with secret, prune.
3. Multiply by 2048, XOR with secret, prune.
This process is repeated 2000 times for each initial secret number.
The goal is to sum the 2000th generated secret number for all buyers.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List

# Constants from the problem description and plan
MODULUS: int = 16777216  # 2^24, for pruning
NUM_ITERATIONS: int = 2000 # Number of times to apply transformation for each initial secret

def transform_secret(secret_num: int) -> int:
    """"""
    Applies one full three-step pseudorandom generation process to a secret number.

    Args:
        secret_num: The current secret number.

    Returns:
        The new secret number after one full transformation sequence.
    """"""
    current_s = secret_num

    # Step 1: Multiply by 64, XOR, Prune
    # ""Calculate result1 = s * 64. Update s by s = (s XOR result1). Then update s by s = s % 16777216.""
    result1 = current_s * 64
    current_s = current_s ^ result1
    current_s = current_s % MODULUS

    # Step 2: Divide by 32 (floor), XOR, Prune
    # ""Calculate result2 = floor(s / 32). Update s by s = (s XOR result2). Then update s by s = s % 16777216.""
    result2 = current_s // 32  # Integer division for floor
    current_s = current_s ^ result2
    current_s = current_s % MODULUS

    # Step 3: Multiply by 2048, XOR, Prune
    # ""Calculate result3 = s * 2048. Update s by s = (s XOR result3). Then update s by s = s % 16777216.""
    result3 = current_s * 2048
    current_s = current_s ^ result3
    current_s = current_s % MODULUS

    return current_s

def parse_input(input_file_path: str) -> List[int]:
    """"""
    Parses the puzzle input file. Each line is expected to contain an initial secret number.

    Args:
        input_file_path: The path to the input file.

    Returns:
        A list of integers, where each integer is an initial secret number.
        Returns an empty list if the file is empty or contains no valid numbers.
        Exits if the file is not found.
    """"""
    initial_secrets: List[int] = []
    try:
        with open(input_file_path, 'r') as f:
            for line in f:
                stripped_line = line.strip()
                if stripped_line:  # Process only non-empty lines
                    try:
                        initial_secrets.append(int(stripped_line))
                    except ValueError:
                        # According to the plan, assume valid integer inputs.
                        # For robustness, this will print a warning for non-integer lines.
                        print(f""Warning: Line '{stripped_line}' in file '{input_file_path}' is not a valid integer. Skipping."", file=sys.stderr)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file_path}' not found."", file=sys.stderr)
        sys.exit(1) # Standard practice to exit if input file is missing

    return initial_secrets

def solve_puzzle(initial_secrets: List[int]) -> int:
    """"""
    Simulates the secret number generation for each initial secret and sums the 2000th results.

    Args:
        initial_secrets: A list of initial secret numbers.

    Returns:
        The sum of the 2000th new secret number generated by each buyer.
        Returns 0 if the list of initial_secrets is empty.
    """"""
    total_sum_of_final_secrets: int = 0

    for secret_val in initial_secrets:
        current_secret_for_buyer = secret_val
        for _ in range(NUM_ITERATIONS):
            current_secret_for_buyer = transform_secret(current_secret_for_buyer)

        # current_secret_for_buyer now holds the 2000th generated number for this buyer
        total_sum_of_final_secrets += current_secret_for_buyer

    return total_sum_of_final_secrets

def main():
    """"""
    Main function to execute the solution.
    Reads input file path from command line, parses input, solves puzzle, and prints result.
    """"""
    if len(sys.argv) != 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    initial_secret_numbers = parse_input(input_file)

    # If parse_input resulted in an empty list (e.g., empty file or all lines invalid),
    # solve_puzzle will correctly return 0.
    final_sum = solve_puzzle(initial_secret_numbers)

    # Output the final sum as a single integer. This is the only output to STDOUT.
    print(final_sum)

def test_example_input():
    """"""
    Tests the solution with the example provided in the problem description.
    This function is not called by default but can be used for verification.
    """"""
    print(""Running example test case..."", file=sys.stderr)
    # Example from problem: 1, 10, 100, 2024
    example_secrets = [1, 10, 100, 2024]

    # Expected 2000th values for each from problem description:
    expected_values = {
        1: 8685429,
        10: 4700978,
        100: 15273692,
        2024: 8667524
    }

    all_individual_correct = True
    for secret in example_secrets:
        current_s = secret
        for i in range(NUM_ITERATIONS):
            current_s = transform_secret(current_s)
        if current_s != expected_values[secret]:
            print(f""Error for initial secret {secret}: Expected {expected_values[secret]}, got {current_s}"", file=sys.stderr)
            all_individual_correct = False
        else:
            print(f""Initial secret {secret} -> 2000th: {current_s} (Correct)"", file=sys.stderr)

    if not all_individual_correct:
        print(""Individual 2000th number verification FAILED."", file=sys.stderr)
    else:
        print(""Individual 2000th number verification PASSED."", file=sys.stderr)

    # Verify sum
    expected_sum = 37327623 # Sum of the above expected values
    calculated_sum = solve_puzzle(example_secrets)

    if calculated_sum == expected_sum:
        print(f""Example sum test PASSED: Got {calculated_sum}"", file=sys.stderr)
    else:
        print(f""Example sum test FAILED: Expected {expected_sum}, Got {calculated_sum}"", file=sys.stderr)

    # Further test for the s=123 sequence from problem description text:
    # The problem description has an intermediate sequence for s=123 that is:
    # 123 -> 15887950 -> 16495136 -> ...
    # My interpretation of the rules (which matches the final example sum) yields:
    # 123 -> 15869874 -> 16495193 -> ...
    # This discrepancy is noted, but the implementation matches the verifiable sum test case.
    # s_test = 123
    # s_t1 = transform_secret(s_test)
    # print(f""Test transform_secret(123): {s_t1} (Problem text implies 15887950)"", file=sys.stderr)
    # s_t2 = transform_secret(s_t1)
    # print(f""Test transform_secret({s_t1}): {s_t2} (Problem text implies 16495136 based on its first value)"", file=sys.stderr)

if __name__ == ""__main__"":
    # To run the built-in tests, uncomment the following line:
    # test_example_input()
    main()
"
23,single-model,gemini-2.5-pro-preview-05-06,True,136.47070384025574,"""""""
Advent of Code [Year] Day 23: LAN Party
Solution implementation for finding sets of three inter-connected computers (triangles)
and counting those that include at least one computer name starting with 't'.

Usage: python3 solution.py [input_file]
""""""
from typing import Dict, Set, FrozenSet
import sys
from collections import defaultdict

def parse_input(input_file: str) -> Dict[str, Set[str]]:
    """"""Parse the puzzle input from file into an adjacency list representation of the graph.

    Args:
        input_file: Path to the input file.

    Returns:
        A dictionary where keys are node names (strings) and values are sets of
        connected node names (strings).
    """"""
    graph: Dict[str, Set[str]] = defaultdict(set)
    try:
        with open(input_file, 'r') as f:
            for line_num, line_content in enumerate(f, 1):
                line = line_content.strip()
                if not line: # Skip empty lines
                    continue

                parts = line.split('-')
                # Check for malformed lines (e.g., not two parts, or empty node names)
                if len(parts) != 2 or not parts[0] or not parts[1]:
                    print(f""Warning: Malformed line {line_num} ('{line}') in input, skipping."", file=sys.stderr)
                    continue

                node1, node2 = parts[0], parts[1]

                # Check for self-loops; problem implies distinct computers
                if node1 == node2:
                    print(f""Warning: Self-loop on node '{node1}' in line {line_num} ('{line}'), skipping."", file=sys.stderr)
                    continue

                graph[node1].add(node2)
                graph[node2].add(node1)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1) # Exit if file not found, critical error
    except Exception as e:
        print(f""An error occurred during parsing: {e}"", file=sys.stderr)
        sys.exit(1)

    if not graph and input_file: # Check if graph is empty after parsing a non-test file.
        print(""Warning: Input file was empty or contained no valid connections. Result will be 0."", file=sys.stderr)

    return graph

def find_triangles(graph: Dict[str, Set[str]]) -> Set[FrozenSet[str]]:
    """"""Find all unique triangles in the graph.
    A triangle is a set of three nodes {A, B, C} such that A-B, B-C, and C-A are all edges.
    This implementation iterates through each node 'u', then through pairs of its
    neighbors ('v', 'w'), and checks if 'v' and 'w' are connected.
    Using a set of frozensets ensures that each triangle is stored only once.

    Args:
        graph: The graph represented as an adjacency list.

    Returns:
        A set of frozensets, where each frozenset contains the names of three
        nodes forming a triangle.
    """"""
    triangles: Set[FrozenSet[str]] = set()

    # Iterate over each node 'u' in the graph.
    for u in graph: # graph.keys() is implicit
        neighbors_of_u = list(graph[u]) # Convert set to list for indexed access

        # Node 'u' must have at least two neighbors to form a triangle.
        if len(neighbors_of_u) < 2:
            continue

        # Iterate over all unique pairs of neighbors (v, w) of 'u'.
        for i in range(len(neighbors_of_u)):
            v = neighbors_of_u[i]
            for j in range(i + 1, len(neighbors_of_u)):
                w = neighbors_of_u[j]

                # If 'w' is a neighbor of 'v', then {u, v, w} forms a triangle.
                # graph[v] is a set, so 'w in graph[v]' is an efficient check.
                if w in graph[v]:
                    triangle = frozenset({u, v, w})
                    triangles.add(triangle)

    return triangles


def solve_part_one(graph: Dict[str, Set[str]]) -> int:
    """"""Solve part one of the puzzle.
    Finds all triangles and counts how many include at least one node whose name starts with 't'.

    Args:
        graph: The graph data, an adjacency list.

    Returns:
        The count of qualifying triangles.
    """"""
    all_triangles = find_triangles(graph)

    count_with_t_node = 0
    for triangle_nodes in all_triangles:
        # Check if any node in the current triangle starts with 't'
        has_t_node = False
        for node in triangle_nodes:
            if node.startswith('t'):
                has_t_node = True
                break # Found a 't' node, no need to check other nodes in this triangle

        if has_t_node:
            count_with_t_node += 1

    return count_with_t_node


EXAMPLE_INPUT_STR = """"""kh-tc
qp-kh
de-cg
ka-co
yn-aq
qp-ub
cg-tb
vc-aq
tb-ka
wh-tc
yn-cg
kh-ub
ta-co
de-co
tc-td
tb-wq
wh-td
ta-ka
td-qp
aq-cg
wq-ub
ub-vc
de-ta
wq-aq
wq-vc
wh-yn
ka-de
kh-ta
co-tc
wh-qp
tb-vc
td-yn""""""

def run_tests():
    """"""Runs tests with the example input and checks outputs.""""""
    print(""Running tests with example input..."", file=sys.stderr)

    example_graph: Dict[str, Set[str]] = defaultdict(set)
    for line in EXAMPLE_INPUT_STR.strip().split('\n'):
        node1, node2 = line.split('-')
        example_graph[node1].add(node2)
        example_graph[node2].add(node1)

    triangles_found = find_triangles(example_graph)
    expected_num_triangles = 12
    assert len(triangles_found) == expected_num_triangles, \
        f""Test find_triangles: FAILED. Expected {expected_num_triangles} triangles, got {len(triangles_found)}.""
    print(f""Test find_triangles: PASSED. Found {len(triangles_found)} triangles."", file=sys.stderr)

    solution = solve_part_one(example_graph)
    expected_solution = 7
    assert solution == expected_solution, \
        f""Test solve_part_one: FAILED. Expected {expected_solution}, got {solution}.""
    print(f""Test solve_part_one: PASSED. Result: {solution}"", file=sys.stderr)
    print(""All example tests PASSED."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        print(""No input file specified. Running tests with example data."", file=sys.stderr)
        try:
            run_tests()
        except AssertionError as e:
            print(f""Test assertion failed: {e}"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    if input_file == ""test"":
        try:
            run_tests()
        except AssertionError as e:
            print(f""Test assertion failed: {e}"", file=sys.stderr)
        return

    print(f""Parsing input from {input_file}..."", file=sys.stderr)
    parsed_data = parse_input(input_file)

    print(""Solving Part One..."", file=sys.stderr)
    part_one_solution = solve_part_one(parsed_data)

    print(part_one_solution)


if __name__ == ""__main__"":
    main()
"
23,system,gemini-2.5-pro-preview-05-06,True,893.6805498600006,"""""""
Advent of Code Day 23: LAN Party
Solution implementation based on the provided plan.
Identifies triangles in a computer network and counts those with at least one 't'-prefixed computer.

Usage: python3 solution.py [input_file]
       python3 solution.py --test
""""""
import sys
import collections
import itertools
from typing import Tuple, Set, FrozenSet

# For type hinting, using collections.defaultdict directly (requires Python 3.9+).
# For older Python versions, `from typing import DefaultDict` would be used.
# Similarly for `set` and `frozenset` if used with generics in older Pythons.
# `FrozenSet` is imported from `typing` for clarity, though `frozenset` could be used directly.
if sys.version_info < (3, 9):
    from typing import DefaultDict
else:
    DefaultDict = collections.defaultdict # type: ignore


# Configuration
T_PREFIX_CHAR = 't'  # Character to check for in computer names

# --- Input Parsing ---

def parse_input_from_string(data: str) -> Tuple[DefaultDict[str, Set[str]], Set[str]]:
    """"""
    Parses network connections from a multi-line string.
    Each line ""compA-compB"" defines an undirected connection.

    Args:
        data: The string containing connection data.

    Returns:
        A tuple (adj_list, all_nodes):
            - adj_list: Adjacency list (defaultdict of sets) representing the graph.
            - all_nodes: Set of all unique computer names.
    """"""
    adj_list: DefaultDict[str, Set[str]] = collections.defaultdict(set)
    all_nodes: Set[str] = set()

    for line in data.strip().split('\n'):
        line = line.strip()
        if not line:  # Skip empty lines
            continue

        parts = line.split('-')
        if len(parts) != 2:
            sys.stderr.write(f""Warning: Malformed line skipped: '{line}'\n"")
            continue

        # Ensure names are stripped if spaces exist around hyphen or in names themselves
        comp1, comp2 = parts[0].strip(), parts[1].strip()

        adj_list[comp1].add(comp2)
        adj_list[comp2].add(comp1)  # Undirected graph

        all_nodes.add(comp1)
        all_nodes.add(comp2)

    return adj_list, all_nodes

def parse_input(input_file: str) -> Tuple[DefaultDict[str, Set[str]], Set[str]]:
    """"""
    Reads puzzle input from a file and parses it.

    Args:
        input_file: Path to the input file.

    Returns:
        Parsed graph data (adjacency list and set of all nodes).
    """"""
    try:
        with open(input_file, 'r') as f:
            data = f.read()
    except FileNotFoundError:
        sys.stderr.write(f""Error: Input file '{input_file}' not found.\n"")
        sys.exit(1)
    except Exception as e:
        sys.stderr.write(f""Error reading file '{input_file}': {e}\n"")
        sys.exit(1)

    return parse_input_from_string(data)

# --- Core Logic ---

def find_unique_triangles(
    adj_list: DefaultDict[str, Set[str]],
    all_nodes: Set[str]
) -> Set[FrozenSet[str]]:
    """"""
    Identifies all unique triangles in the graph.
    A triangle is a set of three mutually connected computers {u, v, w}.

    Args:
        adj_list: Adjacency list of the graph.
        all_nodes: Set of all nodes in the graph. (Used to iterate starting points)

    Returns:
        A set of frozensets, each frozenset representing a unique triangle {name1, name2, name3}.
    """"""
    unique_triangles: Set[FrozenSet[str]] = set()

    # Iterate through each node 'u' as a potential vertex of a triangle
    for u in all_nodes:
        neighbors_of_u = adj_list[u]

        # A triangle requires 'u' to have at least two neighbors
        if len(neighbors_of_u) < 2:
            continue

        # Consider all unique pairs (v, w) from u's neighbors
        # itertools.combinations ensures each pair is considered once and v != w
        for v, w in itertools.combinations(neighbors_of_u, 2):
            # We have potential triangle (u, v, w).
            # Connections u-v and u-w are guaranteed because v,w are neighbors of u.
            # We need to check if v and w are also connected (edge v-w).
            if w in adj_list[v]:  # This checks if v-w exists
                # Found a triangle {u, v, w}
                triangle = frozenset({u, v, w})
                unique_triangles.add(triangle)
                # The use of frozenset and adding to a set automatically handles
                # uniqueness and order-independence (e.g. {u,v,w} is same as {v,u,w}).
                # Each triangle will be found multiple times (e.g. once for each node as 'u'),
                # but the set `unique_triangles` will store it only once.

    return unique_triangles

def count_triangles_with_t_node(
    unique_triangles: Set[FrozenSet[str]]
) -> int:
    """"""
    Counts how many of the given triangles include at least one computer
    whose name starts with the T_PREFIX_CHAR (e.g., 't').

    Args:
        unique_triangles: A set of frozensets, each representing a unique triangle.

    Returns:
        The number of triangles meeting the specified condition.
    """"""
    count = 0
    for triangle in unique_triangles:
        # Check if any computer name in this triangle starts with T_PREFIX_CHAR
        for computer_name in triangle:
            if computer_name.startswith(T_PREFIX_CHAR):
                count += 1
                break  # Condition met for this triangle, move to the next one
    return count

def solve_part_one(parsed_data: Tuple[DefaultDict[str, Set[str]], Set[str]]) -> int:
    """"""
    Solves part one of the puzzle using the parsed graph data.

    Args:
        parsed_data: A tuple containing the adjacency list and set of all nodes.

    Returns:
        The solution for part one (integer count).
    """"""
    adj_list, all_nodes = parsed_data

    sys.stderr.write(f""Parsed {len(all_nodes)} unique computer names.\n"")
    num_edges = sum(len(neighbors) for neighbors in adj_list.values()) // 2
    sys.stderr.write(f""Graph has {num_edges} unique connections (edges).\n"")

    unique_triangles = find_unique_triangles(adj_list, all_nodes)
    sys.stderr.write(f""Found {len(unique_triangles)} unique triangles.\n"")

    final_count = count_triangles_with_t_node(unique_triangles)
    sys.stderr.write(f""Found {final_count} triangles with at least one node starting with '{T_PREFIX_CHAR}'.\n"")

    return final_count

# --- Testing ---

EXAMPLE_INPUT_DATA = """"""
kh-tc
qp-kh
de-cg
ka-co
yn-aq
qp-ub
cg-tb
vc-aq
tb-ka
wh-tc
yn-cg
kh-ub
ta-co
de-co
tc-td
tb-wq
wh-td
ta-ka
td-qp
aq-cg
wq-ub
ub-vc
de-ta
wq-aq
wq-vc
wh-yn
ka-de
kh-ta
co-tc
wh-qp
tb-vc
td-yn
""""""
EXAMPLE_EXPECTED_SOLUTION = 7

def run_tests():
    """"""Runs built-in test cases.""""""
    print(""Running tests..."", file=sys.stderr)

    # Test parsing and solving with example input
    example_adj_list, example_all_nodes = parse_input_from_string(EXAMPLE_INPUT_DATA)

    # Basic parsing checks
    assert 'kh' in example_all_nodes
    assert 'tc' in example_all_nodes
    assert 'tc' in example_adj_list['kh']
    assert 'kh' in example_adj_list['tc']

    # Example: triangle aq,cg,yn
    # Connections: aq-cg, yn-aq, yn-cg
    assert 'aq' in example_all_nodes and 'cg' in example_all_nodes and 'yn' in example_all_nodes
    assert 'cg' in example_adj_list['aq']  # Checks aq-cg
    assert 'yn' in example_adj_list['aq']  # Checks aq-yn
    assert 'yn' in example_adj_list['cg']  # Checks cg-yn

    example_triangles = find_unique_triangles(example_adj_list, example_all_nodes)

    # According to the problem description, the example has 12 such triangles:
    expected_triangle_tuples = [
        (""aq"",""cg"",""yn""), (""aq"",""vc"",""wq""), (""co"",""de"",""ka""), (""co"",""de"",""ta""),
        (""co"",""ka"",""ta""), (""de"",""ka"",""ta""), (""kh"",""qp"",""ub""), (""qp"",""td"",""wh""),
        (""tb"",""vc"",""wq""), (""tc"",""td"",""wh""), (""td"",""wh"",""yn""), (""ub"",""vc"",""wq"")
    ]
    expected_triangles_as_frozensets = {frozenset(t) for t in expected_triangle_tuples}

    assert len(example_triangles) == 12, \
        f""Expected 12 unique triangles in example, but found {len(example_triangles)}.""
    assert example_triangles == expected_triangles_as_frozensets, \
        ""The set of found triangles does not match the expected set for the example.""

    # Test the counting part
    example_solution_count = count_triangles_with_t_node(example_triangles)

    assert example_solution_count == EXAMPLE_EXPECTED_SOLUTION, \
        f""Test failed for example: Expected final count {EXAMPLE_EXPECTED_SOLUTION}, got {example_solution_count}.""

    print(""All built-in tests passed."", file=sys.stderr)

# --- Main Execution ---

def main():
    """"""
    Main entry point for the script. Parses command-line arguments,
    reads input, solves the puzzle, and prints the result.
    """"""
    # Handle command line arguments
    if len(sys.argv) not in [2, 3]: # Allow for optional flags like --test
        print(""Usage: python3 solution.py [input_file]"")
        print(""       python3 solution.py --test"")
        sys.exit(1)

    argument = sys.argv[1]

    if argument == ""--test"":
        run_tests()
        return

    # Assume argument is an input file path
    input_file = argument

    # Parse input data from file
    parsed_data = parse_input(input_file)

    # Solve Part One
    solution = solve_part_one(parsed_data)

    # Print the final solution for Part One to STDOUT
    # All other prints (debug, info, errors) should go to STDERR
    print(solution)

if __name__ == ""__main__"":
    main()
"
24,single-model,gemini-2.5-pro-preview-05-06,True,169.8154947757721,"""""""
Advent of Code Day 24: Crossed Wires (Simulated)
Solution implementation for simulating a system of logic gates.
This problem is styled after Advent of Code puzzles.

Usage: python3 solution.py [input_file]
       python3 solution.py --test (to run example tests using hardcoded examples)
""""""
import sys
import re
from typing import List, Dict, Tuple

# Type Aliases
InitialValues = Dict[str, int]
# GateDefinition stores: (operator_str, input1_wire_name, input2_wire_name, output_wire_name)
GateDefinition = Tuple[str, str, str, str]
GateList = List[GateDefinition]
WireValues = Dict[str, int]


def parse_lines(lines: List[str]) -> Tuple[InitialValues, GateList]:
    """"""Parses lines of input into initial wire values and gate definitions.""""""
    initial_values: InitialValues = {}
    gate_definitions: GateList = []

    parsing_initial_values = True
    # Regex for initial values: e.g., ""x00: 1""
    initial_value_pattern = re.compile(r""^(\w+): (\d+)$"")
    # Regex for gates: e.g., ""x00 AND y00 -> z00""
    gate_pattern = re.compile(r""^(\w+)\s+(AND|OR|XOR)\s+(\w+)\s+->\s+(\w+)$"")

    for line_num, line_content in enumerate(lines):
        line = line_content.strip()
        if not line: # Blank line separates sections
            parsing_initial_values = False
            continue

        if parsing_initial_values:
            match = initial_value_pattern.match(line)
            if match:
                wire_name, value_str = match.groups()
                initial_values[wire_name] = int(value_str)
            elif line: # Non-empty, non-matching line
                print(f""Warning: Malformed initial value line (L{line_num+1}): {line}"", file=sys.stderr)
        else:
            match = gate_pattern.match(line)
            if match:
                in1, op, in2, out = match.groups()
                gate_definitions.append((op, in1, in2, out))
            elif line: # Non-empty, non-matching line
                print(f""Warning: Malformed gate definition line (L{line_num+1}): {line}"", file=sys.stderr)

    return initial_values, gate_definitions


def parse_input(input_file: str) -> Tuple[InitialValues, GateList]:
    """"""Parse the puzzle input from file into initial wire values and gate definitions.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
            - A dictionary mapping wire names to their initial integer values.
            - A list of gate definitions, where each gate is a tuple:
              (operator_str, input1_wire, input2_wire, output_wire).
    """"""
    try:
        with open(input_file, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    return parse_lines(lines)


def perform_gate_operation(op_type: str, val1: int, val2: int) -> int:
    """"""Performs a logic gate operation.

    Args:
        op_type: The type of gate (""AND"", ""OR"", ""XOR"").
        val1: The first input value (0 or 1).
        val2: The second input value (0 or 1).

    Returns:
        The result of the gate operation (0 or 1).

    Raises:
        ValueError: If op_type is unknown or inputs are not 0 or 1.
    """"""
    if not (0 <= val1 <= 1 and 0 <= val2 <= 1):
        raise ValueError(f""Gate inputs must be 0 or 1. Got {val1}, {val2}"")

    if op_type == ""AND"":
        return val1 & val2
    elif op_type == ""OR"":
        return val1 | val2
    elif op_type == ""XOR"":
        return val1 ^ val2
    else:
        raise ValueError(f""Unknown gate operation: {op_type}"")


def simulate_circuit(initial_wire_values: InitialValues, gates: GateList) -> WireValues:
    """"""Simulates the circuit to determine final values on all wires.

    Args:
        initial_wire_values: A dictionary of wires with pre-assigned values.
        gates: A list of gate definitions.

    Returns:
        A dictionary mapping all computable wire names to their final integer values.
    """"""
    wire_values = initial_wire_values.copy()

    # List of gates that haven't successfully computed their output yet
    processing_gates = list(gates)

    while True:
        new_values_computed_this_iteration = 0
        # Gates that couldn't be processed in this iteration, to try in the next
        remaining_gates_for_next_round: GateList = []

        if not processing_gates: # No more gates to process
            break

        for gate_op, in1_name, in2_name, out_name in processing_gates:
            # If output wire already has a value (either initial or computed in a previous step),
            # this gate's output is already determined. Skip.
            if out_name in wire_values:
                continue

            # Check if both inputs are available
            if in1_name in wire_values and in2_name in wire_values:
                val1 = wire_values[in1_name]
                val2 = wire_values[in2_name]

                try:
                    result = perform_gate_operation(gate_op, val1, val2)
                    wire_values[out_name] = result
                    new_values_computed_this_iteration += 1
                except ValueError as e:
                    print(f""Error during gate operation for gate ({gate_op}, {in1_name}, {in2_name}, {out_name}): {e}"", file=sys.stderr)
                    # Decide how to handle: skip gate, halt, etc. For now, skip adding to next round.
                    continue
            else:
                # Gate not ready (one or both inputs unknown), add to list for next iteration
                remaining_gates_for_next_round.append((gate_op, in1_name, in2_name, out_name))

        if new_values_computed_this_iteration == 0:
            # If no new values were computed in a full pass over remaining gates,
            # the system has stabilized. Any gates in remaining_gates_for_next_round
            # are uncomputable with the current known values.
            # Given ""no loops"", this means they will never be computable.
            if remaining_gates_for_next_round:
                # print(f""Warning: {len(remaining_gates_for_next_round)} gates remain uncomputed."", file=sys.stderr)
                pass # This is expected if some inputs are never defined.
            break

        processing_gates = remaining_gates_for_next_round

    return wire_values


def calculate_output_value(final_wire_values: WireValues) -> int:
    """"""Calculates the final decimal number from 'z' wires.

    Args:
        final_wire_values: Dictionary of all wire values after simulation.

    Returns:
        The decimal value represented by the 'z' wires.
    """"""
    z_wires: List[Tuple[int, int]] = [] # Stores (index, value)

    for wire_name, value in final_wire_values.items():
        if wire_name.startswith('z'):
            try:
                # Ensure the part after 'z' is purely numeric for correct sorting
                if wire_name[1:].isdigit():
                    index = int(wire_name[1:])
                    z_wires.append((index, value))
                else:
                    print(f""Warning: Non-numeric 'z' wire suffix: {wire_name}"", file=sys.stderr)
            except ValueError:
                print(f""Warning: Malformed 'z' wire name (could not parse index): {wire_name}"", file=sys.stderr)

    if not z_wires:
        return 0

    # Sort by index (z00, z01, z02, ...)
    z_wires.sort()

    # Construct binary string: z_N ... z02 z01 z00 (MSB ... LSB)
    # Values from z_wires are [val_z0, val_z1, val_z2, ...]
    # So we need to reverse this list of values before joining.
    binary_parts = [str(val) for _idx, val in z_wires]
    binary_string = """".join(reversed(binary_parts))

    if not binary_string:
        return 0

    return int(binary_string, 2)


def solve_part_one(parsed_data: Tuple[InitialValues, GateList]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        parsed_data: A tuple containing (initial_wire_values, gate_definitions).

    Returns:
        Solution for part one (the decimal output value).
    """"""
    initial_values, gates = parsed_data
    final_wire_values = simulate_circuit(initial_values, gates)

    # Example debug output (can be enabled if needed)
    # print_debug_wire_info(final_wire_values, initial_values)

    output_decimal_value = calculate_output_value(final_wire_values)
    return output_decimal_value

# Optional debug helper
# def print_debug_wire_info(final_wire_values, initial_values):
#     if len(initial_values) > 10: # Crude check for large example
#         print(""Final wire values (debug):"", file=sys.stderr)
#         relevant_wires = {k: v for k, v in final_wire_values.items() if not (k.startswith('x') or k.startswith('y'))}
#         sorted_wires = sorted(relevant_wires.items())
#         for name, val in sorted_wires:
#             print(f""{name}: {val}"", file=sys.stderr)
#         print(""Z-wires (debug):"", file=sys.stderr)
#         z_debug_wires = sorted([(k,v) for k,v in final_wire_values.items() if k.startswith('z')], key=lambda item: int(item[0][1:]))
#         for name, val in z_debug_wires:
#              print(f""{name}: {val}"", file=sys.stderr)

def run_tests():
    """"""Runs built-in tests against example cases.""""""
    print(""Running tests..."", file=sys.stderr)

    # Example 1
    example1_str = """"""x00: 1
x01: 1
x02: 1
y00: 0
y01: 1
y02: 0

x00 AND y00 -> z00
x01 XOR y01 -> z01
x02 OR y02 -> z02""""""
    parsed_data_ex1 = parse_lines(example1_str.splitlines())
    result_ex1 = solve_part_one(parsed_data_ex1)
    expected_ex1 = 4
    assert result_ex1 == expected_ex1, f""Example 1 Failed: Expected {expected_ex1}, Got {result_ex1}""
    print(""Example 1 Passed."", file=sys.stderr)

    # Example 2
    example2_str = """"""x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
y00: 1
y01: 1
y02: 1
y03: 1
y04: 1

ntg XOR fgs -> mjb
y02 OR x01 -> tnw
kwq OR kpj -> z05
x00 OR x03 -> fst
tgd XOR rvg -> z01
vdt OR tnw -> bfw
bfw AND frj -> z10
ffh OR nrd -> bqk
y00 AND y03 -> djm
y03 OR y00 -> psh
bqk OR frj -> z08
tnw OR fst -> frj
gnj AND tgd -> z11
bfw XOR mjb -> z00
x03 OR x00 -> vdt
gnj AND wpb -> z02
x04 AND y00 -> kjc
djm OR pbm -> qhw
nrd AND vdt -> hwm
kjc AND fst -> rvg
y04 OR y02 -> fgs
y01 AND x02 -> pbm
ntg OR kjc -> kwq
psh XOR fgs -> tgd
qhw XOR tgd -> z09
pbm OR djm -> kpj
x03 XOR y03 -> ffh
x00 XOR y04 -> ntg
bfw OR bqk -> z06
nrd XOR fgs -> wpb
frj XOR qhw -> z04
bqk OR frj -> z07
y03 OR x01 -> nrd
hwm AND bqk -> z03
tgd XOR rvg -> z12
tnw OR pbm -> gnj""""""
    parsed_data_ex2 = parse_lines(example2_str.splitlines())
    result_ex2 = solve_part_one(parsed_data_ex2)
    expected_ex2 = 2024
    assert result_ex2 == expected_ex2, f""Example 2 Failed: Expected {expected_ex2}, Got {result_ex2}""
    print(""Example 2 Passed."", file=sys.stderr)

    print(""All tests passed."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"")
        print(f""   or: python3 {sys.argv[0]} --test"")
        sys.exit(1)

    if sys.argv[1] == '--test':
        if len(sys.argv) > 2:
            print(f""Usage: python3 {sys.argv[0]} --test (no other arguments needed for test mode)"", file=sys.stderr)
            sys.exit(1)
        run_tests()
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve the puzzle
    solution = solve_part_one(parsed_data)

    # Print the solution
    print(solution)


if __name__ == ""__main__"":
    main()
"
24,system,gemini-2.5-pro-preview-05-06,True,1336.1584811210632,"import sys
import re
from typing import List, Dict, Tuple, Set

# Type aliases for clarity
InitialInputs = Dict[str, int]
GateDefinitions = Dict[str, Tuple[str, str, str]]  # output_wire -> (input1, op_str, input2)
AllWireNames = Set[str]
ParsedDataType = Tuple[InitialInputs, GateDefinitions, AllWireNames]
MemoizedWireValues = Dict[str, int]


def parse_input(input_file: str) -> ParsedDataType:
    """"""Parse the puzzle input from file into data structures.

    Args:
        input_file: Path to the input file.

    Returns:
        A tuple containing:
        - initial_inputs: Dict mapping wire names to their initial integer values (0 or 1).
        - gate_definitions: Dict mapping an output wire name to a tuple
                          (input1_wire, operation_type_str, input2_wire).
        - all_wire_names: Set of all unique wire names encountered.

    Raises:
        SystemExit: If file not found or critical parsing error occurs.
    """"""
    initial_inputs: InitialInputs = {}
    gate_definitions: GateDefinitions = {}
    all_wire_names: AllWireNames = set()

    # Wire names are alphanumeric as per examples (e.g., x00, ntg)
    wire_name_pattern = r""[a-zA-Z0-9]+""
    initial_value_re = re.compile(rf""({wire_name_pattern}):\s*([01])"")
    gate_def_re = re.compile(rf""({wire_name_pattern})\s+(AND|OR|XOR)\s+({wire_name_pattern})\s+->\s+({wire_name_pattern})"")

    try:
        with open(input_file, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:  # Skip blank lines
                    continue

                match_initial = initial_value_re.fullmatch(line)
                if match_initial:
                    wire_name, value_str = match_initial.groups()
                    value = int(value_str)

                    # Constraint: A wire receives value from at most one source.
                    if wire_name in initial_inputs:
                         raise ValueError(f""Input error line {line_num}: Wire '{wire_name}' has duplicate initial value assignment."")
                    if wire_name in gate_definitions:
                         raise ValueError(f""Input error line {line_num}: Wire '{wire_name}' is an output of a gate and also given an initial value."")

                    initial_inputs[wire_name] = value
                    all_wire_names.add(wire_name)
                    continue

                match_gate = gate_def_re.fullmatch(line)
                if match_gate:
                    input1, op, input2, output_wire = match_gate.groups()

                    # Constraint: Wire output from at most one gate AND not an initial input.
                    if output_wire in gate_definitions:
                        raise ValueError(f""Input error line {line_num}: Wire '{output_wire}' defined as output for multiple gates."")
                    if output_wire in initial_inputs:
                         raise ValueError(f""Input error line {line_num}: Wire '{output_wire}' has an initial value and is also defined as a gate output."")

                    gate_definitions[output_wire] = (input1, op, input2)
                    all_wire_names.add(input1)
                    all_wire_names.add(input2)
                    all_wire_names.add(output_wire)
                    continue

                # If line doesn't match either format and is not blank
                print(f""Warning: Unparseable line {line_num}: '{line}'"", file=sys.stderr)

    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    return initial_inputs, gate_definitions, all_wire_names


def solve_circuit(parsed_data: ParsedDataType) -> int:
    """"""Solve the puzzle using the parsed circuit data.

    Args:
        parsed_data: A tuple containing initial_inputs, gate_definitions, and all_wire_names.

    Returns:
        The final decimal number derived from 'z'-wires.

    Raises:
        ValueError: If a wire's value cannot be resolved (e.g., undefined wire, cycle).
        AssertionError: For critical internal logic errors.
    """"""
    initial_inputs, gate_definitions, all_wire_names = parsed_data
    memoized_wire_values: MemoizedWireValues = {}

    # Python's default recursion limit might be an issue for very deep circuits.
    # sys.setrecursionlimit(desired_limit) could be used if needed.

    def get_wire_value(wire_name: str) -> int:
        """"""Recursively computes the value of a wire, with memoization.

        This function is nested to close over initial_inputs, gate_definitions,
        and memoized_wire_values from the outer scope.
        """"""
        if wire_name in memoized_wire_values:
            return memoized_wire_values[wire_name]

        if wire_name in initial_inputs:
            value = initial_inputs[wire_name]
            memoized_wire_values[wire_name] = value
            return value

        if wire_name in gate_definitions:
            input1_name, op_type, input2_name = gate_definitions[wire_name]

            # Recursively get values for input wires
            # Problem states no loops, so recursion will terminate.
            val1 = get_wire_value(input1_name)
            val2 = get_wire_value(input2_name)

            result: int
            if op_type == ""AND"":
                result = val1 & val2
            elif op_type == ""OR"":
                result = val1 | val2
            elif op_type == ""XOR"":
                result = val1 ^ val2
            else:
                # This case should not be reached if parsing and gate_definitions are correct
                raise AssertionError(f""Internal error: Unknown operation type '{op_type}' for wire '{wire_name}'."")

            memoized_wire_values[wire_name] = result
            return result

        # If wire_name is not in initial_inputs and not an output of a gate, its value is unknown.
        raise ValueError(f""Wire '{wire_name}' is not defined as an initial input or a gate output, but its value is required."")

    # Identify all 'z'-wires with numeric suffixes
    # Stores tuples of (numeric_suffix_int, wire_name_str)
    target_z_wires: List[Tuple[int, str]] = []
    for name in all_wire_names:
        if name.startswith('z'):
            suffix = name[1:] # Get the part after 'z'
            if suffix.isdigit(): # Check if it's purely numeric
                target_z_wires.append((int(suffix), name))

    # Sort 'z'-wires by their numeric suffix (ascending order)
    # This ensures LSB corresponds to smallest suffix, MSB to largest.
    target_z_wires.sort()

    if not target_z_wires:
        # No 'z'-wires found, or none with valid numeric suffixes.
        # As per plan, binary number is ""0"", decimal value is 0.
        return 0

    # Get values for sorted 'z'-wires.
    # sorted_z_values_LSB_to_MSB will store values where index 0 is LSB.
    sorted_z_values_LSB_to_MSB: List[int] = []
    for suffix_num, wire_name in target_z_wires:
        # get_wire_value will raise ValueError if wire_name or its dependencies are unresolvable.
        # This will propagate up and be handled by main().
        value = get_wire_value(wire_name)
        sorted_z_values_LSB_to_MSB.append(value)

    # Construct binary string: MSB comes from largest suffix, LSB from smallest.
    # sorted_z_values_LSB_to_MSB has LSB at index 0, MSB at last index.
    # The int(binary_str, 2) function expects MSB first in binary_str.
    # So, reverse the list of values before joining them into a string.
    if not sorted_z_values_LSB_to_MSB:
        # This condition should be redundant due to the `if not target_z_wires` check earlier,
        # unless get_wire_value could somehow lead to an empty list here without raising an error.
        return 0

    binary_string = """".join(map(str, reversed(sorted_z_values_LSB_to_MSB)))

    # Convert binary string to decimal
    try:
        decimal_value = int(binary_string, 2)
    except ValueError:
        # This should not happen if values are all 0 or 1.
        # Indicates an internal error if binary_string is malformed.
        raise AssertionError(f""Internal error: Generated binary string '{binary_string}' is invalid."")

    return decimal_value


# --- Test Cases ---
EXAMPLE_INPUT_1 = """"""\
x00: 1
x01: 1
x02: 1
y00: 0
y01: 1
y02: 0

x00 AND y00 -> z00
x01 XOR y01 -> z01
x02 OR y02 -> z02
""""""
EXPECTED_OUTPUT_1 = 4

EXAMPLE_INPUT_2 = """"""\
x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
y00: 1
y01: 1
y02: 1
y03: 1
y04: 1

ntg XOR fgs -> mjb
y02 OR x01 -> tnw
kwq OR kpj -> z05
x00 OR x03 -> fst
tgd XOR rvg -> z01
vdt OR tnw -> bfw
bfw AND frj -> z10
ffh OR nrd -> bqk
y00 AND y03 -> djm
y03 OR y00 -> psh
bqk OR frj -> z08
tnw OR fst -> frj
gnj AND tgd -> z11
bfw XOR mjb -> z00
x03 OR x00 -> vdt
gnj AND wpb -> z02
x04 AND y00 -> kjc
djm OR pbm -> qhw
nrd AND vdt -> hwm
kjc AND fst -> rvg
y04 OR y02 -> fgs
y01 AND x02 -> pbm
ntg OR kjc -> kwq
psh XOR fgs -> tgd
qhw XOR tgd -> z09
pbm OR djm -> kpj
x03 XOR y03 -> ffh
x00 XOR y04 -> ntg
bfw OR bqk -> z06
nrd XOR fgs -> wpb
frj XOR qhw -> z04
bqk OR frj -> z07
y03 OR x01 -> nrd
hwm AND bqk -> z03
tgd XOR rvg -> z12
tnw OR pbm -> gnj
""""""
EXPECTED_OUTPUT_2 = 2024

TEST_CASES = [
    (""Test Case 1 (Simple)"", EXAMPLE_INPUT_1, EXPECTED_OUTPUT_1),
    (""Test Case 2 (Larger)"", EXAMPLE_INPUT_2, EXPECTED_OUTPUT_2),
]

def run_tests():
    """"""Runs all defined test cases and prints their status.""""""
    print(""Running test cases..."", file=sys.stderr)
    import tempfile
    import os
    import traceback

    all_passed = True
    for i, (name, input_str, expected_output) in enumerate(TEST_CASES):
        passed = False
        actual_output = None
        error_info = """"
        # Create a temporary file for parse_input
        # Ensure tmp_file_path is defined for finally block, even if tempfile creation fails
        tmp_file_path = None
        try:
            # Using delete=False because parse_input opens by path.
            # tempfile will be closed after writing, then parse_input reopens.
            with tempfile.NamedTemporaryFile(mode=""w+"", delete=False, suffix="".txt"", encoding=""utf-8"") as tmp_file:
                tmp_file.write(input_str)
                tmp_file_path = tmp_file.name

            parsed_data = parse_input(tmp_file_path)
            actual_output = solve_circuit(parsed_data) # Changed function name

            if actual_output == expected_output:
                passed = True
            else:
                error_info = f""Expected {expected_output}, got {actual_output}""

        except Exception as e:
            error_info = f""Exception: {e}\n{traceback.format_exc()}""
        finally:
            if tmp_file_path and os.path.exists(tmp_file_path):
                os.remove(tmp_file_path)

        status = ""PASSED"" if passed else ""FAILED""
        print(f""{name}: {status}"", file=sys.stderr)
        if not passed:
            all_passed = False
            # For brevity, limit printing full input string for large inputs
            input_summary = input_str
            if len(input_summary) > 200:
                input_summary = input_str[:200].strip() + ""\n...""
            print(f""  Input:\n{input_summary}"", file=sys.stderr)
            print(f""  Error/Mismatch: {error_info}"", file=sys.stderr)
        print(""-"" * 30, file=sys.stderr)

    if all_passed:
        print(""All test cases PASSED."", file=sys.stderr)
    else:
        print(""Some test cases FAILED."", file=sys.stderr)


def main():
    """"""Main entry point for the script.""""""
    # Update the problem year and day in the top-level docstring when known.
    # For now, using a generic title.
    # Update script docstring
    script_doc = """"""Advent of Code: Digital Logic Circuit Simulation

    Simulates a digital logic circuit and computes a final number from 'z'-wires.
    The circuit is evaluated using recursion with memoization.
    'z'-wires are sorted by numeric suffix, their values form a binary number
    (LSB from smallest suffix, MSB from largest suffix), which is then converted to decimal.

    Usage: python3 solution.py [input_file]
           python3 solution.py --test (to run example test cases)
    """"""
    __doc__ = script_doc # Update module's docstring dynamically, or set it statically at top.

    if len(sys.argv) == 2 and sys.argv[1] == ""--test"":
        run_tests()
        return

    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        print(""   or: python3 solution.py --test"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # parse_input handles its own errors and sys.exit if critical
    parsed_data = parse_input(input_file)

    try:
        solution = solve_circuit(parsed_data) # Changed function name
        # ONLY PRINT THE FINAL RESULT to STDOUT
        print(solution)
    except ValueError as e:
        print(f""Error during circuit simulation: {e}"", file=sys.stderr)
        sys.exit(1)
    except AssertionError as e:
        print(f""Internal logic error: {e}"", file=sys.stderr)
        import traceback
        print(traceback.format_exc(), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""An unexpected error occurred during solution: {e}"", file=sys.stderr)
        import traceback
        print(traceback.format_exc(), file=sys.stderr)
        sys.exit(1)

if __name__ == ""__main__"":
    # Update module docstring for clarity if script is run with -h or similar tools
    # This approach for __doc__ update inside main() might not be standard for all tools.
    # It's generally better to have the final docstring statically defined at the top.
    # For this submission, the static string at the top of the file is the primary one.
    main()
"
25,single-model,gemini-2.5-pro-preview-05-06,True,229.2808985710144,"""""""
Advent of Code Day 25: Code Chronicle
Solution for determining the number of unique lock/key pairs that fit together.

The approach involves:
1. Parsing schematics from the input file. Schematics are 7x5 grids of '#' and '.'.
   Each schematic is identified as either a lock or a key based on its top and bottom rows.
2. Converting each schematic into a list of 5 heights, one for each column.
   - For locks, pin height in a column is the number of consecutive '#' characters
     from top to bottom within the 5-row interaction space (schematic rows 1-5).
   - For keys, shape height in a column is the number of consecutive '#' characters
     from bottom to top within the 5-row interaction space (schematic rows 5-1).
3. Comparing every lock with every key. A lock and key pair fits if, for all five
   columns, the sum of the lock's pin height and the key's shape height does not
   exceed the total available height of the interaction space (which is 5).
4. Counting the total number of such fitting pairs.

Usage: python3 solution.py [input_file]
       python3 solution.py test (to run internal tests)
""""""
import sys
from typing import List, Tuple

# Constants for schematic properties
SCHEMATIC_TOTAL_HEIGHT = 7  # Total rows in a schematic block (0-indexed: 0-6)
SCHEMATIC_WIDTH = 5   # Number of columns (0-indexed: 0-4)

# Rows 0 and 6 are fixed plates. Interaction space is rows 1-5.
INTERACTION_SPACE_FIRST_ROW_IDX = 1 # Index of the first row of interaction space
INTERACTION_SPACE_LAST_ROW_IDX = 5  # Index of the last row of interaction space
INTERACTION_SPACE_HEIGHT = INTERACTION_SPACE_LAST_ROW_IDX - INTERACTION_SPACE_FIRST_ROW_IDX + 1 # Should be 5

# Patterns to identify lock/key types
LOCK_TOP_ROW_PATTERN = ""#####""
LOCK_BOTTOM_ROW_PATTERN = "".....""
KEY_TOP_ROW_PATTERN = "".....""
KEY_BOTTOM_ROW_PATTERN = ""#####""

# Type alias for pin/key heights (list of 5 integers)
Heights = List[int]

def _get_lock_pin_heights_from_schematic(schematic_lines: List[str]) -> Heights:
    """"""
    Calculates the pin heights for a lock schematic.
    Pin height in a column is the number of consecutive '#' characters
    from top to bottom within the interaction space.
    """"""
    if len(schematic_lines) != SCHEMATIC_TOTAL_HEIGHT:
        # This validation is more for internal consistency, parse_input should ensure correct length.
        raise ValueError(f""Schematic must have {SCHEMATIC_TOTAL_HEIGHT} lines."")

    heights: Heights = [0] * SCHEMATIC_WIDTH
    for col_idx in range(SCHEMATIC_WIDTH):
        current_pin_height = 0
        # Interaction space is schematic_lines[INTERACTION_SPACE_FIRST_ROW_IDX]
        # through schematic_lines[INTERACTION_SPACE_LAST_ROW_IDX]
        for row_idx in range(INTERACTION_SPACE_FIRST_ROW_IDX, INTERACTION_SPACE_LAST_ROW_IDX + 1):
            if schematic_lines[row_idx][col_idx] == '#':
                current_pin_height += 1
            else:  # Pin is broken by a '.', so it ends here
                break
        heights[col_idx] = current_pin_height
    return heights

def _get_key_shape_heights_from_schematic(schematic_lines: List[str]) -> Heights:
    """"""
    Calculates the shape heights for a key schematic.
    Key shape height in a column is the number of consecutive '#' characters
    from bottom to top within the interaction space.
    """"""
    if len(schematic_lines) != SCHEMATIC_TOTAL_HEIGHT:
        raise ValueError(f""Schematic must have {SCHEMATIC_TOTAL_HEIGHT} lines."")

    heights: Heights = [0] * SCHEMATIC_WIDTH
    for col_idx in range(SCHEMATIC_WIDTH):
        current_key_height = 0
        # Scan from bottom of interaction space (schematic_lines[INTERACTION_SPACE_LAST_ROW_IDX]) upwards
        # to schematic_lines[INTERACTION_SPACE_FIRST_ROW_IDX].
        for row_idx in range(INTERACTION_SPACE_LAST_ROW_IDX, INTERACTION_SPACE_FIRST_ROW_IDX - 1, -1):
            if schematic_lines[row_idx][col_idx] == '#':
                current_key_height += 1
            else:  # Key shape is broken by a '.', so it ends here
                break
        heights[col_idx] = current_key_height
    return heights

def parse_input(input_file: str) -> Tuple[List[Heights], List[Heights]]:
    """"""
    Parses the puzzle input file into lists of lock pin heights and key shape heights.
    """"""
    with open(input_file, 'r') as f:
        content = f.read().strip()

    schematic_blocks = content.split('\n\n')

    locks_pin_heights: List[Heights] = []
    keys_shape_heights: List[Heights] = []

    for block_idx, block in enumerate(schematic_blocks):
        if not block.strip(): # Skip empty blocks (e.g. from multiple newlines at end of file or between blocks)
            continue

        # Split block into lines, removing empty lines that might result from weird spacing within a block
        lines = [line.strip() for line in block.split('\n') if line.strip()]

        if len(lines) != SCHEMATIC_TOTAL_HEIGHT:
            print(f""Warning: Skipping malformed schematic block #{block_idx+1} with {len(lines)} lines (expected {SCHEMATIC_TOTAL_HEIGHT})."", file=sys.stderr)
            continue

        # Validate width of all lines in the current schematic block
        valid_width = True
        for line_idx, line_content in enumerate(lines):
            if len(line_content) != SCHEMATIC_WIDTH:
                print(f""Warning: Skipping malformed schematic block #{block_idx+1}. Line {line_idx+1} ('{line_content}') has width {len(line_content)}, expected {SCHEMATIC_WIDTH}."", file=sys.stderr)
                # print(f""Block content:\n{block}"", file=sys.stderr) # Uncomment for more detailed block dump
                valid_width = False
                break
        if not valid_width:
            continue

        first_row = lines[0]
        last_row = lines[SCHEMATIC_TOTAL_HEIGHT - 1] # e.g., lines[6] for 7-line schematics

        is_lock = (first_row == LOCK_TOP_ROW_PATTERN and last_row == LOCK_BOTTOM_ROW_PATTERN)
        is_key = (first_row == KEY_TOP_ROW_PATTERN and last_row == KEY_BOTTOM_ROW_PATTERN)

        if is_lock:
            try:
                pin_heights = _get_lock_pin_heights_from_schematic(lines)
                locks_pin_heights.append(pin_heights)
            except ValueError as e: # Should not be reached if SCHEMATIC_TOTAL_HEIGHT check passes
                 print(f""Error processing lock schematic block #{block_idx+1}: {e}"", file=sys.stderr)
        elif is_key:
            try:
                shape_heights = _get_key_shape_heights_from_schematic(lines)
                keys_shape_heights.append(shape_heights)
            except ValueError as e: # Should not be reached
                 print(f""Error processing key schematic block #{block_idx+1}: {e}"", file=sys.stderr)
        else:
            print(f""Warning: Unknown schematic type or malformed first/last rows for block #{block_idx+1}.\nFirst row: '{first_row}', Last row: '{last_row}'."", file=sys.stderr)
            # print(f""Block content:\n{block}"", file=sys.stderr) # Uncomment for more detailed block dump

    return locks_pin_heights, keys_shape_heights

def solve_part_one(parsed_data: Tuple[List[Heights], List[Heights]]) -> int:
    """"""
    Solves part one: counts unique lock/key pairs that fit together.
    A pair fits if for every column, lock_pin_height + key_shape_height <= INTERACTION_SPACE_HEIGHT.
    """"""
    locks_pin_heights, keys_shape_heights = parsed_data

    fit_count = 0

    if not locks_pin_heights or not keys_shape_heights:
        if sum(len(heights_list) for heights_list in parsed_data) > 0: # Only print if one list is empty but not both potentially due to file content
             print(""Warning: No locks or no keys found/parsed. Result will be 0."", file=sys.stderr)
        return 0

    for lock_idx, lock_h in enumerate(locks_pin_heights):
        for key_idx, key_h in enumerate(keys_shape_heights):
            does_fit = True
            for col_idx in range(SCHEMATIC_WIDTH):
                if lock_h[col_idx] + key_h[col_idx] > INTERACTION_SPACE_HEIGHT:
                    does_fit = False
                    break  # This column doesn't fit, so the pair doesn't fit

            if does_fit:
                fit_count += 1

    return fit_count

def run_tests():
    """"""Runs tests against the provided examples and some edge cases.""""""
    print(""Running tests..."", file=sys.stderr)

    # Test _get_lock_pin_heights_from_schematic
    lock_schematic_1_lines = [
        ""#####"", "".####"", "".####"", "".####"", "".#.#."", "".#..."", "".....""
    ]
    expected_lock_1_heights = [0, 5, 3, 4, 3]
    actual_lock_1_heights = _get_lock_pin_heights_from_schematic(lock_schematic_1_lines)
    assert actual_lock_1_heights == expected_lock_1_heights, \
        f""Test Lock 1 heights: Expected {expected_lock_1_heights}, Got {actual_lock_1_heights}""

    lock_schematic_2_lines = [
        ""#####"", ""##.##"", "".#.##"", ""...##"", ""...#."", ""...#."", "".....""
    ]
    expected_lock_2_heights = [1, 2, 0, 5, 3]
    actual_lock_2_heights = _get_lock_pin_heights_from_schematic(lock_schematic_2_lines)
    assert actual_lock_2_heights == expected_lock_2_heights, \
        f""Test Lock 2 heights: Expected {expected_lock_2_heights}, Got {actual_lock_2_heights}""

    # Test _get_key_shape_heights_from_schematic
    key_schematic_1_lines = [
        ""....."", ""#...."", ""#...."", ""#...#"", ""#.#.#"", ""#.###"", ""#####""
    ]
    expected_key_1_heights = [5, 0, 2, 1, 3]
    actual_key_1_heights = _get_key_shape_heights_from_schematic(key_schematic_1_lines)
    assert actual_key_1_heights == expected_key_1_heights, \
        f""Test Key 1 heights: Expected {expected_key_1_heights}, Got {actual_key_1_heights}""

    key_schematic_2_lines = [
        ""....."", ""....."", ""#.#.."", ""###.."", ""###.#"", ""###.#"", ""#####""
    ]
    expected_key_2_heights = [4, 3, 4, 0, 2]
    actual_key_2_heights = _get_key_shape_heights_from_schematic(key_schematic_2_lines)
    assert actual_key_2_heights == expected_key_2_heights, \
        f""Test Key 2 heights: Expected {expected_key_2_heights}, Got {actual_key_2_heights}""

    key_schematic_3_lines = [
        ""....."", ""....."", ""....."", ""#...."", ""#.#.."", ""#.#.#"", ""#####""
    ]
    expected_key_3_heights = [3, 0, 2, 0, 1]
    actual_key_3_heights = _get_key_shape_heights_from_schematic(key_schematic_3_lines)
    assert actual_key_3_heights == expected_key_3_heights, \
        f""Test Key 3 heights: Expected {expected_key_3_heights}, Got {actual_key_3_heights}""

    # Test solve_part_one with example data (using heights derived above)
    example_locks_heights = [expected_lock_1_heights, expected_lock_2_heights]
    example_keys_heights = [expected_key_1_heights, expected_key_2_heights, expected_key_3_heights]

    expected_fit_count = 3
    actual_fit_count = solve_part_one((example_locks_heights, example_keys_heights))
    assert actual_fit_count == expected_fit_count, \
        f""Test example fit count: Expected {expected_fit_count}, Got {actual_fit_count}""

    # Test with empty input lists (simulating empty or all-malformed file)
    empty_data = ([], [])
    assert solve_part_one(empty_data) == 0, ""Test empty data: Expected 0""
    empty_data_locks = ([expected_lock_1_heights], [])
    assert solve_part_one(empty_data_locks) == 0, ""Test empty keys list: Expected 0""
    empty_data_keys = ([], [expected_key_1_heights])
    assert solve_part_one(empty_data_keys) == 0, ""Test empty locks list: Expected 0""

    print(""All tests passed."", file=sys.stderr)


def main():
    """"""Main entry point for the solution.""""""
    if len(sys.argv) > 1 and sys.argv[1].lower() == ""test"":
        run_tests()
        return

    if len(sys.argv) < 2:
        print(f""Usage: python3 {sys.argv[0]} [input_file]"")
        print(f""   or: python3 {sys.argv[0]} test"")
        sys.exit(1)

    input_file = sys.argv[1]
    parsed_data: Tuple[List[Heights], List[Heights]]

    try:
        parsed_data = parse_input(input_file)
        # Check if input file was non-empty but parsing yielded nothing, indicating all blocks were malformed.
        # This is primarily for user feedback; solve_part_one handles empty lists correctly.
        with open(input_file, 'r') as f_check:
            is_input_file_contentful = bool(f_check.read().strip())

        if is_input_file_contentful and not parsed_data[0] and not parsed_data[1]:
             print(""Warning: Input file was not empty, but no valid schematics were parsed. All blocks may have been malformed or unrecognized. See previous warnings."", file=sys.stderr)

    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""An unexpected error occurred during parsing: {e}"", file=sys.stderr)
        sys.exit(1)

    part_one_solution = solve_part_one(parsed_data)

    # Per AoC custom, only print the final result to STDOUT for the solution part.
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
"
25,system,gemini-2.5-pro-preview-05-06,True,975.1917021274567,"""""""
Advent of Code Day 25: Code Chronicle (Placeholder for actual year/day/title)
Solution implementation for determining unique fitting lock/key pairs.

A lock and key pair fits if, for every corresponding column, the sum of
the lock's pin height and the key's protrusion height does not exceed
a specific 'available space'. The available space is N_ROWS - 2.
Heights are calculated based on consecutive '#' characters in columns
within an 'active region' (rows 1 to N_ROWS-2) of the schematic.

Usage: python3 solution.py [input_file]
""""""
import sys
from typing import List, Tuple

# Define test cases from the problem description
# The string from JSON will have '\\n'. In a Python string literal,
# this becomes a literal backslash followed by 'n'.
# We will replace ""\\n"" with ""\n"" (actual newline) before parsing.
EXAMPLE_TEST_CASES: List[Tuple[str, str]] = [
    (
      ""#####\\n.####\\n.####\\n.####\\n.#.#.\\n.#...\\n.....\\n\\n#####\\n##.##\\n.#.##\\n...##\\n...#.\\n...#.\\n.....\\n\\n.....\\n#....\\n#....\\n#...#\\n#.#.#\\n#.###\\n#####\\n\\n.....\\n.....\\n#.#..\\n###..\\n###.#\\n###.#\\n#####\\n\\n.....\\n.....\\n.....\\n#....\\n#.#..\\n#.#.#\\n#####"",
      ""3""
    )
]


def parse_schematics_from_string(input_str: str) -> List[List[str]]:
    """"""Parses schematics from a single string.""""""
    if not input_str.strip(): # Handle empty or whitespace-only input
        return []

    schematic_blocks_raw = input_str.split(""\n\n"")
    # Filter out any empty blocks that might result from multiple blank lines
    schematic_blocks = [block for block in schematic_blocks_raw if block.strip()]

    parsed_schematics = []
    for block in schematic_blocks:
        # Split each block by single newlines to get rows.
        # Do not strip individual lines here, to preserve their exact content for column checks.
        lines = block.split(""\n"")
        if lines: # Ensure the block wasn't just whitespace producing an empty list of lines
            parsed_schematics.append(lines)
    return parsed_schematics

def parse_input_file(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into list of schematics.""""""
    with open(input_file, 'r') as f:
        content = f.read()
    return parse_schematics_from_string(content)

def extract_heights(schematic_rows: List[str], schematic_type: str, N_ROWS: int, N_COLS: int) -> List[int]:
    """"""
    Extracts column heights for a given schematic.
    Active region for height calculation is rows 1 to N_ROWS-2 (0-indexed).
    """"""
    column_heights = [0] * N_COLS

    # If N_ROWS < 3, the active region (rows 1 to N_ROWS-2) is empty or invalid.
    # In this case, heights remain all zeros as per initialization.
    if N_ROWS < 3:
        return column_heights

    for col_idx in range(N_COLS):
        current_col_height = 0
        if schematic_type == ""lock"":
            # Count consecutive '#' downwards from row 1 (0-indexed), inclusive,
            # up to row N_ROWS-2 (0-indexed), inclusive.
            for row_idx in range(1, N_ROWS - 1): # Iterates 1, 2, ..., N_ROWS-2
                # Boundary checks for row and column access, though problem implies valid structure
                if row_idx >= len(schematic_rows) or col_idx >= len(schematic_rows[row_idx]):
                    break
                if schematic_rows[row_idx][col_idx] == '#':
                    current_col_height += 1
                else:
                    break # Stop at first non-'#' or end of active region for this column
            column_heights[col_idx] = current_col_height
        elif schematic_type == ""key"":
            # Count consecutive '#' upwards from row N_ROWS-2 (0-indexed), inclusive,
            # down to row 1 (0-indexed), inclusive.
            for row_idx in range(N_ROWS - 2, 0, -1): # Iterates N_ROWS-2, N_ROWS-3, ..., 1
                if row_idx >= len(schematic_rows) or col_idx >= len(schematic_rows[row_idx]):
                    break
                if schematic_rows[row_idx][col_idx] == '#':
                    current_col_height += 1
                else:
                    break # Stop at first non-'#' or end of active region for this column
            column_heights[col_idx] = current_col_height

    return column_heights

def solve(parsed_schematics: List[List[str]]) -> int:
    """"""Solve the puzzle: count fitting lock/key pairs.""""""
    if not parsed_schematics:
        return 0

    first_schematic = parsed_schematics[0]
    if not first_schematic:
        sys.stderr.write(""Warning: First schematic is empty after parsing.\n"")
        return 0

    N_ROWS = len(first_schematic)
    if N_ROWS == 0:
        sys.stderr.write(""Warning: First schematic has no rows.\n"")
        return 0
    N_COLS = len(first_schematic[0]) # Assumes first row is representative for N_COLS
    if N_COLS == 0:
        sys.stderr.write(""Warning: First schematic has empty rows (0 columns).\n"")
        return 0

    available_space = N_ROWS - 2

    all_lock_heights: List[List[int]] = []
    all_key_heights: List[List[int]] = []

    expected_top_row_lock = '#' * N_COLS
    expected_bottom_row_lock = '.' * N_COLS
    expected_top_row_key = '.' * N_COLS
    expected_bottom_row_key = '#' * N_COLS

    for i, schematic_rows in enumerate(parsed_schematics):
        if len(schematic_rows) != N_ROWS:
            sys.stderr.write(f""Warning: Schematic {i} has {len(schematic_rows)} rows, expected {N_ROWS}. Skipping.\n"")
            continue
        if any(len(row) != N_COLS for row in schematic_rows):
            sys.stderr.write(f""Warning: Schematic {i} has rows with inconsistent column count (expected {N_COLS}). Skipping.\n"")
            continue

        if N_ROWS < 2: # Cannot classify if less than 2 rows for top/bottom.
            # This case would also mean N_ROWS < 3, so available_space is <=0 and heights are 0.
            # Depending on available_space (0 or negative), pairs might all fit or none fit.
            # However, problem structure implies N_ROWS is reasonably large (e.g. >=3).
            sys.stderr.write(f""Warning: Schematic {i} has N_ROWS < 2 ({N_ROWS}), cannot classify. Skipping classification."")
            continue

        top_row = schematic_rows[0]
        bottom_row = schematic_rows[N_ROWS-1]

        schematic_type = None
        if top_row == expected_top_row_lock and bottom_row == expected_bottom_row_lock:
            schematic_type = ""lock""
        elif top_row == expected_top_row_key and bottom_row == expected_bottom_row_key:
            schematic_type = ""key""

        if schematic_type:
            heights = extract_heights(schematic_rows, schematic_type, N_ROWS, N_COLS)
            if schematic_type == ""lock"":
                all_lock_heights.append(heights)
            else: # ""key""
                all_key_heights.append(heights)

    fitting_pairs_count = 0
    if not all_lock_heights or not all_key_heights:
        return 0

    for lock_profile in all_lock_heights:
        for key_profile in all_key_heights:
            is_a_fit = True
            if len(lock_profile) != N_COLS or len(key_profile) != N_COLS:
                # This should not happen if parsing and height extraction are correct
                sys.stderr.write(f""Error: A lock or key profile has inconsistent column count. Lock: {len(lock_profile)}, Key: {len(key_profile)}, Expected: {N_COLS}.\n"")
                is_a_fit = False
            else:
                for col_idx in range(N_COLS):
                    if lock_profile[col_idx] + key_profile[col_idx] > available_space:
                        is_a_fit = False
                        break

            if is_a_fit:
                fitting_pairs_count += 1

    return fitting_pairs_count

def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    # Prepare test cases by replacing literal ""\\n"" with actual newlines ""\n""
    processed_test_cases = []
    for input_str, expected_str in EXAMPLE_TEST_CASES:
        actual_input_str = input_str.replace(""\\n"", ""\n"")
        processed_test_cases.append((actual_input_str, expected_str))

    if processed_test_cases:
        print(""--- Running Test Cases ---"", file=sys.stderr)
        all_tests_passed = True
        for i, (example_input_str, expected_output_str) in enumerate(processed_test_cases):
            sys.stderr.write(f""Test Case {i+1}:\n"")
            example_data = parse_schematics_from_string(example_input_str)
            actual_output = solve(example_data)

            if str(actual_output) == expected_output_str:
                sys.stderr.write(f""  Expected: {expected_output_str}, Got: {actual_output} -> PASSED\n"")
            else:
                sys.stderr.write(f""  Expected: {expected_output_str}, Got: {actual_output} -> FAILED\n"")
                all_tests_passed = False

        if not all_tests_passed:
             sys.stderr.write(""One or more example test cases FAILED.\n"")
        # To halt on test failure: assert all_tests_passed, ""One or more example test cases failed.""
        print(""--- Finished Test Cases ---"", file=sys.stderr)

    input_file = sys.argv[1]
    try:
        parsed_data = parse_input_file(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        return
    except Exception as e:
        print(f""Error parsing input file: {e}"", file=sys.stderr)
        return

    solution = solve(parsed_data)
    print(solution) # Print final solution to STDOUT

if __name__ == ""__main__"":
    main()
"
1,single-model,gpt-4.1-mini,False,24.827049732208252," """"""
Advent of Code Day 1: Historian Hysteria

This solution reads two columns of numbers representing two lists of location IDs.
It computes the total distance between the two lists by pairing the sorted elements
and summing the absolute differences.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse the input file into two lists of integers representing left and right columns.

    Args:
        input_file: Path to the input puzzle file.

    Returns:
        A tuple of two integer lists: (left_list, right_list).
    """"""
    left_list: List[int] = []
    right_list: List[int] = []

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                # Skip empty lines
                continue
            parts = line.split()
            if len(parts) != 2:
                # Skip or raise error if line format is unexpected
                raise ValueError(f""Invalid line format: '{line}' Expected exactly two numbers separated by whitespace."")
            try:
                left_num = int(parts[0])
                right_num = int(parts[1])
            except ValueError as e:
                raise ValueError(f""Non-integer value found in line: '{line}'"") from e

            left_list.append(left_num)
            right_list.append(right_num)

    return left_list, right_list


def total_distance(left_list: List[int], right_list: List[int]) -> int:
    """"""Compute total distance between two lists of numbers by pairing their sorted elements and summing absolute differences.

    Args:
        left_list: First list of integers.
        right_list: Second list of integers.

    Returns:
        The sum of absolute differences between paired elements.
    """"""
    if len(left_list) != len(right_list):
        raise ValueError(""Left and right lists must be of the same length."")

    left_sorted = sorted(left_list)
    right_sorted = sorted(right_list)

    total = 0
    for l_val, r_val in zip(left_sorted, right_sorted):
        diff = abs(l_val - r_val)
        total += diff

    return total


def solve(input_file: str) -> int:
    """"""Main solving function.

    Args:
        input_file: Path to the input file.

    Returns:
        The total distance between the two location ID lists.
    """"""
    left_list, right_list = parse_input(input_file)
    return total_distance(left_list, right_list)


def run_example_tests() -> None:
    """"""Run provided example test to verify correctness.""""""
    example_input = [
        (3, 4),
        (4, 3),
        (2, 5),
        (1, 3),
        (3, 9),
        (3, 3)
    ]

    left_example = [pair[0] for pair in example_input]
    right_example = [pair[1] for pair in example_input]

    expected_total_distance = 11

    computed_distance = total_distance(left_example, right_example)
    assert computed_distance == expected_total_distance, f""Example test failed: expected {expected_total_distance}, got {computed_distance}""


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    # Run example tests
    try:
        run_example_tests()
    except AssertionError as e:
        print(f""Example test assertion failed: {e}"", file=sys.stderr)
        sys.exit(1)

    # Solve the puzzle
    try:
        result = solve(input_file)
    except Exception as e:
        print(f""Error during solving: {e}"", file=sys.stderr)
        sys.exit(1)

    # ONLY print the final result
    print(result)


if __name__ == ""__main__"":
    main()
"
1,system,gpt-4.1-mini,True,116.31338024139404,"""""""
Advent of Code - Historian Hysteria (Day 1)

This script reads pairs of integers representing two location ID lists,
sorts both lists, pairs elements by index, computes the absolute differences,
then sums these differences to output the total distance.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse input file, extracting two lists of integers from each line.

    Args:
        input_file: Path to the puzzle input file.

    Returns:
        A tuple of two lists of integers: (left_list, right_list).
    """"""
    left_list: List[int] = []
    right_list: List[int] = []
    with open(input_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            stripped = line.strip()
            if not stripped:
                # Skip empty lines if any
                continue
            parts = stripped.split()
            if len(parts) != 2:
                raise ValueError(f""Invalid input format at line {line_num}: expected 2 integers, got {len(parts)} parts"")
            try:
                left_val = int(parts[0])
                right_val = int(parts[1])
            except ValueError as e:
                raise ValueError(f""Invalid integer value at line {line_num}: {e}"")
            left_list.append(left_val)
            right_list.append(right_val)
    if len(left_list) != len(right_list):
        raise ValueError(""Input lists have different lengths, which is unexpected."")
    if not left_list:
        raise ValueError(""Input is empty. No pairs to process."")
    return left_list, right_list


def compute_total_distance(left_list: List[int], right_list: List[int]) -> int:
    """"""Compute the total sum of absolute differences between paired elements
    after sorting both lists.

    Args:
        left_list: List of integers from the left side.
        right_list: List of integers from the right side.

    Returns:
        The total sum of absolute differences between paired elements.
    """"""
    sorted_left = sorted(left_list)
    sorted_right = sorted(right_list)

    total_distance = 0
    for i, (l_val, r_val) in enumerate(zip(sorted_left, sorted_right)):
        diff = abs(l_val - r_val)
        total_distance += diff
    return total_distance


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    try:
        left_list, right_list = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    result = compute_total_distance(left_list, right_list)
    print(result)


if __name__ == ""__main__"":
    main()
"
2,single-model,gpt-4.1-mini,True,24.25560474395752,"import sys
from typing import List

""""""
Advent of Code Day 2: Red-Nosed Reports

We determine whether each report (a list of integer levels) is ""safe"" according to rules:
- Levels must be strictly monotonic increasing or strictly monotonic decreasing.
- Adjacent levels differ by at least 1 and at most 3.

The program reads the puzzle input file where each line is a space-separated list of integers representing levels.
It outputs the count of safe reports.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input into a list of reports.

    Each report is a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        List of reports, each report is a list of levels (ints).
    """"""
    reports = []
    with open(input_file, 'r') as file:
        for line in file:
            stripped = line.strip()
            if not stripped:
                # Skip empty lines
                continue
            # Parse line into integers
            try:
                levels = list(map(int, stripped.split()))
                reports.append(levels)
            except ValueError as ve:
                # If a line has invalid data, raise error
                raise ValueError(f""Invalid line in input (non-integer value): '{line.strip()}'"") from ve
    return reports


def is_safe_report(levels: List[int]) -> bool:
    """"""Check if a single report is safe.

    Rules:
    - Levels are strictly monotonic increasing or strictly monotonic decreasing
    - Adjacent levels differ by at least 1 and at most 3 (absolute difference)

    Args:
        levels: List of integer levels

    Returns:
        True if the report is safe, False otherwise
    """"""
    if len(levels) < 2:
        # Trivially safe if only one level (no adjacent differences to compare)
        return True

    # Determine monotonicity direction
    diffs = []
    for i in range(len(levels) - 1):
        diff = levels[i + 1] - levels[i]
        # Adjacent levels must differ by at least 1 and at most 3
        abs_diff = abs(diff)
        if abs_diff < 1 or abs_diff > 3:
            # Difference out of allowed bounds
            return False
        diffs.append(diff)

    # Check whether all diffs are positive (strictly increasing) or all negative (strictly decreasing)
    all_increasing = all(d > 0 for d in diffs)
    all_decreasing = all(d < 0 for d in diffs)

    # If neither fully increasing nor fully decreasing, unsafe
    if not (all_increasing or all_decreasing):
        return False

    return True


def count_safe_reports(reports: List[List[int]]) -> int:
    """"""Count how many reports are safe among given reports.

    Args:
        reports: List of reports (list of levels)

    Returns:
        Integer count of safe reports
    """"""
    count = 0
    for report in reports:
        if is_safe_report(report):
            count += 1
    return count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        reports = parse_input(input_file)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)

    safe_count = count_safe_reports(reports)

    # Output only the final result as required
    print(safe_count)


if __name__ == ""__main__"":
    main()
"
2,system,gpt-4.1-mini,True,137.46358180046082,"""""""
Advent of Code - Day 2: Red-Nosed Reports

This solution reads multiple reports from an input file, where each report is a sequence of integer levels.
It checks each report to determine if it is 'safe' based on the following criteria:
- The sequence is strictly monotonically increasing OR strictly monotonically decreasing.
- Adjacent levels differ by at least 1 and at most 3 (inclusive).

Outputs the count of safe reports.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys


def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input into a list of reports, each report is a list of integers.

    Args:
        input_file: Path to the input file.

    Returns:
        List of lists of integers, each inner list is a report.
    """"""
    reports = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue  # Skip empty lines
            levels = list(map(int, line.split()))
            reports.append(levels)
    return reports


def is_safe_report(levels: List[int]) -> bool:
    """"""Check if a report is safe.

    Conditions:
    - Levels must be strictly monotonically increasing or decreasing.
    - Adjacent differences must be between 1 and 3 inclusive.

    Args:
        levels: List of integers representing the levels.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    n = len(levels)
    if n < 2:
        # With less than two levels, trivially safe since no adjacent pairs to contradict.
        return True

    differences = []
    for i in range(n - 1):
        diff = levels[i + 1] - levels[i]
        # Difference zero or absolute > 3 invalidates the report immediately
        if diff == 0 or abs(diff) > 3:
            return False
        differences.append(diff)

    # Check if all differences are positive (strictly increasing)
    all_increasing = all(d > 0 for d in differences)
    # Check if all differences are negative (strictly decreasing)
    all_decreasing = all(d < 0 for d in differences)

    # The report is safe only if strictly increasing or strictly decreasing
    return all_increasing or all_decreasing


def solve(reports: List[List[int]]) -> int:
    """"""Count how many reports are safe.

    Args:
        reports: List of lists, where each inner list contains levels of a report.

    Returns:
        Integer count of safe reports.
    """"""
    safe_count = 0
    for report in reports:
        if is_safe_report(report):
            safe_count += 1
    return safe_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    reports = parse_input(input_file)

    result = solve(reports)
    print(result)


if __name__ == ""__main__"":
    main()
"
3,single-model,gpt-4.1-mini,True,19.930848121643066,"import sys
import re
from typing import List

""""""
Advent of Code - Day 3: Mull It Over

This solution scans corrupted memory input to find valid 'mul(X,Y)' instructions where X and Y are 1-3 digit numbers,
perform multiplications, and returns the sum of all these results.

Only perfectly formatted mul instructions with no extra characters inside or around the parentheses,
no extra spaces, and using parentheses with a comma are counted.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> str:
    """"""
    Reads the entire content of the input file as a single string.

    Args:
        input_file (str): Path to the input file.

    Returns:
        str: The corrupted memory string.
    """"""
    with open(input_file, 'r', encoding='utf-8') as f:
        return f.read()


def find_and_sum_mul_instructions(memory: str) -> int:
    """"""
    Find all valid 'mul(X,Y)' instructions in the corrupted memory and sum their multiplication results.

    A valid instruction matches exactly: mul(number,number)
    where number is 1 to 3 digits.

    Args:
        memory (str): The corrupted memory string.

    Returns:
        int: Sum of all multiplication results from valid instructions.
    """"""
    # Regex explanation:
    # \bmu l : match 'mul' as a whole word
    # \( : literal opening parenthesis
    # (\d{1,3}) : group 1, first number, 1-3 digits
    # , : literal comma
    # (\d{1,3}) : group 2, second number, 1-3 digits
    # \) : literal closing parenthesis
    pattern = re.compile(r'\bmul\((\d{1,3}),(\d{1,3})\)')

    total = 0
    for match in pattern.finditer(memory):
        x_str, y_str = match.groups()
        x = int(x_str)
        y = int(y_str)
        product = x * y
        total += product

    return total


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    memory = parse_input(input_file)

    result = find_and_sum_mul_instructions(memory)

    # Print only the final result
    print(result)


if __name__ == ""__main__"":
    main()"
3,system,gpt-4.1-mini,True,139.48460388183594,"""""""
Advent of Code - Day 3: Mull It Over

This solution scans a corrupted memory string to find all valid 'mul(X,Y)'
instructions where X and Y are integers from 0 to 999 with no leading zeros
(except zero itself). It calculates the sum of the products of all valid pairs.

Usage: python3 solution.py [input_file]
""""""

import sys
import re
from typing import List, Tuple


def parse_input(input_file: str) -> str:
    """"""Reads the entire input file as a single string without modification.

    Args:
        input_file: Path to the input file

    Returns:
        The raw corrupted memory string to be scanned.
    """"""
    with open(input_file, 'r', encoding='utf-8') as f:
        return f.read()


def compile_mul_pattern() -> re.Pattern:
    """"""Compiles a regular expression pattern matching valid mul(X,Y) instructions.

    The pattern enforces:
      - Exact literal 'mul('
      - X is 0 or a number with 1-3 digits and no leading zeros (except zero itself)
      - A literal comma ',' with no spaces
      - Y follows the same rules as X
      - Closing parenthesis ')'
      - No extra spaces or characters

    Returns:
        Compiled regex pattern with two capture groups for X and Y.
    """"""
    # Pattern for an integer with no leading zeros except zero itself:
    # either '0' OR a digit from 1-9 followed by zero, one or two digits
    num_pattern = r'(0|[1-9]\d{0,2})'
    pattern_str = f'mul\({num_pattern},{num_pattern}\)'
    return re.compile(pattern_str)


def extract_mul_pairs(corrupted_memory: str, pattern: re.Pattern) -> List[Tuple[int, int]]:
    """"""Finds all valid mul(X,Y) pairs in the corrupted memory string.

    Args:
        corrupted_memory: The input corrupted memory string.
        pattern: Compiled regex pattern matching valid mul instructions.

    Returns:
        A list of integer tuples (X, Y) from all valid matches.
    """"""
    pairs = []
    for match in pattern.finditer(corrupted_memory):
        x_str, y_str = match.group(1), match.group(2)
        x, y = int(x_str), int(y_str)
        pairs.append((x, y))
    return pairs


def sum_of_products(pairs: List[Tuple[int, int]]) -> int:
    """"""Calculates the sum of products of integer pairs.

    Args:
        pairs: List of tuples (X, Y)

    Returns:
        The sum of all X * Y
    """"""
    return sum(x * y for x, y in pairs)


def main():
    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    corrupted_memory = parse_input(input_file)

    pattern = compile_mul_pattern()

    pairs = extract_mul_pairs(corrupted_memory, pattern)

    result = sum_of_products(pairs)

    # Print final result to stdout as required
    print(result)


if __name__ == '__main__':
    main()
"
4,single-model,gpt-4.1-mini,True,19.855156421661377,"from typing import List, Tuple
import sys

""""""
Advent of Code Day 4: Ceres Search

This solution searches for all occurrences of the word 'XMAS' in a given word search grid.
Words can appear horizontally, vertically, diagonally, forwards, and backwards.

Approach:
- Parse the input grid into a 2D list of characters.
- Define all 8 directions to search from every cell.
- For each cell in the grid, attempt to find 'XMAS' in every direction.
- Count all occurrences found.

This implementation handles edge cases, such as grids with no occurrences, small grids, or irregular inputs.

Usage:
    python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input into a 2D character grid.""""""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip() != '']
    # Each line represents a row of letters
    grid = [list(line) for line in lines]
    return grid


def find_word_occurrences(grid: List[List[str]], word: str) -> int:
    """"""Find total occurrences of 'word' in grid in all 8 directions.

    Args:
        grid: 2D list of characters
        word: The target word to search for

    Returns:
        Total count of occurrences found
    """"""
    if not grid or not grid[0]:
        return 0

    rows = len(grid)
    cols = len(grid[0])
    word_len = len(word)

    # All 8 directions: horizontal, vertical, diagonal
    directions: List[Tuple[int, int]] = [
        (0, 1),   # right
        (0, -1),  # left
        (1, 0),   # down
        (-1, 0),  # up
        (1, 1),   # down-right diagonal
        (1, -1),  # down-left diagonal
        (-1, 1),  # up-right diagonal
        (-1, -1)  # up-left diagonal
    ]

    def within_bounds(r: int, c: int) -> bool:
        return 0 <= r < rows and 0 <= c < cols

    count = 0

    # For each cell, search in each direction
    for r in range(rows):
        for c in range(cols):
            # If first letter matches, check for full word
            if grid[r][c] == word[0]:
                for dr, dc in directions:
                    nr, nc = r, c
                    match = True
                    for i in range(1, word_len):
                        nr += dr
                        nc += dc
                        if not within_bounds(nr, nc):
                            match = False
                            break
                        if grid[nr][nc] != word[i]:
                            match = False
                            break
                    if match:
                        count += 1
    return count


def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one: count total occurrences of 'XMAS' in the word search grid.""""""
    return find_word_occurrences(grid, 'XMAS')


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    grid = parse_input(input_file)

    total_occurrences = solve_part_one(grid)
    print(total_occurrences)


if __name__ == ""__main__"":
    main()
"
4,system,gpt-4.1-mini,True,352.67389392852783,"""""""
Advent of Code: Day 4 - Ceres Search
Find total occurrences of the word 'XMAS' in a given word search grid.
Occurrences can appear horizontally, vertically, diagonally (both major and minor),
forwards and backwards.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the input file into a 2D grid of characters.

    Args:
        input_file: Path to the input file

    Returns:
        2D list of characters (grid)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip() != '']

    if not lines:
        return []

    line_length = len(lines[0])
    # Verify all lines have the same length
    for idx, line in enumerate(lines):
        if len(line) != line_length:
            raise ValueError(f""Line {idx+1} length ({len(line)}) does not match first line length ({line_length})"")

    grid = [list(line) for line in lines]
    return grid


def directions() -> List[Tuple[int, int]]:
    """"""Return the eight possible directions as (row_delta, col_delta).""""""
    return [
        (0, 1),   # left to right
        (0, -1),  # right to left
        (1, 0),   # top to bottom
        (-1, 0),  # bottom to top
        (1, 1),   # diagonal down-right
        (1, -1),  # diagonal down-left
        (-1, 1),  # diagonal up-right
        (-1, -1)  # diagonal up-left
    ]


def count_occurrences_at(grid: List[List[str]], start_row: int, start_col: int,
                         direction: Tuple[int, int], word: str) -> int:
    """"""Check if the word occurs starting at (start_row, start_col) in given direction.

    Args:
        grid: 2D character grid
        start_row: Starting row index
        start_col: Starting column index
        direction: Tuple of (row_delta, col_delta)
        word: Target word to find

    Returns:
        1 if the word occurs here in this direction, else 0
    """"""
    max_row = len(grid)
    max_col = len(grid[0]) if max_row > 0 else 0
    dr, dc = direction
    word_len = len(word)

    # Check bounds to ensure the entire word fits
    end_row = start_row + dr * (word_len - 1)
    end_col = start_col + dc * (word_len - 1)
    if not (0 <= end_row < max_row and 0 <= end_col < max_col):
        return 0

    for i in range(word_len):
        r = start_row + dr * i
        c = start_col + dc * i
        if grid[r][c] != word[i]:
            return 0

    return 1


def count_total_occurrences(grid: List[List[str]], word: str) -> int:
    """"""Count total occurrences of the word in all directions in the grid.

    Args:
        grid: 2D character grid
        word: Target word to find

    Returns:
        Total count of occurrences
    """"""
    if not grid or not grid[0]:
        return 0

    total_count = 0
    directions_list = directions()
    rows = len(grid)
    cols = len(grid[0])

    # For each cell and direction, check for occurrence
    for r in range(rows):
        for c in range(cols):
            for dir_vec in directions_list:
                total_count += count_occurrences_at(grid, r, c, dir_vec, word)

    return total_count


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    target_word = ""XMAS""

    result = count_total_occurrences(grid, target_word)

    # Only print the final count to stdout
    print(result)


if __name__ == ""__main__"":
    main()
"
5,single-model,gpt-4.1-mini,True,20.910573482513428,"import sys
from typing import List, Tuple, Set, Dict


def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse the puzzle input file into ordering rules and updates lists.

    Args:
        input_file: Path to the puzzle input file.

    Returns:
        A tuple containing:
          - list of ordering rules as tuples (X, Y) meaning X must come before Y
          - list of updates, each update is a list of page numbers in given order
    """"""
    rules = []
    updates = []
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip()]  # Ignore empty lines

    # Separate rules and updates: rules lines contain '|', updates contain commas.
    # Problem states rules come first, then updates.
    # Find index where updates start (line contains commas)
    idx = 0
    for i, line in enumerate(lines):
        if ',' in line:
            idx = i
            break

    # Parse rules
    for line in lines[:idx]:
        if '|' in line:
            parts = line.split('|')
            if len(parts) != 2:
                raise ValueError(f""Invalid rule format: {line}"")
            try:
                x = int(parts[0])
                y = int(parts[1])
            except ValueError:
                raise ValueError(f""Non-integer page number in rule: {line}"")
            rules.append((x, y))

    # Parse updates
    for line in lines[idx:]:
        try:
            pages = [int(p.strip()) for p in line.split(',') if p.strip() != '']
            if pages:
                updates.append(pages)
        except ValueError:
            raise ValueError(f""Non-integer page number in update: {line}"")

    return rules, updates


def is_update_correctly_ordered(rules: List[Tuple[int, int]], update: List[int]) -> bool:
    """"""Check if given update respects all ordering rules involving pages within the update.

    Args:
        rules: List of ordering rules as tuples (X, Y) where X must come before Y
        update: List of page numbers in their printed order

    Returns:
        True if update respects all applicable ordering rules, False otherwise
    """"""
    # Create a map from page to its index in update for O(1) lookup
    position: Dict[int, int] = {}
    for idx, page in enumerate(update):
        position[page] = idx

    # Only rules where both pages are in the update are relevant
    for x, y in rules:
        if x in position and y in position:
            # Check if x appears before y
            if position[x] >= position[y]:
                # Violation
                return False
    return True


def middle_page(update: List[int]) -> int:
    """"""Return the middle page number of an update.

    For odd length updates, this is the exact middle.
    For even length updates (not specified by problem, but assuming odd lengths),
    this method returns the lower middle (floor division).

    Args:
        update: List of page numbers in order

    Returns:
        The middle page number
    """"""
    length = len(update)
    mid_idx = length // 2
    return update[mid_idx]


def solve(rules: List[Tuple[int, int]], updates: List[List[int]]) -> int:
    """"""Solve the puzzle by summing the middle page numbers of all correctly ordered updates.

    Args:
        rules: List of ordering rules
        updates: List of updates (list of page numbers)

    Returns:
        Sum of middle page numbers of updates correctly respecting the rules
    """"""
    total = 0
    for update in updates:
        if is_update_correctly_ordered(rules, update):
            total += middle_page(update)
    return total


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    rules, updates = parse_input(input_file)

    result = solve(rules, updates)
    print(result)


if __name__ == '__main__':
    main()
"
5,system,gpt-4.1-mini,True,191.69801354408264,"""""""
Advent of Code 2018 Day 5: Print Queue

Determine which updates obey all given ordering constraints and sum the middle pages of valid updates.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Dict
import sys


def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse input file to extract ordering constraints and updates.

    Args:
        input_file: Path to input file

    Returns:
        A tuple containing:
        - List of ordering constraints as tuples (X, Y) where X must come before Y
        - List of updates, each being a list of page numbers
    """"""
    constraints: List[Tuple[int, int]] = []
    updates: List[List[int]] = []
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Split input into two parts at the first blank line
    try:
        blank_line_index = lines.index('')
    except ValueError:
        # No blank line, assume all constraints then updates
        # (Unlikely, but fallback)
        blank_line_index = len(lines)

    constraint_lines = lines[:blank_line_index]
    update_lines = lines[blank_line_index+1:]  # after blank line

    # Parse constraints
    for line in constraint_lines:
        if not line:
            continue
        if '|' not in line:
            continue  # skip malformed lines
        parts = line.split('|')
        if len(parts) != 2:
            continue
        try:
            x = int(parts[0].strip())
            y = int(parts[1].strip())
            constraints.append((x, y))
        except ValueError:
            # Skip malformed lines
            continue

    # Parse updates
    for line in update_lines:
        if not line:
            continue
        try:
            pages = [int(p.strip()) for p in line.split(',') if p.strip() != '']
            if pages:
                updates.append(pages)
        except ValueError:
            continue

    return constraints, updates


def is_update_valid(ordering_rules: List[Tuple[int, int]], update: List[int]) -> bool:
    """"""Check if an update respects all applicable ordering constraints.

    Args:
        ordering_rules: List of (X, Y) constraints where X must come before Y
        update: List of page numbers in the update

    Returns:
        True if update respects all constraints, False otherwise
    """"""
    page_positions: Dict[int, int] = {page: idx for idx, page in enumerate(update)}
    pages_set = set(update)

    for x, y in ordering_rules:
        # Constraint applies only if both pages present
        if x in pages_set and y in pages_set:
            if page_positions[x] >= page_positions[y]:
                # Violated ordering
                return False
    return True


def sum_middle_pages_of_valid_updates(ordering_rules: List[Tuple[int, int]], updates: List[List[int]]) -> int:
    """"""For all valid updates, sum their middle page numbers.

    Args:
        ordering_rules: List of ordering constraints
        updates: List of updates (pages lists)

    Returns:
        Sum of middle page numbers of valid updates
    """"""
    total_sum = 0
    for update in updates:
        if is_update_valid(ordering_rules, update):
            middle_index = len(update) // 2  # zero-based floor division
            middle_page = update[middle_index]
            total_sum += middle_page
    return total_sum


def main():
    if len(sys.argv) != 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    ordering_rules, updates = parse_input(input_file)

    result = sum_middle_pages_of_valid_updates(ordering_rules, updates)

    print(result)


if __name__ == '__main__':
    main()
"
6,single-model,gpt-4.1-mini,True,30.317673444747925,"""""""
Advent of Code 2018 Day 6: Guard Gallivant
Solution implementation based on the provided problem description.

The problem describes a grid containing obstacles (#) and a single guard facing a direction (^, >, v, <).
The guard moves according to the patrol protocol:
  - If there is an obstacle directly in front, turn right 90 degrees.
  - Otherwise, move one step forward.

The guard continues this until it leaves the mapped area (moves outside the grid).

We must track all distinct positions the guard visits (including the start), and output how many such positions are visited before the guard leaves the area.

Approach:
- Parse grid from input.
- Find guard's starting position and direction.
- Simulate the guard's movement until it leaves the grid.
- Keep track of visited positions in a set.
- Return the count of visited positions.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

# Direction deltas and turning logic
DIRECTIONS = ['^', '>', 'v', '<']  # Up, Right, Down, Left
DELTA = {
    '^': (-1, 0),
    '>': (0, 1),
    'v': (1, 0),
    '<': (0, -1),
}


def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], str]:
    """"""Parse the puzzle input file into the lab map, find guard start position and direction.

    Args:
        input_file: Path to the input file

    Returns:
        grid: 2D list of characters representing the map
        start_pos: Tuple of (row, col) for guard's starting position
        start_dir: A character '^', '>', 'v', '<' indicating guard's initial facing direction
    """"""
    grid = []
    start_pos = None
    start_dir = None

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            line = line.rstrip('\n')
            if not line:
                # skip empty lines if any
                continue
            row = list(line)
            for c, ch in enumerate(row):
                if ch in DIRECTIONS:
                    start_pos = (r, c)
                    start_dir = ch
                    # Replace guard char with '.' in map since guard is tracked separately
                    row[c] = '.'
            grid.append(row)

    if start_pos is None or start_dir is None:
        raise ValueError(""Guard starting position or direction not found in input."")

    return grid, start_pos, start_dir


def turn_right(current_direction: str) -> str:
    """"""Return the direction after turning right 90 degrees.

    Args:
        current_direction: One of '^', '>', 'v', '<'

    Returns:
        New direction after turning right.
    """"""
    idx = DIRECTIONS.index(current_direction)
    # Turning right moves to the next direction in DIRECTIONS list modulo length
    new_dir = DIRECTIONS[(idx + 1) % len(DIRECTIONS)]
    return new_dir


def simulate_guard_path(grid: List[List[str]], start_pos: Tuple[int, int], start_dir: str) -> Set[Tuple[int, int]]:
    """"""Simulate the guard's movement until it leaves the map.

    Args:
        grid: 2D grid map
        start_pos: starting (row, col) position
        start_dir: starting direction ('^', '>', 'v', '<')

    Returns:
        Set of visited positions (row, col) including start.
    """"""
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    pos = start_pos
    direction = start_dir
    visited = set()
    visited.add(pos)

    while True:
        dr, dc = DELTA[direction]
        nr, nc = pos[0] + dr, pos[1] + dc

        # Check if next position is inside the grid
        if not (0 <= nr < rows and 0 <= nc < cols):
            # The guard has left the mapped area
            break

        # Check if next position is obstacle
        if grid[nr][nc] == '#':
            # Turn right and do not move
            direction = turn_right(direction)
        else:
            # Move forward
            pos = (nr, nc)
            visited.add(pos)

    return visited


def solve_part_one(grid: List[List[str]], start_pos: Tuple[int, int], start_dir: str) -> int:
    """"""Solve part one: count distinct visited positions by the guard before leaving the map.

    Args:
        grid: 2D map
        start_pos: starting guard position
        start_dir: starting guard direction

    Returns:
        Number of distinct positions visited
    """"""
    visited_positions = simulate_guard_path(grid, start_pos, start_dir)
    return len(visited_positions)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Parse input
    grid, start_pos, start_dir = parse_input(input_file)

    # Solve
    result = solve_part_one(grid, start_pos, start_dir)

    # Print only the result
    print(result)


if __name__ == '__main__':
    main()
"
6,system,gpt-4.1-mini,True,196.95737600326538,"""""""
Advent of Code 2022 Day 6: Guard Gallivant

Solution implements simulation of a guard moving on a 2D grid:
- The guard moves forward if possible.
- If an obstacle or map boundary is ahead, guard turns right 90 degrees.
- Simulation continues until the guard moves off the map.
- Tracks all distinct positions visited by the guard, including the start.

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple, Set
import sys

# Direction order corresponds to turning right (clockwise): up -> right -> down -> left
DIRECTIONS = ['^', '>', 'v', '<']
# Map each direction to a delta row, delta column for movement
MOVE_DELTAS = {
    '^': (-1, 0),
    '>': (0, 1),
    'v': (1, 0),
    '<': (0, -1),
}


def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], str]:
    """"""Parse the puzzle input from file into grid, initial position and facing direction.

    Args:
        input_file: Path to the input file.

    Returns:
        grid: 2D list of characters representing the map.
        start_pos: Tuple of (row, col) indicating guard's starting position.
        start_dir: Character indicating guard's starting facing '^', '>', 'v', or '<'.
    """"""
    grid: List[List[str]] = []
    start_pos: Tuple[int, int] = (-1, -1)
    start_dir: str = ''

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            line = line.rstrip('\n')
            row = list(line)
            for c, ch in enumerate(row):
                if ch in DIRECTIONS:
                    start_pos = (r, c)
                    start_dir = ch
            grid.append(row)

    if start_pos == (-1, -1) or start_dir == '':
        raise ValueError(""No starting guard position with facing direction found in input."")

    return grid, start_pos, start_dir


def turn_right(direction: str) -> str:
    """"""Return the new direction after turning right (clockwise) 90 degrees.

    Args:
        direction: Current facing direction '^', '>', 'v', or '<'.

    Returns:
        New direction character after turning right.
    """"""
    idx = DIRECTIONS.index(direction)
    new_idx = (idx + 1) % 4
    return DIRECTIONS[new_idx]


def is_in_bounds(pos: Tuple[int, int], grid: List[List[str]]) -> bool:
    """"""Check if a position is within the grid boundaries.

    Args:
        pos: Tuple (row, col) position.
        grid: 2D grid.

    Returns:
        True if position is inside grid bounds, False otherwise.
    """"""
    r, c = pos
    return 0 <= r < len(grid) and 0 <= c < len(grid[0])


def simulate_guard_movement(grid: List[List[str]], start_pos: Tuple[int, int], start_dir: str) -> int:
    """"""Simulate the guard's movement according to rules and count distinct visited positions.

    Args:
        grid: 2D list representing the map.
        start_pos: Starting position (row, col).
        start_dir: Starting facing direction.

    Returns:
        The count of distinct positions the guard visits (including starting position).
    """"""
    visited_positions: Set[Tuple[int, int]] = set()
    pos = start_pos
    direction = start_dir

    visited_positions.add(pos)

    while True:
        dr, dc = MOVE_DELTAS[direction]
        next_pos = (pos[0] + dr, pos[1] + dc)

        if not is_in_bounds(next_pos, grid) or grid[next_pos[0]][next_pos[1]] == '#':
            # Obstacle or boundary ahead, turn right
            direction = turn_right(direction)
            # Do not move this step
        else:
            # Move forward
            pos = next_pos
            visited_positions.add(pos)
            # Check if moved out of map - (should not happen here because we check bounds first)
            if not is_in_bounds(pos, grid):
                break
        # Exit condition: moving off map is detected just before moving
        # Because we check bounds before moving, guard leaves map only after moving
        # So simulate loop terminates when guard attempts to move out, which is returned as turning
        # to continue until eventually moves out
        # Because the problem states:
        # The guard continues moving until it leaves the mapped area.

        # To detect leaving map, in our logic:
        # Moving off map is caught by `not is_in_bounds(next_pos, grid)` which causes turn right.
        # So guard leaves map by moving forward when next_pos is outside: but in code, this is prevented.
        # Hence, we need to detect when the guard attempts to move forward beyond the grid and stop.

        # Actually, in above logic, if next_pos is out of bounds, guard turns right.
        # The problem states the simulation continues until the guard leaves the grid.
        # The guard leaves the grid only when the step forward moves them off grid.
        # So we need to break once the guard wants to move forward outside.

        # So we modify logic to break once next_pos is out of bounds before moving.

        # Revised plan:
        # Check if next_pos is inside bounds first:
        #   If outside -> guard tries to move outside -> simulation ends.
        # Therefore, we must check before loop iteration.

    return len(visited_positions)


def simulate_guard_movement_correct(grid: List[List[str]], start_pos: Tuple[int, int], start_dir: str) -> int:
    """"""Corrected simulate function that stops when guard attempts to move outside the grid.

    Args:
        grid: 2D grid of map.
        start_pos: starting position (row, col).
        start_dir: starting facing direction character.

    Returns:
        Number of distinct positions visited including start.
    """"""
    visited_positions: Set[Tuple[int, int]] = set()
    pos = start_pos
    direction = start_dir

    visited_positions.add(pos)

    while True:
        dr, dc = MOVE_DELTAS[direction]
        next_pos = (pos[0] + dr, pos[1] + dc)

        # If next_pos is outside the grid, the guard attempts to leave the mapped area -> stop
        if not is_in_bounds(next_pos, grid):
            break

        # If obstacle ahead, turn right
        if grid[next_pos[0]][next_pos[1]] == '#':
            direction = turn_right(direction)
            # do not move
        else:
            # Move forward
            pos = next_pos
            visited_positions.add(pos)

    return len(visited_positions)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    grid, start_pos, start_dir = parse_input(input_file)

    # Run simulation
    result = simulate_guard_movement_correct(grid, start_pos, start_dir)

    print(result)


if __name__ == '__main__':
    main()
"
7,single-model,gpt-4.1-mini,True,34.39405369758606,"import sys
from typing import List, Tuple

""""""
Advent of Code Day 7: Bridge Repair

Given multiple test equations of the form:
  test_value: numbers...
Determine which equations can be made true by inserting only '+' or '*' operators between the numbers in left-to-right order evaluation (no operator precedence).

For each equation, try all combinations of '+' and '*'. If any combination evaluates to the test_value,
consider the equation valid and include test_value in the sum.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input into a list of tuples containing the test value and list of numbers.

    Args:
        input_file: Path to the input file

    Returns:
        List of tuples: (test_value, list_of_numbers)
    """"""
    equations = []
    with open(input_file, 'r', encoding='utf-8') as f:
        for line_number, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue
            if ':' not in line:
                print(f""Warning: Skipping invalid line {line_number} without colon: {line}"", file=sys.stderr)
                continue
            left, right = line.split(':', 1)
            try:
                test_value = int(left.strip())
                numbers_str = right.strip().split()
                numbers = [int(x) for x in numbers_str]
                if not numbers:
                    print(f""Warning: No numbers on line {line_number}: {line}"", file=sys.stderr)
                    continue
                equations.append((test_value, numbers))
            except ValueError as e:
                print(f""Warning: Could not parse integers on line {line_number}: {line} ({e})"", file=sys.stderr)
    return equations


def eval_left_to_right(numbers: List[int], ops: List[str]) -> int:
    """"""Evaluate the expression formed by inserting operators between numbers, left to right.

    Args:
        numbers: List of integers
        ops: List of operators as strings, each either '+' or '*'

    Returns:
        The integer result of evaluation
    """"""
    assert len(ops) == len(numbers) - 1, ""Operators count must be one less than numbers count""
    result = numbers[0]
    for i, op in enumerate(ops):
        if op == '+':
            result += numbers[i + 1]
        elif op == '*':
            result *= numbers[i + 1]
        else:
            raise ValueError(f""Invalid operator: {op}"")
    return result


def can_form_test_value(test_value: int, numbers: List[int]) -> bool:
    """"""Check if there exists a combination of '+' and '*' operators between numbers
    that evaluates to test_value with strict left-to-right evaluation.

    Args:
        test_value: Target value to be matched
        numbers: List of numbers in order

    Returns:
        True if possible, False otherwise
    """"""
    if len(numbers) == 1:
        # Only one number, it must match test_value exactly
        return numbers[0] == test_value

    num_ops = len(numbers) - 1

    # There are 2^(num_ops) combinations of operators '+' and '*'
    # We can represent each combination as a bitmask where 0 = '+', 1 = '*'
    for mask in range(1 << num_ops):
        ops = []
        for i in range(num_ops):
            if (mask & (1 << i)) != 0:
                ops.append('*')
            else:
                ops.append('+')

        try:
            result = eval_left_to_right(numbers, ops)
            if result == test_value:
                return True
        except Exception as e:
            print(f""Error evaluating expression with operators {ops}: {e}"", file=sys.stderr)
            continue
    return False


def solve(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Calculate the sum of test values for equations that can be made true.

    Args:
        equations: List of (test_value, numbers) tuples

    Returns:
        Sum of test values for equations where operator insertion can yield test_value
    """"""
    total = 0
    for test_value, numbers in equations:
        if can_form_test_value(test_value, numbers):
            total += test_value
    return total


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    equations = parse_input(input_file)

    # Sanity check example from problem statement (for debugging):
    # Only do this if input matches example (optional)
    # This block can be commented out or removed in final
    EXAMPLE_INPUT = [
        (190, [10, 19]),
        (3267, [81, 40, 27]),
        (83, [17, 5]),
        (156, [15, 6]),
        (7290, [6, 8, 6, 15]),
        (161011, [16, 10, 13]),
        (192, [17, 8, 14]),
        (21037, [9, 7, 18, 13]),
        (292, [11, 6, 16, 20])
    ]
    if len(equations) == len(EXAMPLE_INPUT):
        # Validate against example
        example_sum = solve(EXAMPLE_INPUT)
        assert example_sum == 3749, f""Example verification failed: got {example_sum}, expected 3749""

    result = solve(equations)
    print(result)


if __name__ == ""__main__"":
    main()
"
7,system,gpt-4.1-mini,True,235.8894510269165,"""""""
Advent of Code Day 7: Bridge Repair

This solution parses each input equation with a test value and a sequence of numbers.
It tries all combinations of '+' and '*' operators inserted between the numbers and
evaluates the resulting expression strictly left-to-right. If any combination yields
the test value, that test value is included in the sum.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
import itertools


def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of (test_value, numbers) tuples.

    Args:
        input_file: Path to the input file.

    Returns:
        List of tuples where each tuple is (test_value: int, numbers: List[int])
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            if ':' not in line:
                continue  # skip malformed lines
            test_val_str, nums_str = line.split(':', 1)
            test_val = int(test_val_str.strip())
            numbers = [int(x) for x in nums_str.strip().split()]
            if len(numbers) < 2:
                # According to constraints, skip if less than 2 numbers
                continue
            equations.append((test_val, numbers))
    return equations


def generate_operator_combinations(n: int) -> List[List[str]]:
    """"""Generates all combinations of '+' and '*' operators of length n.

    Args:
        n: Number of operator slots.

    Returns:
        List of operator combinations, each a list of '+' or '*'.
    """"""
    return list(itertools.product(['+', '*'], repeat=n))


def evaluate_expression(numbers: List[int], operators: List[str]) -> int:
    """"""Evaluates the expression formed by numbers and operators strictly left to right.

    Args:
        numbers: Sequence of integers.
        operators: Sequence of operators, '+' or '*', length is len(numbers) - 1.

    Returns:
        Integer result of left-to-right evaluation.
    """"""
    result = numbers[0]
    for op, num in zip(operators, numbers[1:]):
        if op == '+':
            result += num
        elif op == '*':
            result *= num
        else:
            raise ValueError(f""Unsupported operator {op}"")
    return result


def can_produce_value(test_val: int, numbers: List[int]) -> bool:
    """"""Checks whether any operator combination produces the test value.

    Args:
        test_val: Target integer value to match.
        numbers: List of integers to insert operators between.

    Returns:
        True if any operator combination yields test_val, False otherwise.
    """"""
    operator_slots = len(numbers) - 1
    for operators in generate_operator_combinations(operator_slots):
        val = evaluate_expression(numbers, operators)
        if val == test_val:
            return True
    return False


def solve(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Solve the puzzle by summing test values of equations that can match with some operator combo.

    Args:
        equations: List of tuples (test_val, numbers)

    Returns:
        Integer sum of matching test values.
    """"""
    total_sum = 0
    for test_val, numbers in equations:
        if can_produce_value(test_val, numbers):
            total_sum += test_val
    return total_sum


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]
    equations = parse_input(input_file)
    answer = solve(equations)
    print(answer)


# Uncomment for quick internal test with example input
# if __name__ == '__main__':
#     test_input = '''190: 10 19
# 3267: 81 40 27
# 83: 17 5
# 156: 15 6
# 7290: 6 8 6 15
# 161011: 16 10 13
# 192: 17 8 14
# 21037: 9 7 18 13
# 292: 11 6 16 20'''.splitlines()
#     equations = []
#     for line in test_input:
#         if ':' in line:
#             test_val_str, nums_str = line.split(':', 1)
#             test_val = int(test_val_str.strip())
#             numbers = [int(x) for x in nums_str.strip().split()]
#             equations.append((test_val, numbers))
#     result = solve(equations)
#     assert result == 3749, f""Expected 3749 but got {result}""

if __name__ == ""__main__"":
    main()"
8,single-model,gpt-4.1-mini,True,26.988769054412842,"from typing import List, Tuple, Set, Dict
import sys
import logging

logging.basicConfig(level=logging.ERROR)  # Change to DEBUG for step-by-step logs

Coordinate = Tuple[int, int]


def parse_input(input_file: str) -> Tuple[List[str], int, int, Dict[str, List[Coordinate]]]:
    """"""Parse the puzzle input file.

    Args:
        input_file: path to the input file

    Returns:
        - The raw map as list of strings
        - number of rows
        - number of columns
        - Dictionary mapping frequencies (str) to list of antenna coordinates (x,y)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f if line.strip() != '']

    if not lines:
        raise ValueError(""Input map is empty"")

    rows = len(lines)
    cols = len(lines[0])

    # Validate map is rectangular
    for line in lines:
        if len(line) != cols:
            raise ValueError(""Input map rows are not all the same length"")

    antenna_map: Dict[str, List[Coordinate]] = {}

    for y, line in enumerate(lines):
        for x, ch in enumerate(line):
            if ch.isalnum():  # Only antennas have frequencies indicated by alphanumeric
                antenna_map.setdefault(ch, []).append((x, y))

    logging.debug(f""Parsed map size {cols}x{rows} with frequencies: {list(antenna_map.keys())}"")

    return lines, rows, cols, antenna_map


def get_antinode_positions_for_frequency(antennas: List[Coordinate], rows: int, cols: int) -> Set[Coordinate]:
    """"""Compute antinode positions for one frequency based on antennas' coordinates.

    Args:
        antennas: List of (x,y) antenna coordinates with the same frequency
        rows: height of the map
        cols: width of the map

    Returns:
        Set of unique antinode positions (x,y) within map bounds
    """"""
    antinodes: Set[Coordinate] = set()
    n = len(antennas)

    # For every pair of antennas, find the two antinodes on the line formed by them
    for i in range(n):
        x1, y1 = antennas[i]
        for j in range(i + 1, n):
            x2, y2 = antennas[j]

            dx = x2 - x1
            dy = y2 - y1

            # Calculate the two antinodes:
            # An antinode is at a position such that it is collinear with the two antennas,
            # and one antenna is twice as far from the antinode as the other.
            # That means: if distance between antennas is d,
            # antinodes at positions extending line segment past each point so that one to antinode is twice other to antinode.

            # Lets represent the vector from antenna1 to antenna2 as (dx, dy)
            # Antinodes are at:
            #  pos1 = antenna1 - (dx, dy)  (beyond antenna1, so antenna1 is midpoint between pos1 and antenna2 -> distances 1 and 2)
            #  pos2 = antenna2 + (dx, dy)  (beyond antenna2, same logic)

            pos1 = (x1 - dx, y1 - dy)
            pos2 = (x2 + dx, y2 + dy)

            # Check bounds before adding
            if 0 <= pos1[0] < cols and 0 <= pos1[1] < rows:
                logging.debug(f""Antinode at {pos1} from antennas {antennas[i]} and {antennas[j]}"")
                antinodes.add(pos1)
            if 0 <= pos2[0] < cols and 0 <= pos2[1] < rows:
                logging.debug(f""Antinode at {pos2} from antennas {antennas[i]} and {antennas[j]}"")
                antinodes.add(pos2)

    return antinodes


def calculate_total_antinodes(map_lines: List[str], rows: int, cols: int, antenna_map: Dict[str, List[Coordinate]]) -> int:
    """"""Calculate total unique antinodes on the map from all frequencies.

    Args:
        map_lines: List of strings representing the map
        rows: Number of rows
        cols: Number of columns
        antenna_map: Dict mapping frequency to list of coordinates

    Returns:
        Number of unique antinode locations within map bounds
    """"""
    total_antinodes: Set[Coordinate] = set()

    for freq, antennas in antenna_map.items():
        if len(antennas) < 2:
            # Need at least two antennas of same frequency
            logging.debug(f""Frequency {freq} has less than 2 antennas, skipping"")
            continue

        antinodes_for_freq = get_antinode_positions_for_frequency(antennas, rows, cols)

        logging.debug(f""Frequency {freq} adds {len(antinodes_for_freq)} antinodes"")
        total_antinodes.update(antinodes_for_freq)

    return len(total_antinodes)


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        map_lines, rows, cols, antenna_map = parse_input(input_file)

        result = calculate_total_antinodes(map_lines, rows, cols, antenna_map)

        print(result)

    except Exception as e:
        logging.error(f""Error processing input: {e}"")
        sys.exit(1)


if __name__ == ""__main__"":
    main()
"
8,system,gpt-4.1-mini,True,197.2443118095398,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity

This solution identifies all antinodes formed by pairs of antennas of the same frequency.
For each pair, two antinodes lie collinearly on the line defined by the antennas, such that one antenna is exactly twice as far to the antinode as the other.
The code collects all such antinode positions within the grid boundaries and counts unique locations.

Usage: python3 solution.py [input_file]
""""""
from typing import Dict, List, Set, Tuple
import sys

Coordinate = Tuple[int, int]


def parse_input(input_file: str) -> Tuple[Dict[str, List[Coordinate]], int, int]:
    """"""Parse the input grid and extract antennas grouped by frequency.

    Args:
        input_file: path to the input file

    Returns:
        frequencies: Dict mapping frequency (char) -> list of (x, y) antenna coordinates
        width: int width of the grid
        height: int height of the grid
    """"""
    frequencies: Dict[str, List[Coordinate]] = {}
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f.readlines()]

    height = len(lines)
    width = len(lines[0]) if height > 0 else 0

    for y, line in enumerate(lines):
        if len(line) != width:
            raise ValueError(f""Inconsistent line width at line {y}: expected {width}, got {len(line)}"")
        for x, ch in enumerate(line):
            if ch != '.':  # It's an antenna
                if ch not in frequencies:
                    frequencies[ch] = []
                frequencies[ch].append((x, y))

    return frequencies, width, height


def compute_antinode_positions(positions: List[Coordinate]) -> Set[Coordinate]:
    """"""Given a list of antenna positions for a frequency, compute all antinodes generated.

    Each pair of antennas produces exactly two antinodes by extending the vector between the two antennas in each direction.

    Args:
        positions: List of (x, y) antenna coordinates for one frequency

    Returns:
        Set of antinode coordinates as (x, y) tuples
    """"""
    antinodes = set()
    length = len(positions)
    for i in range(length):
        x1, y1 = positions[i]
        for j in range(i + 1, length):
            x2, y2 = positions[j]
            dx = x2 - x1
            dy = y2 - y1
            # Antinode on the side of (x1, y1), opposite of (x2, y2)
            an1 = (x1 - dx, y1 - dy)
            # Antinode on the side of (x2, y2), extending in the vector direction
            an2 = (x2 + dx, y2 + dy)
            antinodes.add(an1)
            antinodes.add(an2)
    return antinodes


def filter_within_bounds(points: Set[Coordinate], width: int, height: int) -> Set[Coordinate]:
    """"""Filter points to keep only those within the grid boundaries.

    Args:
        points: set of (x, y) coordinates
        width: grid width
        height: grid height

    Returns:
        set of points within bounds
    """"""
    return { (x, y) for (x, y) in points if 0 <= x < width and 0 <= y < height }


def count_antinode_positions(frequencies: Dict[str, List[Coordinate]], width: int, height: int) -> int:
    """"""Compute total unique antinode positions across all frequencies within grid bounds.

    Args:
        frequencies: Dict mapping frequency -> list of antenna positions
        width: grid width
        height: grid height

    Returns:
        Total count of unique antinode positions inside the grid
    """"""
    all_antinodes: Set[Coordinate] = set()
    for freq, positions in frequencies.items():
        if len(positions) < 2:
            # No pairs, no antinodes
            continue
        antinodes = compute_antinode_positions(positions)
        antinodes_in_bounds = filter_within_bounds(antinodes, width, height)
        all_antinodes.update(antinodes_in_bounds)
    return len(all_antinodes)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Parse input
    frequencies, width, height = parse_input(input_file)

    # Compute the number of unique antinode positions
    result = count_antinode_positions(frequencies, width, height)

    # Output result only
    print(result)


# Run main when executed
if __name__ == ""__main__"":
    main()
"
9,single-model,gpt-4.1-mini,False,43.48370981216431,"from typing import List, Tuple
import sys
import re

""""""
Advent of Code Day 9: Disk Fragmenter

This solution parses the given disk map string representing alternating lengths of files and free spaces.
Each file is assigned an ID starting from 0 in the order they appear.

The disk map is expanded into a list of blocks, each block either holding a file ID or free space.
The compaction process moves the last block of files into the leftmost free space until no gaps remain between files.

After compaction, the filesystem checksum is calculated as the sum of (position * file ID) for every file block.

The solution reads input from a file provided as a command line argument and prints the checksum.

Usage: python3 solution.py [input_file]
""""""

def parse_disk_map(disk_map: str) -> List[int]:
    """"""Parse the disk map string into a list of blocks.

    Args:
        disk_map: A string representing alternating lengths of files and free spaces.

    Returns:
        A list where index is block position and value is file ID or -1 for free space.
    """"""
    # The digits alternate between file length and free space length
    # Files are at even indices starting with file (id increments per file), spaces at odd
    # Convert disk_map string of digits to list of integers
    lengths = list(map(int, disk_map.strip()))
    result: List[int] = []
    file_id = 0
    for i, length in enumerate(lengths):
        if i % 2 == 0:  # file block
            result.extend([file_id] * length)
            file_id += 1
        else:  # free space
            result.extend([-1] * length)
    return result


def compact_disk(blocks: List[int]) -> List[int]:
    """"""Compact the disk blocks by moving file blocks one at a time from the end to the leftmost free space.

    This simulates moving last file blocks to the earliest free spots until no gaps remain.

    Args:
        blocks: List of blocks with file IDs and free spaces (-1).

    Returns:
        New list of blocks after compaction.
    """"""
    blocks = blocks.copy()

    while True:
        try:
            leftmost_free = blocks.index(-1)  # leftmost free space
        except ValueError:
            # No free space -> disk is compacted
            break

        try:
            last_file_pos = len(blocks) - 1 - blocks[::-1].index(next(
                f for f in reversed(blocks) if f != -1))  # last file block position
        except StopIteration:
            # No files present
            break

        if last_file_pos < leftmost_free:
            # All files are already compacted to the left
            break

        # Move the file block at last_file_pos to leftmost_free (swap)
        if blocks[leftmost_free] == -1 and blocks[last_file_pos] != -1:
            blocks[leftmost_free], blocks[last_file_pos] = blocks[last_file_pos], blocks[leftmost_free]
        else:
            # This condition shouldn't happen, but break to avoid infinite loop
            break

    return blocks


def calculate_checksum(blocks: List[int]) -> int:
    """"""Calculate the checksum by summing position * file ID for all file blocks.

    Args:
        blocks: List of blocks with file IDs and free spaces (-1).

    Returns:
        The checksum as an integer.
    """"""
    checksum = 0
    for pos, val in enumerate(blocks):
        if val != -1:
            checksum += pos * val
    return checksum


def solve(disk_map: str) -> int:
    blocks = parse_disk_map(disk_map)
    compacted = compact_disk(blocks)
    return calculate_checksum(compacted)


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        # The input is a single line string representing the disk map
        disk_map = f.read().strip()

    # Sanity check: input contains only digits
    if not re.fullmatch(r'\d+', disk_map):
        print(""Invalid input: disk map must be a string of digits."", file=sys.stderr)
        sys.exit(1)

    result = solve(disk_map)
    print(result)


if __name__ == ""__main__"":
    main()
"
9,system,gpt-4.1-mini,False,357.1363878250122,
10,single-model,gpt-4.1-mini,True,27.21047830581665,"'''
Advent of Code 2022 Day 10: Hoof It

This solution reads a topographic height map and identifies all trailheads (positions with height 0).
For each trailhead, it finds all hiking trails starting at that position. A hiking trail is defined as a path where each step moves orthogonally (up/down/left/right) into a position with height exactly 1 greater than the current position's height.
The score for a trailhead is the count of unique positions with height 9 reachable from that trailhead via hiking trails.

The final answer is the sum of all trailheads' scores.

Approach:
- Parse the input grid into a 2D list of integers.
- Identify trailhead positions (height == 0).
- For each trailhead, perform a BFS or DFS to explore valid hiking trails (neighbors height == current +1).
- During exploration, track visited positions to avoid cycles and overcounting.
- Count how many height-9 positions are reachable from each trailhead.
- Sum these counts and output the result.

Usage: python3 solution.py [input_file]
'''

from typing import List, Tuple, Set
import sys
from collections import deque

Position = Tuple[int, int]


def parse_input(input_file: str) -> List[List[int]]:
    '''
    Parses the input file into a 2D grid of integers representing heights.

    Args:
        input_file: Path to the input file.

    Returns:
        A 2D list of integers representing the height map.
    '''
    grid: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                row = [int(ch) for ch in line]
                grid.append(row)
    return grid


def neighbors(r: int, c: int, max_r: int, max_c: int) -> List[Position]:
    '''
    Returns the valid orthogonal neighbors (up/down/left/right) for a position.

    Args:
        r: Row index
        c: Column index
        max_r: Number of rows in grid
        max_c: Number of columns in grid

    Returns:
        List of neighbor positions as (row, column) tuples.
    '''
    nbrs = []
    for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < max_r and 0 <= nc < max_c:
            nbrs.append((nr, nc))
    return nbrs


def score_trailhead(grid: List[List[int]], start: Position) -> int:
    '''
    For a given trailhead (height 0), explore all reachable positions through hiking trails:
    steps where heights increase exactly by 1.

    Returns the count of distinct positions with height 9 reachable from start.

    Args:
        grid: Height map
        start: Starting position (row, col)

    Returns:
        Number of unique height-9 positions reachable from this trailhead.
    '''
    max_r, max_c = len(grid), len(grid[0])
    visited: Set[Position] = set()
    nine_positions: Set[Position] = set()

    # Use a queue for BFS exploration
    queue: deque[Tuple[int,int]] = deque()
    queue.append(start)
    visited.add(start)

    while queue:
        r, c = queue.popleft()
        current_height = grid[r][c]

        # If current is height 9, add to count
        if current_height == 9:
            nine_positions.add((r, c))

        # Explore neighbors with height == current_height + 1
        for nr, nc in neighbors(r, c, max_r, max_c):
            neighbor_height = grid[nr][nc]
            if neighbor_height == current_height + 1 and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))

    return len(nine_positions)


def find_trailheads(grid: List[List[int]]) -> List[Position]:
    '''
    Identifies all trailheads (positions with height 0) in reading order.

    Args:
        grid: Height map

    Returns:
        List of positions (row, col) with height 0.
    '''
    trailheads = []
    for r, row in enumerate(grid):
        for c, h in enumerate(row):
            if h == 0:
                trailheads.append((r, c))
    return trailheads


def solve(grid: List[List[int]]) -> int:
    '''
    Solves the problem: sum of scores of all trailheads.

    Args:
        grid: Height map

    Returns:
        Sum of scores for all trailheads.
    '''
    trailheads = find_trailheads(grid)
    total_score = 0
    for th in trailheads:
        score = score_trailhead(grid, th)
        total_score += score
    return total_score


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]
    grid = parse_input(input_file)

    if not grid or not grid[0]:
        print(0)  # Empty input or grid
        return

    result = solve(grid)
    print(result)


# If you want to include example tests, uncomment and run them here.
# def test():
#     example1 = [
#         [0,1,2,3],
#         [1,2,3,4],
#         [8,7,6,5],
#         [9,8,7,6],
#     ]
#     # Single trailhead at (0,0) with score 1
#     assert solve(example1) == 1

#     example_larger = [
#         [8,9,0,1,0,1,2,3],
#         [7,8,1,2,1,8,7,4],
#         [8,7,4,3,0,9,6,5],
#         [9,6,5,4,9,8,7,4],
#         [4,5,6,7,8,9,0,3],
#         [3,2,0,1,9,0,1,2],
#         [0,1,3,2,9,8,0,1],
#         [1,0,4,5,6,7,3,2],
#     ]
#     # From description sum is 36
#     assert solve(example_larger) == 36

# if __name__ == '__main__':
#     test()

if __name__ == '__main__':
    main()
"
10,system,gpt-4.1-mini,True,164.7267873287201,"""""""
Advent of Code 2023 Day 10: Hoof It

Given a topographic map as a 2D grid of heights (0-9),
find all trailheads (positions with height 0) and for each,
compute how many distinct height-9 positions are reachable
by hiking trails. A hiking trail is a strictly ascending
path starting at 0 and ending at 9, where each step
increments height by exactly 1, moving orthogonally.

Output the sum of all trailheads' scores.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
from collections import deque


def parse_input(input_file: str) -> Tuple[List[List[int]], List[Tuple[int, int]]]:
    """"""Parse the input file into a height map and find trailheads.

    Args:
        input_file: Path to the input file containing the grid.

    Returns:
        height_map: 2D list of integers representing heights.
        trailheads: List of coordinates (row, col) with height 0.
    """"""
    height_map: List[List[int]] = []
    trailheads: List[Tuple[int, int]] = []

    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f if line.strip() != '']

    if not lines:
        return height_map, trailheads  # empty input edge case

    row_length = len(lines[0])

    for r, line in enumerate(lines):
        if len(line) != row_length:
            raise ValueError(f""Non-rectangular input at line {r+1}"")
        row = []
        for c, ch in enumerate(line):
            if not ch.isdigit() or not (0 <= int(ch) <= 9):
                raise ValueError(f""Invalid character '{ch}' at line {r+1}, column {c+1}"")
            height = int(ch)
            row.append(height)
            if height == 0:
                trailheads.append((r, c))
        height_map.append(row)

    return height_map, trailheads


def get_neighbors(r: int, c: int, max_r: int, max_c: int) -> List[Tuple[int, int]]:
    """"""Get valid orthogonal neighbors within bounds.

    Args:
        r: Current row.
        c: Current column.
        max_r: Maximum row index (exclusive).
        max_c: Maximum column index (exclusive).

    Returns:
        List of (row, col) tuples for orthogonal neighbors.
    """"""
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    neighbors = []
    for dr, dc in directions:
        nr, nc = r + dr, c + dc
        if 0 <= nr < max_r and 0 <= nc < max_c:
            neighbors.append((nr, nc))
    return neighbors


def explore_trailhead(height_map: List[List[int]], start: Tuple[int, int]) -> Set[Tuple[int, int]]:
    """"""From a trailhead, find all reachable height-9 positions by valid hiking trails.

    Args:
        height_map: 2D grid of heights.
        start: Starting coordinate (row, col) with height 0.

    Returns:
        Set of coordinates of reachable height-9 cells.
    """"""
    max_r, max_c = len(height_map), len(height_map[0])
    visited: Set[Tuple[int, int]] = set()
    reachable_nines: Set[Tuple[int, int]] = set()

    # Use BFS to explore all valid ascending paths
    queue = deque()
    queue.append(start)
    visited.add(start)

    while queue:
        r, c = queue.popleft()
        current_height = height_map[r][c]

        for nr, nc in get_neighbors(r, c, max_r, max_c):
            neighbor_height = height_map[nr][nc]
            if neighbor_height == current_height + 1 and (nr, nc) not in visited:
                visited.add((nr, nc))
                if neighbor_height == 9:
                    reachable_nines.add((nr, nc))
                queue.append((nr, nc))

    return reachable_nines


def solve(height_map: List[List[int]], trailheads: List[Tuple[int, int]]) -> int:
    """"""Compute the sum of scores of all trailheads.

    Args:
        height_map: 2D integer height grid.
        trailheads: List of coordinates with height 0.

    Returns:
        Sum of scores (number of distinct reachable height-9 cells from all trailheads).
    """"""
    total_score = 0
    for trailhead in trailheads:
        reachable_nines = explore_trailhead(height_map, trailhead)
        total_score += len(reachable_nines)
    return total_score


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    try:
        height_map, trailheads = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        return

    # Handle empty input case (no trailheads)
    if not trailheads:
        print(0)
        return

    result = solve(height_map, trailheads)
    print(result)


if __name__ == ""__main__"":
    main()
"
11,single-model,gpt-4.1-mini,True,26.689743757247925,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles

The solution simulates the transformation of a linear arrangement of stones over multiple blinking steps. Each stone is represented by an integer engraved number.

On each blink, every stone simultaneously transforms following these rules (in order):
1. If 0, becomes 1.
2. If the number has an even number of digits, split into two stones where the left half digits form one stone and the right half digits form the second stone (the right part can be zero).
3. Otherwise, multiply the number by 2024.

The simulation runs for 25 blinks, and the final count of stones is output.

Approach:
- Represent stones as a list of integers.
- For each blink, build the new list of stones by applying the transformation rules to each stone.
- Carefully handle leading zeros when splitting stones (strip leading zeros, interpret as int, zero if empty).
- Use integer arithmetic and string conversions for digit splits.

The solution is efficient enough for 25 blinks even when the number of stones grows large because each blink operation processes stones in a single pass.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys


def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers representing stones.

    Args:
        input_file: Path to the input file

    Returns:
        List of integers representing the initial stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        if not line:
            return []
        stones_str = line.split()
        stones = [int(s) for s in stones_str]
    return stones


def split_stone(number: int) -> List[int]:
    """"""Split a stone number into two stones according to the rule for even digit count.

    Args:
        number: The stone number to split

    Returns:
        List of two integers representing the two new stones
    """"""
    num_str = str(number)
    length = len(num_str)
    half = length // 2

    left_str = num_str[:half].lstrip('0')
    right_str = num_str[half:].lstrip('0')

    # If after stripping we have empty string, it means the number is zero
    left_num = int(left_str) if left_str else 0
    right_num = int(right_str) if right_str else 0

    return [left_num, right_num]


def transform_stone(number: int) -> List[int]:
    """"""Apply the transformation rules to a single stone and return the resulting stone(s).

    Args:
        number: The stone's current number

    Returns:
        A list of integers representing the transformed stone(s)
    """"""
    # Rule 1: If the stone is 0, replace with 1
    if number == 0:
        return [1]

    num_str = str(number)
    digit_count = len(num_str)

    # Rule 2: If number of digits is even, split into two stones
    if digit_count % 2 == 0:
        return split_stone(number)

    # Rule 3: Otherwise, multiply by 2024
    return [number * 2024]


def blink(stones: List[int]) -> List[int]:
    """"""Perform a single blink transformation on the list of stones.

    Args:
        stones: List of integers representing the current stones

    Returns:
        List of integers representing the stones after transformation
    """"""
    new_stones = []
    for stone in stones:
        transformed = transform_stone(stone)
        new_stones.extend(transformed)
    return new_stones


def solve(stones: List[int], blinks: int) -> int:
    """"""Simulate blinking stones a number of times and return the count of stones after.

    Args:
        stones: Initial arrangement of stones
        blinks: Number of blinks to simulate

    Returns:
        Number of stones after blinking
    """"""
    current_stones = stones
    for i in range(blinks):
        current_stones = blink(current_stones)
    return len(current_stones)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    initial_stones = parse_input(input_file)

    # Edge case: if input is empty, result after blinking is 0
    if not initial_stones:
        print(0)
        return

    # Solve for 25 blinks as requested
    result = solve(initial_stones, 25)

    # Print only the number of stones
    print(result)


# Example testing for correctness on provided example from problem description
# (Can be expanded or disabled in final)
def run_example_tests():
    # Example from prompt:
    # Initial: 0 1 10 99 999
    stones = [0, 1, 10, 99, 999]
    after_1_blink = [1, 2024, 1, 0, 9, 9, 2021976]
    result_after_1 = blink(stones)
    assert result_after_1 == after_1_blink, f""Example 1 blink failed: got {result_after_1}""

    # Longer example initial: 125 17
    stones_long = [125, 17]
    after_1 = [253000, 1, 7]
    res_1 = blink(stones_long)
    assert res_1 == after_1, f""Long example blink 1 failed: got {res_1}""

    after_2 = [253,0,2024,14168]
    res_2 = blink(res_1)
    assert res_2 == after_2, f""Long example blink 2 failed: got {res_2}""

    # Could continue testing further blinks if desired.


if __name__ == ""__main__"":
    # Uncomment to run example tests (prints nothing if passes)
    # run_example_tests()
    main()
"
11,system,gpt-4.1-mini,True,171.6608498096466,"""""""
Advent of Code 2022 Day 11: Plutonian Pebbles

Simulate 25 iterations of transformations on a sequence of stones according to specified rules.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys


def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers representing stones.

    Args:
        input_file: Path to the input file

    Returns:
        List of integers representing the initial stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        if not line:
            return []
        stones = [int(token) for token in line.split()]
    return stones


def transform_stone(stone: int) -> List[int]:
    """"""Apply transformation rules to a single stone.

    Args:
        stone: Integer representing the stone's number

    Returns:
        A list of integers representing the transformed stone(s).
    """"""
    # Rule 1: If the stone is 0, replace with 1
    if stone == 0:
        return [1]

    stone_str = str(stone)
    length = len(stone_str)

    # Rule 2: If the number of digits is even, split into two stones
    if length % 2 == 0:
        half = length // 2
        left_str = stone_str[:half]
        right_str = stone_str[half:]
        left_num = int(left_str)  # int() removes leading zeros automatically
        right_num = int(right_str)
        return [left_num, right_num]

    # Rule 3: Otherwise, multiply by 2024
    return [stone * 2024]


def blink(stones: List[int]) -> List[int]:
    """"""Perform one blink iteration applying transformation rules to all stones simultaneously.

    Args:
        stones: Current list of stones

    Returns:
        Updated list of stones after one blink
    """"""
    new_stones = []
    for stone in stones:
        transformed = transform_stone(stone)
        new_stones.extend(transformed)
    return new_stones


def simulate_blinks(initial_stones: List[int], blinks: int = 25) -> int:
    """"""Simulate multiple blinks and count resulting stones.

    Args:
        initial_stones: Starting sequence of stones
        blinks: Number of iterations to perform (default 25)

    Returns:
        Number of stones after all blinks
    """"""
    stones = initial_stones
    for _ in range(blinks):
        stones = blink(stones)
    return len(stones)


def main() -> None:
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    stones = parse_input(input_file)

    # Simulate 25 blinks and print the final number of stones
    result = simulate_blinks(stones, 25)
    print(result)


# Optional: example test cases when running as a script without input file
# Not part of final deployment but useful for quick validation
if __name__ == ""__main__"":
    if len(sys.argv) == 1:
        # Run internal tests
        test_cases = [
            (""0 1 10 99 999"", 7),
            (""125 17"", 22)
        ]
        for input_str, expected in test_cases:
            stones = [int(x) for x in input_str.split()]
            result = simulate_blinks(stones, 1 if input_str == ""0 1 10 99 999"" else 6)  # Using 1 blink for first, 6 for second example
            # For the 0 1 10 99 999 example, after 1 blink, stones count = 7
            # For the 125 17 example, after 6 blinks count = 22
            assert result == expected, f""Test failed for input: {input_str}, got {result}, expected {expected}""
        print(""All internal tests passed."")
    else:
        main()
"
12,single-model,gpt-4.1-mini,False,35.094731092453,NO CODE
12,system,gpt-4.1-mini,True,195.92088150978088,"""""""
Advent of Code: Garden Groups (Day 12)

This solution identifies all connected regions (connected components) of identical plant types
in a 2D grid using BFS traversal. For each region, it computes the area (number of plots)
and the perimeter (number of sides exposed to different plants or outside grid boundaries).
The total fence cost is the sum of (area * perimeter) for all distinct regions.

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple
from collections import deque
import sys


def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the input file into a 2D grid of plant characters.""""""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                grid.append(list(line))
    return grid


def bfs_find_region(grid: List[List[str]], visited: List[List[bool]], start_r: int, start_c: int) -> List[Tuple[int, int]]:
    """"""Perform BFS to find all connected plots of the same plant type starting from (start_r, start_c).

    Args:
        grid: 2D grid of plant types
        visited: 2D boolean grid tracking visited cells
        start_r: starting row
        start_c: starting column

    Returns:
        List of (row, col) tuples representing the region's plots
    """"""
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0
    plant_type = grid[start_r][start_c]

    region_cells = []
    queue = deque()
    queue.append((start_r, start_c))
    visited[start_r][start_c] = True

    while queue:
        r, c = queue.popleft()
        region_cells.append((r, c))

        # Check neighbors up, down, left, right
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if not visited[nr][nc] and grid[nr][nc] == plant_type:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
    return region_cells


def calculate_perimeter(grid: List[List[str]], region_cells: List[Tuple[int,int]]) -> int:
    """"""Calculate the perimeter of a given region.

    Perimeter is number of plot sides exposed to grid edges or different plant types.

    Args:
        grid: 2D grid
        region_cells: list of plots in the region

    Returns:
        The perimeter as an integer
    """"""
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    # Put region cells into a set for O(1) membership tests
    region_set = set(region_cells)
    plant_type = grid[region_cells[0][0]][region_cells[0][1]] if region_cells else None

    perimeter = 0

    for r, c in region_cells:
        # For each plot, check all four sides
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r + dr, c + dc
            # If neighbor is outside grid bounds, this side contributes to perimeter
            if not (0 <= nr < rows and 0 <= nc < cols):
                perimeter += 1
            else:
                # Neighbor inside grid but either different plant type or not in region
                if (nr, nc) not in region_set:
                    perimeter += 1

    return perimeter


def solve_total_fence_cost(grid: List[List[str]]) -> int:
    """"""Solve the total fencing cost for all regions in the garden map.

    Args:
        grid: 2D list of plant type characters

    Returns:
        Total fencing cost as integer
    """"""
    rows = len(grid)
    if rows == 0:
        return 0
    cols = len(grid[0])

    visited = [[False]*cols for _ in range(rows)]
    total_cost = 0

    for r in range(rows):
        for c in range(cols):
            if not visited[r][c]:
                # BFS to find region
                region_cells = bfs_find_region(grid, visited, r, c)
                area = len(region_cells)
                perimeter = calculate_perimeter(grid, region_cells)
                total_cost += area * perimeter

    return total_cost


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    result = solve_total_fence_cost(grid)
    print(result)


if __name__ == ""__main__"":
    main()
"
13,single-model,gpt-4.1-mini,True,63.55042815208435,"import sys
from typing import List, Tuple, Optional
import re

""""""
Advent of Code 2019 Day 13: Claw Contraption

Solution approach:
Each claw machine defines movements in X and Y directions for buttons A and B.
Pressing button A costs 3 tokens, B costs 1 token.
We want to find the minimum total tokens to win as many prizes as possible.

Key points:
- Each prize position is given (X, Y).
- Each button defines a vector movement (dx, dy).
- We want nonnegative integers (a, b) presses satisfying:
    a * A_x + b * B_x = Prize_x
    a * A_y + b * B_y = Prize_y
- Among all solutions with a,b <= 100, choose minimal cost = 3 * a + b.

Approach:
- For each machine, try all (a, b) with 0 <= a,b <= 100
- Check if the position matches prize exactly.
- If matches, track minimum cost.
- Count how many prizes can be won, sum minimal costs.

Output:
Print the minimal total tokens spent to win all possible prizes.

Usage:
python3 solution.py input_file

""""""


def parse_input(input_file: str) -> List[Tuple[Tuple[int,int], Tuple[int,int], Tuple[int,int]]]:
    """"""Parse input into a list of machines.

    Each machine is a tuple: ((Ax, Ay), (Bx, By), (PrizeX, PrizeY))

    Args:
        input_file: path to input file

    Returns:
        List of machines as described.
    """"""
    machines = []
    with open(input_file, 'r') as f:
        content = f.read()

    # Machines are separated by blank lines
    blocks = content.strip().split('\n\n')

    pattern_a = re.compile(r'Button A: X([+\-]\d+), Y([+\-]\d+)')
    pattern_b = re.compile(r'Button B: X([+\-]\d+), Y([+\-]\d+)')
    pattern_p = re.compile(r'Prize: X=(\d+), Y=(\d+)')

    for block in blocks:
        lines = block.strip().split('\n')
        if len(lines) < 3:
            continue  # skip incomplete blocks

        match_a = pattern_a.match(lines[0].strip())
        match_b = pattern_b.match(lines[1].strip())
        match_p = pattern_p.match(lines[2].strip())

        if not (match_a and match_b and match_p):
            # Invalid block, skip
            continue

        Ax, Ay = int(match_a.group(1)), int(match_a.group(2))
        Bx, By = int(match_b.group(1)), int(match_b.group(2))
        Px, Py = int(match_p.group(1)), int(match_p.group(2))

        machines.append(((Ax, Ay), (Bx, By), (Px, Py)))

    return machines


def find_min_cost_for_machine(A: Tuple[int,int], B: Tuple[int,int],
                              P: Tuple[int,int], max_presses: int=100) -> Optional[int]:
    """"""Find the minimum token cost to reach prize position using buttons A and B.

    We brute force all a,b in [0, max_presses] and check if a*A + b*B = P exactly.

    Cost: a*3 + b*1

    Args:
        A: movement vector for button A (dx, dy)
        B: movement vector for button B (dx, dy)
        P: prize position (x, y)
        max_presses: maximum button presses to consider

    Returns:
        Minimal cost if reachable, None otherwise
    """"""
    Ax, Ay = A
    Bx, By = B
    Px, Py = P

    min_cost = None

    # For efficiency, we try all a in [0, max_presses],
    # then compute if b must be integer and in [0, max_presses]

    for a in range(max_presses + 1):
        # We have equations:
        # a*Ax + b*Bx = Px  => b*Bx = Px - a*Ax
        # a*Ay + b*By = Py  => b*By = Py - a*Ay

        # For b to be same in both equations and integral:
        # Check if Bx and By are zero first.

        # Handle zero vectors carefully

        # If Bx == 0 and By == 0, no moves from B, can't adjust
        if Bx == 0 and By == 0:
            # Then we must have a*Ax == Px and a*Ay == Py exactly
            if a * Ax == Px and a * Ay == Py:
                cost = a * 3
                if min_cost is None or cost < min_cost:
                    min_cost = cost
            continue

        # Otherwise, check if solution exists

        # For each coordinate:
        # if Bx != 0 => b_x = (Px - a*Ax)/Bx
        # if By != 0 => b_y = (Py - a*Ay)/By

        # For solution, b_x and b_y must equal and integer and >=0 and <= max_presses

        b_candidates = []

        if Bx != 0:
            bx = (Px - a * Ax) / Bx
            b_candidates.append(bx)
        else:
            # Bx == 0, then must have Px == a*Ax else no solution
            if Px != a * Ax:
                continue

        if By != 0:
            by = (Py - a * Ay) / By
            b_candidates.append(by)
        else:
            # By == 0, must have Py == a*Ay
            if Py != a * Ay:
                continue

        if len(b_candidates) == 0:
            # Means Bx == By == 0 handled above.
            continue
        elif len(b_candidates) == 1:
            b = b_candidates[0]
        else:
            b1, b2 = b_candidates
            # Both must be equal
            if abs(b1 - b2) > 1e-9:
                continue
            b = b1

        # Check b is integer and in range
        if b.is_integer():
            b_int = int(b)
            if 0 <= b_int <= max_presses:
                # Valid solution
                cost = a * 3 + b_int
                if min_cost is None or cost < min_cost:
                    min_cost = cost

    return min_cost


def solve(machines: List[Tuple[Tuple[int,int], Tuple[int,int], Tuple[int,int]]]) -> int:
    """"""Solve the puzzle.

    Args:
        machines: list of machines as parsed.

    Returns:
        minimal total tokens to win all possible prizes
    """"""
    total_cost = 0
    won_prizes = 0

    for idx, (A, B, P) in enumerate(machines):
        cost = find_min_cost_for_machine(A, B, P, max_presses=100)
        if cost is not None:
            total_cost += cost
            won_prizes += 1

    return total_cost


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    machines = parse_input(input_file)

    # Validate we have machines
    if not machines:
        print(0)
        return

    result = solve(machines)

    # Print only final result
    print(result)


if __name__ == '__main__':
    main()
"
13,system,gpt-4.1-mini,True,202.61135601997375,"""""""
Advent of Code - Day 13: Claw Contraption

For each claw machine, find non-negative integer counts (a,b) with 0 <= a,b <= 100
satisfying:
    a * A_x + b * B_x = P_x
    a * A_y + b * B_y = P_y

Each press of A costs 3 tokens, each press of B costs 1 token.
Goal: Maximize number of prizes won (machines with solutions), then minimize total cost.

Approach:
- Parse machines from input
- For each machine, brute force all (a,b) in [0..100] to find solutions exactly matching prize coords
- Track minimal cost solution per machine
- Sum minimal costs over all machines with solutions
- Print sum

Usage: python3 solution.py input.txt
""""""
from typing import List, Optional, Tuple
import sys
import re


class Machine:
    def __init__(self, Ax: int, Ay: int, Bx: int, By: int, Px: int, Py: int):
        self.Ax = Ax
        self.Ay = Ay
        self.Bx = Bx
        self.By = By
        self.Px = Px
        self.Py = Py


def parse_input(input_file: str) -> List[Machine]:
    """"""Parse the input file into a list of Machine instances.

    Each machine has 3 lines:
      Button A: X+<int>, Y+<int>
      Button B: X+<int>, Y+<int>
      Prize: X=<int>, Y=<int>

    Args:
        input_file: path to input text file

    Returns:
        List of Machine instances.
    """"""
    machines = []
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip()]

    # Process lines in chunks of 3
    if len(lines) % 3 != 0:
        # Input format invalid
        raise ValueError(f""Input lines count {len(lines)} not multiple of 3"")

    pattern_A_B = re.compile(r'X\+(-?\d+), Y\+(-?\d+)')
    pattern_prize = re.compile(r'X=(-?\d+), Y=(-?\d+)')

    for i in range(0, len(lines), 3):
        lineA = lines[i]
        lineB = lines[i + 1]
        lineP = lines[i + 2]

        mA = pattern_A_B.search(lineA)
        mB = pattern_A_B.search(lineB)
        mP = pattern_prize.search(lineP)

        if not (mA and mB and mP):
            raise ValueError(f""Invalid line format near lines {i+1}-{i+3}"")

        Ax, Ay = int(mA.group(1)), int(mA.group(2))
        Bx, By = int(mB.group(1)), int(mB.group(2))
        Px, Py = int(mP.group(1)), int(mP.group(2))

        machines.append(Machine(Ax, Ay, Bx, By, Px, Py))

    return machines


def find_min_cost_for_machine(machine: Machine) -> Optional[int]:
    """"""Find minimal token cost to align claw exactly with prize position.

    Search all (a,b) with 0 <= a,b <= 100 satisfying
    a*Ax + b*Bx = Px and a*Ay + b*By = Py.

    Token cost = 3*a + 1*b.

    Args:
        machine: Machine instance

    Returns:
        Minimal token cost for this machine, or None if no solution.
    """"""
    Ax, Ay, Bx, By, Px, Py = machine.Ax, machine.Ay, machine.Bx, machine.By, machine.Px, machine.Py
    min_cost = None

    # Since all are integers and bounded to 0..100, brute force is feasible
    # Optimization: early pruning if sums exceed Px or Py (since increments are positive)
    # However, input does not forbid zero increments; keep conditions safe

    # We only consider a,b in [0..100]
    for a in range(101):
        # Calculate residuals for x and y
        rem_x = Px - a * Ax
        rem_y = Py - a * Ay

        # Check rem_x and rem_y must be >=0 if Bx and By > 0, else, try direct check
        # Since no info on sign of increments, just proceed for all b
        if rem_x < 0 or rem_y < 0:
            # The sum exceeded prize, no solution for this a
            continue

        # To satisfy both equations exactly:
        # b*Bx = rem_x and b*By = rem_y
        # So Bx and By must divide rem_x and rem_y respectively
        # and b must be same.

        # Handle corner case Bx or By = 0
        if Bx == 0 and rem_x != 0:
            continue  # impossible since no change in x for B but prize x not met
        if By == 0 and rem_y != 0:
            continue  # impossible since no change in y for B but prize y not met

        # If both Bx and By zero, prize must match exactly a presses of A
        if Bx == 0 and By == 0:
            if rem_x == 0 and rem_y == 0:
                cost = 3 * a + 0
                if min_cost is None or cost < min_cost:
                    min_cost = cost
            continue

        # For nonzero Bx and By
        # If Bx == 0: only check rem_x == 0, b chosen by y
        if Bx == 0:
            if rem_x != 0:
                continue
            if By != 0 and rem_y % By == 0:
                b = rem_y // By
                if 0 <= b <= 100:
                    cost = 3 * a + b
                    if min_cost is None or cost < min_cost:
                        min_cost = cost
            continue

        # If By == 0: only check rem_y == 0, b chosen by x
        if By == 0:
            if rem_y != 0:
                continue
            if Bx != 0 and rem_x % Bx == 0:
                b = rem_x // Bx
                if 0 <= b <= 100:
                    cost = 3 * a + b
                    if min_cost is None or cost < min_cost:
                        min_cost = cost
            continue

        # If both Bx and By nonzero
        # b must satisfy rem_x = b*Bx and rem_y = b*By
        # so b = rem_x / Bx = rem_y / By and both must be integers
        if rem_x % Bx != 0 or rem_y % By != 0:
            continue

        b_x = rem_x // Bx
        b_y = rem_y // By

        if b_x != b_y:
            continue

        b = b_x

        if 0 <= b <= 100:
            cost = 3 * a + b
            if min_cost is None or cost < min_cost:
                min_cost = cost

    return min_cost


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    machines = parse_input(input_file)

    costs = []
    for machine in machines:
        min_cost = find_min_cost_for_machine(machine)
        if min_cost is not None:
            costs.append(min_cost)

    # Max prizes won = number of machines with solutions
    max_prizes = len(costs)

    # Minimal total token cost to win max prizes = sum of minimal costs
    total_cost = sum(costs)

    # Output only final integer result
    print(total_cost)


if __name__ == ""__main__"":
    main()
"
14,single-model,gpt-4.1-mini,True,33.81201958656311,"import sys
from typing import List, Tuple
import re

WIDTH = 101
HEIGHT = 103

Robot = Tuple[int, int, int, int]  # (pos_x, pos_y, vel_x, vel_y)


def parse_input(input_file: str) -> List[Robot]:
    """"""Parse the puzzle input from file into a list of robots with position and velocity.

    Args:
        input_file: Path to the input file

    Returns:
        List of tuples (pos_x, pos_y, vel_x, vel_y) for each robot
    """"""
    pattern = re.compile(r""p=(-?\d+),(-?\d+) v=(-?\d+),(-?\d+)"")
    robots: List[Robot] = []

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            match = pattern.match(line)
            if not match:
                raise ValueError(f""Invalid input line format: {line}"")
            px, py, vx, vy = map(int, match.groups())
            robots.append((px, py, vx, vy))

    return robots


def simulate_robots(robots: List[Robot], width: int, height: int, seconds: int) -> List[List[int]]:
    """"""Simulate the robots positions after a given number of seconds with wrapping.

    Args:
        robots: List of robot tuples (pos_x, pos_y, vel_x, vel_y)
        width: Width of the area
        height: Height of the area
        seconds: Number of seconds to simulate

    Returns:
        A 2D list (height x width) with counts of robots on each tile
    """"""
    # Initialize grid counts
    grid = [[0 for _ in range(width)] for _ in range(height)]

    for px, py, vx, vy in robots:
        # Compute new position after 'seconds' with wrapping
        new_x = (px + vx * seconds) % width
        new_y = (py + vy * seconds) % height
        grid[new_y][new_x] += 1

    return grid


def count_quadrants(grid: List[List[int]]) -> Tuple[int, int, int, int]:
    """"""Count number of robots in each quadrant of the grid.

    Quadrants partition the grid into four sections divided by the center lines.
    Robots on the exact center lines are excluded.

    Args:
        grid: 2D list of counts of robots on each tile

    Returns:
        A tuple (q1, q2, q3, q4) counts
        where quadrants are defined as:
            Q1: top-left
            Q2: top-right
            Q3: bottom-left
            Q4: bottom-right
    """"""
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    mid_x = width // 2
    mid_y = height // 2

    q1 = q2 = q3 = q4 = 0

    for y in range(height):
        for x in range(width):
            count = grid[y][x]
            if count == 0:
                continue
            # Skip robots on the center lines
            if x == mid_x or y == mid_y:
                continue
            # Top half is y < mid_y, bottom half y > mid_y
            # Left half is x < mid_x, right half x > mid_x
            if y < mid_y and x < mid_x:
                q1 += count
            elif y < mid_y and x > mid_x:
                q2 += count
            elif y > mid_y and x < mid_x:
                q3 += count
            elif y > mid_y and x > mid_x:
                q4 += count
            # else positions on center lines which we've skipped

    return q1, q2, q3, q4


def solve_safety_factor(robots: List[Robot], seconds: int = 100) -> int:
    """"""Calculate the safety factor after simulating robot movement for given seconds.

    Args:
        robots: List of robots (pos_x, pos_y, vel_x, vel_y)
        seconds: Number of seconds to simulate (default 100)

    Returns:
        The safety factor as int (product of counts in each quadrant)
    """"""
    grid = simulate_robots(robots, WIDTH, HEIGHT, seconds)
    q1, q2, q3, q4 = count_quadrants(grid)
    # Safety factor is product of the counts
    safety_factor = q1 * q2 * q3 * q4
    return safety_factor


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        robots = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    if not robots:
        print(0)
        return

    result = solve_safety_factor(robots, 100)
    print(result)  # Only print the final result


# If example testing is desired, define a test function here
# We include a basic example test based on the prompt example input

def test_example() -> None:
    example_input = [
        ""p=0,4 v=3,-3"",
        ""p=6,3 v=-1,-3"",
        ""p=10,3 v=-1,2"",
        ""p=2,0 v=2,-1"",
        ""p=0,0 v=1,3"",
        ""p=3,0 v=-2,-2"",
        ""p=7,6 v=-1,-3"",
        ""p=3,0 v=-1,-2"",
        ""p=9,3 v=2,3"",
        ""p=7,3 v=-1,2"",
        ""p=2,4 v=2,-3"",
        ""p=9,5 v=-3,-3""
    ]

    import tempfile

    with tempfile.NamedTemporaryFile('w+', delete=True) as f:
        f.writelines(line + '\n' for line in example_input)
        f.flush()
        robots = parse_input(f.name)
        # The example area size is smaller (11x7),
        # so we adapt simulate_robots to use these dimensions for this test

        test_grid = simulate_robots(robots, 11, 7, 100)
        q1, q2, q3, q4 = count_quadrants(test_grid)
        # According to the problem example, quadrants count are (1,3,4,1)
        assert (q1, q2, q3, q4) == (1, 3, 4, 1), f""Quadrant counts do not match expected values, got {(q1,q2,q3,q4)}""

        safety_factor = q1 * q2 * q3 * q4
        assert safety_factor == 12, f""Safety factor mismatch, expected 12, got {safety_factor}""

if __name__ == ""__main__"":
    # Uncomment the following line to run the example test
    # test_example()
    main()"
14,system,gpt-4.1-mini,True,184.24328804016113,"""""""
Advent of Code: Robot Movement Simulation and Safety Factor Calculation

This solution simulates robot movements on a 2D bounded grid with wrap-around edges over 100 seconds using modular arithmetic.
After simulation, it partitions robots into four quadrants (excluding robots on midlines) and computes the safety factor as the product of the robot counts in these quadrants.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
import re

# Constants for the grid size
WIDTH = 101
HEIGHT = 103
MID_X = WIDTH // 2   # 50
MID_Y = HEIGHT // 2  # 51


def parse_input(input_file: str) -> List[Tuple[int, int, int, int]]:
    """"""Parse puzzle input file into a list of robot states.

    Each robot state is a tuple (x, y, vx, vy).

    Args:
        input_file: Path to input file.

    Returns:
        List of (x, y, vx, vy) tuples.
    """"""
    robots = []
    pattern = re.compile(r'p=(-?\d+),(-?\d+) v=(-?\d+),(-?\d+)')
    with open(input_file, 'r') as f:
        for line_num, line in enumerate(f, start=1):
            line = line.strip()
            if not line:
                continue
            m = pattern.match(line)
            if not m:
                raise ValueError(f""Invalid input format on line {line_num}: {line}"")
            x, y, vx, vy = map(int, m.groups())
            # Optional: validate position in bounds
            if not (0 <= x < WIDTH) or not (0 <= y < HEIGHT):
                raise ValueError(f""Position out of bounds on line {line_num}: ({x},{y})"")
            robots.append((x, y, vx, vy))
    return robots


def simulate_robots(robots: List[Tuple[int, int, int, int]], seconds: int) -> List[Tuple[int, int]]:
    """"""Simulate robot movements over given seconds with wrap-around.

    Args:
        robots: List of tuples (x, y, vx, vy).
        seconds: Number of seconds to simulate.

    Returns:
        List of final positions (x, y) after simulation.
    """"""
    final_positions = []
    for x, y, vx, vy in robots:
        # Calculate new position with modular arithmetic for wrap-around
        new_x = (x + vx * seconds) % WIDTH
        new_y = (y + vy * seconds) % HEIGHT
        final_positions.append((new_x, new_y))
    return final_positions


def count_quadrants(positions: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:
    """"""Count how many robots fall into each quadrant.

    Quadrants:
        top-left: x < MID_X and y < MID_Y
        top-right: x > MID_X and y < MID_Y
        bottom-left: x < MID_X and y > MID_Y
        bottom-right: x > MID_X and y > MID_Y

    Robots exactly on mid_x or mid_y are excluded.

    Args:
        positions: List of robot (x, y) positions.

    Returns:
        Tuple of counts: (top-left, top-right, bottom-left, bottom-right)
    """"""
    top_left = 0
    top_right = 0
    bottom_left = 0
    bottom_right = 0

    for x, y in positions:
        if x == MID_X or y == MID_Y:
            # Robots on midlines do not count
            continue
        if x < MID_X and y < MID_Y:
            top_left += 1
        elif x > MID_X and y < MID_Y:
            top_right += 1
        elif x < MID_X and y > MID_Y:
            bottom_left += 1
        elif x > MID_X and y > MID_Y:
            bottom_right += 1
        # Positions not fitting these criteria (e.g., on mid_x or mid_y) are excluded

    return top_left, top_right, bottom_left, bottom_right


def compute_safety_factor(quadrant_counts: Tuple[int, int, int, int]) -> int:
    """"""Compute safety factor as product of counts in all four quadrants.

    Args:
        quadrant_counts: Tuple of four quadrant counts.

    Returns:
        Integer safety factor.
    """"""
    product = 1
    for count in quadrant_counts:
        # If any quadrant has zero robots, product is zero
        if count == 0:
            return 0
        product *= count
    return product


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        robots = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    final_positions = simulate_robots(robots, 100)

    quadrant_counts = count_quadrants(final_positions)

    safety_factor = compute_safety_factor(quadrant_counts)

    print(safety_factor)


if __name__ == ""__main__"":
    main()
"
15,single-model,gpt-4.1-mini,False,21.34374761581421,"""""""
Advent of Code 2022 Day 15: Warehouse Woes
Solution implementing robot and box movement simulation as described.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

Position = Tuple[int, int]  # (row, col)


def parse_input(input_file: str) -> Tuple[List[List[str]], str, Position, Set[Position]]:
    """"""Parse the puzzle input file.

    Args:
        input_file: Path to input file containing map and moves.

    Returns:
        A tuple containing:
        - 2D grid map as list of list of chars
        - moves string (stripped of newlines)
        - robot starting position
        - set of box positions
    """"""
    with open(input_file, 'r') as f:
        lines = f.readlines()

    # Separate map lines and moves lines
    # Map ends where a blank line or no more map char lines (contain #, ., O, @) appear
    # The moves start immediately after map lines

    map_lines = []
    move_lines = []
    map_section_done = False

    for line in lines:
        stripped = line.rstrip('\n')
        if not stripped:
            map_section_done = True
            continue

        # A line is considered part of map if it has wall (#) or other map chars
        if not map_section_done and all(c in '#.O@' for c in stripped):
            map_lines.append(stripped)
        else:
            map_section_done = True
            move_lines.append(stripped)

    # If moves split across multiple lines, join them
    moves = ''.join(move_lines).replace('\n', '')

    # Build grid
    grid = [list(line) for line in map_lines]

    robot_pos: Position = (-1, -1)
    boxes: Set[Position] = set()

    for r, row in enumerate(grid):
        for c, val in enumerate(row):
            if val == '@':
                robot_pos = (r, c)
            elif val == 'O':
                boxes.add((r, c))

    if robot_pos == (-1, -1):
        raise ValueError(""Robot position '@' not found in map."")

    return grid, moves, robot_pos, boxes


def delta_for_move(move: str) -> Position:
    """"""Return the row and column delta for a given move character.

    Args:
        move: One of '^', 'v', '<', '>'

    Returns:
        (dr, dc) tuple indicating movement direction
    """"""
    if move == '^':
        return (-1, 0)
    elif move == 'v':
        return (1, 0)
    elif move == '<':
        return (0, -1)
    elif move == '>':
        return (0, 1)
    else:
        raise ValueError(f""Invalid move character: {move}"")


def is_within_bounds(grid: List[List[str]], pos: Position) -> bool:
    """"""Check if a position is within the grid bounds.

    Args:
        grid: 2D grid
        pos: (row, col)

    Returns:
        True if position is inside grid, False otherwise
    """"""
    r, c = pos
    return 0 <= r < len(grid) and 0 <= c < len(grid[0])


def is_wall(grid: List[List[str]], pos: Position) -> bool:
    """"""Check if a position is a wall.

    Args:
        grid: 2D grid
        pos: (row, col)

    Returns:
        True if position is a wall, False otherwise
    """"""
    r, c = pos
    return grid[r][c] == '#'


def simulate_moves(grid: List[List[str]], moves: str, robot_pos: Position, boxes: Set[Position]) -> Set[Position]:
    """"""Simulate robot moves and box pushes according to the puzzle rules.

    Args:
        grid: 2D grid map
        moves: String of move commands
        robot_pos: Starting robot position
        boxes: Set of positions of boxes

    Returns:
        Set of final box positions after all moves
    """"""
    # Convert set to mutable during simulation
    box_positions = set(boxes)
    r, c = robot_pos

    for move in moves:
        dr, dc = delta_for_move(move)

        next_pos = (r + dr, c + dc)

        if not is_within_bounds(grid, next_pos):
            # Next position out of map bounds, no move
            continue

        if is_wall(grid, next_pos):
            # Next position a wall, no move
            continue

        if next_pos in box_positions:
            # Box is in the way, attempt to push
            beyond_pos = (next_pos[0] + dr, next_pos[1] + dc)

            if (not is_within_bounds(grid, beyond_pos)) or is_wall(grid, beyond_pos) or (beyond_pos in box_positions):
                # Cannot push box if beyond is wall, out of bounds, or another box
                continue

            # Push box
            box_positions.remove(next_pos)
            box_positions.add(beyond_pos)

            # Move robot onto the box's previous position
            r, c = next_pos
        else:
            # Space is free, robot can move
            r, c = next_pos

    return box_positions


def calculate_gps_sum(box_positions: Set[Position], grid: List[List[str]]) -> int:
    """"""Calculate the sum of GPS coordinates of boxes.

    Args:
        box_positions: Set of final box positions
        grid: The grid map (to determine map width)

    Returns:
        Sum of all box GPS coordinates (100 * row + col)
    """"""
    total = 0
    for (r, c) in box_positions:
        total += 100 * r + c
    return total


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    grid, moves, robot_pos, boxes = parse_input(input_file)

    final_boxes = simulate_moves(grid, moves, robot_pos, boxes)

    result = calculate_gps_sum(final_boxes, grid)

    print(result)


if __name__ == ""__main__"":
    main()
"
15,system,gpt-4.1-mini,False,541.6831872463226,
16,single-model,gpt-4.1-mini,True,28.870136976242065,"import sys
from typing import List, Tuple, Optional, Set
from collections import deque

""""""
Advent of Code 2022 Day 16: Reindeer Maze

Solution:
- Parse the maze from input.
- Identify start position (S) and end position (E).
- Model the reindeer's state as (row, col, direction).
- Directions: 0=East,1=South,2=West,3=North.
- Moves:
   * Move forward if not a wall (#) - cost +1
   * Turn left or right (90 degrees) - cost +1000
- Find minimal total cost from start state (S, facing East) to any state at end position (E).
- Use Dijkstra's algorithm to find minimum total cost.

Usage: python3 solution.py [input_file]
""""""

# Direction vectors correspond to directions: East, South, West, North
DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # (dr, dc)


def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]:
    """"""Parse the maze input.

    Args:
        input_file: Path to the input file

    Returns:
        maze: 2D list of maze characters
        start_pos: (row, col) tuple of Start tile
        end_pos: (row, col) tuple of End tile
    """"""
    maze: List[List[str]] = []
    start_pos = None
    end_pos = None

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            line = line.rstrip('\n')
            maze.append(list(line))
            for c, ch in enumerate(line):
                if ch == 'S':
                    start_pos = (r, c)
                elif ch == 'E':
                    end_pos = (r, c)

    if start_pos is None or end_pos is None:
        raise ValueError(""Start (S) or End (E) position not found in input."")

    return maze, start_pos, end_pos


def valid_position(maze: List[List[str]], r: int, c: int) -> bool:
    """"""Check if position is inside maze and not a wall.

    Args:
        maze: The maze grid
        r: Row index
        c: Column index

    Returns:
        True if valid position to move into, else False
    """"""
    return 0 <= r < len(maze) and 0 <= c < len(maze[0]) and maze[r][c] != '#'


def turn_left(direction: int) -> int:
    """"""Turn 90 degrees counterclockwise.

    Args:
        direction: Current direction (0=E,1=S,2=W,3=N)

    Returns:
        New direction after left turn
    """"""
    return (direction - 1) % 4


def turn_right(direction: int) -> int:
    """"""Turn 90 degrees clockwise.

    Args:
        direction: Current direction (0=E,1=S,2=W,3=N)

    Returns:
        New direction after right turn
    """"""
    return (direction + 1) % 4


def dijkstra_min_cost(maze: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int:
    """"""Use Dijkstra's algorithm to find minimum total cost path.

    State: (row, col, direction)
    Actions:
      - forward to adjacent cell (cost 1) if open
      - turn left (cost 1000)
      - turn right (cost 1000)

    Args:
        maze: Maze grid
        start: Start position (row, col)
        end: End position (row, col)

    Returns:
        Minimum total score to reach end cell
    """"""
    import heapq

    rows = len(maze)
    cols = len(maze[0])

    # Initial state: at start position facing East (direction=0)
    start_state = (start[0], start[1], 0)  # r, c, direction

    # min_cost dictionary: keys are (r, c, direction), values are cost
    min_cost = {}

    # Priority queue elements: (cost, r, c, direction)
    heap: List[Tuple[int, int, int, int]] = []
    heapq.heappush(heap, (0, start[0], start[1], 0))
    min_cost[start_state] = 0

    while heap:
        cost, r, c, direction = heapq.heappop(heap)

        if (r, c) == end:
            # Reached end position; cost is minimum due to Dijkstra
            return cost

        # If this state has a better recorded cost, skip
        if min_cost.get((r, c, direction), float('inf')) < cost:
            continue

        # Actions:
        # 1) Move forward if possible
        dr, dc = DIRECTIONS[direction]
        nr, nc = r + dr, c + dc
        if valid_position(maze, nr, nc):
            next_state = (nr, nc, direction)
            next_cost = cost + 1
            if next_cost < min_cost.get(next_state, float('inf')):
                min_cost[next_state] = next_cost
                heapq.heappush(heap, (next_cost, nr, nc, direction))

        # 2) Turn left (cost 1000)
        new_dir = turn_left(direction)
        next_state = (r, c, new_dir)
        next_cost = cost + 1000
        if next_cost < min_cost.get(next_state, float('inf')):
            min_cost[next_state] = next_cost
            heapq.heappush(heap, (next_cost, r, c, new_dir))

        # 3) Turn right (cost 1000)
        new_dir = turn_right(direction)
        next_state = (r, c, new_dir)
        next_cost = cost + 1000
        if next_cost < min_cost.get(next_state, float('inf')):
            min_cost[next_state] = next_cost
            heapq.heappush(heap, (next_cost, r, c, new_dir))

    # If we exhaust heap without reaching end, no path found
    raise ValueError(""No path from Start to End found."")


def solve(maze: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int:
    """"""Solve the puzzle by finding minimum cost to reach end from start.

    Args:
        maze: Maze grid
        start: Start position
        end: End position

    Returns:
        Minimum score
    """"""
    min_score = dijkstra_min_cost(maze, start, end)
    return min_score


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    maze, start_pos, end_pos = parse_input(input_file)

    result = solve(maze, start_pos, end_pos)
    # Print only the result per instructions
    print(result)


# For debugging and testing with provided examples
if __name__ == ""__main__"":
    main()
"
16,system,gpt-4.1-mini,True,200.90070128440857,"""""""
Advent of Code 2023 Day 16: Reindeer Maze
Solution implementation based on the provided plan.

Approach:
- Model state as (row, col, facing_direction), with facing_direction in {0:East,1:South,2:West,3:North}.
- Use Dijkstra's algorithm over this augmented state space to find minimal cost path.
- Move forward costs 1 point, rotation costs 1000 points.
- Return minimal cost reaching the 'E' tile in any direction.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Dict
import sys
import heapq


def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]:
    """"""Parse maze input grid and find start and end positions.

    Args:
        input_file: Path to input file.

    Returns:
        grid: 2D list of chars
        start_pos: (row, col) of 'S'
        end_pos: (row, col) of 'E'
    """"""
    grid: List[List[str]] = []
    start_pos = None
    end_pos = None

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            row = list(line.rstrip('\n'))
            grid.append(row)
            for c, ch in enumerate(row):
                if ch == 'S':
                    if start_pos is not None:
                        raise ValueError(""Multiple start tiles found"")
                    start_pos = (r, c)
                elif ch == 'E':
                    if end_pos is not None:
                        raise ValueError(""Multiple end tiles found"")
                    end_pos = (r, c)

    if start_pos is None or end_pos is None:
        raise ValueError(""Start or end position not found in input"")

    return grid, start_pos, end_pos


def solve_min_score(grid: List[List[str]], start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> int:
    """"""Compute minimal total score to reach 'E' from 'S' with given rules.

    Args:
        grid: Maze grid.
        start_pos: Starting coordinates (row,col).
        end_pos: Ending coordinates (row,col).

    Returns:
        Minimal total score (int).
    """"""
    rows, cols = len(grid), len(grid[0])

    # Directions: 0=East,1=South,2=West,3=North
    direction_vectors = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Priority queue elements: (cost, row, col, direction)
    start_direction = 0  # Facing East initially

    # Distances dictionary to track minimal cost per state
    # Keys: (row, col, direction) -> cost
    distances: Dict[Tuple[int, int, int], int] = {}

    heap: List[Tuple[int, int, int, int]] = []
    heapq.heappush(heap, (0, start_pos[0], start_pos[1], start_direction))
    distances[(start_pos[0], start_pos[1], start_direction)] = 0

    def in_bounds(r: int, c: int) -> bool:
        return 0 <= r < rows and 0 <= c < cols

    while heap:
        cost, r, c, d = heapq.heappop(heap)

        # If reached end tile, return cost immediately
        if (r, c) == end_pos:
            return cost

        # If this state cost is higher than recorded, skip
        if distances.get((r, c, d), float('inf')) < cost:
            continue

        # 1. Move forward if possible
        dr, dc = direction_vectors[d]
        nr, nc = r + dr, c + dc
        if in_bounds(nr, nc):
            if grid[nr][nc] == '.' or grid[nr][nc] == 'E':
                new_cost = cost + 1
                state = (nr, nc, d)
                if new_cost < distances.get(state, float('inf')):
                    distances[state] = new_cost
                    heapq.heappush(heap, (new_cost, nr, nc, d))

        # 2. Rotate clockwise
        new_d_cw = (d + 1) % 4
        new_cost_cw = cost + 1000
        state_cw = (r, c, new_d_cw)
        if new_cost_cw < distances.get(state_cw, float('inf')):
            distances[state_cw] = new_cost_cw
            heapq.heappush(heap, (new_cost_cw, r, c, new_d_cw))

        # 3. Rotate counterclockwise
        new_d_ccw = (d - 1) % 4
        new_cost_ccw = cost + 1000
        state_ccw = (r, c, new_d_ccw)
        if new_cost_ccw < distances.get(state_ccw, float('inf')):
            distances[state_ccw] = new_cost_ccw
            heapq.heappush(heap, (new_cost_ccw, r, c, new_d_ccw))

    # If no path found (should not happen with valid input)
    raise RuntimeError(""No path to end tile found"")


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid, start_pos, end_pos = parse_input(input_file)

    result = solve_min_score(grid, start_pos, end_pos)

    print(result)


if __name__ == ""__main__"":
    main()
"
17,single-model,gpt-4.1-mini,False,37.12010860443115," """"""
Advent of Code 2023 Day 17: Chronospatial Computer

This solution implements a virtual machine for a 3-bit opcode computer with three registers A, B, and C.
It supports 8 instructions, each with specific behaviors, operand types, and effects.

Usage: python3 solution.py [input_file]

The input file is expected to contain the initial register values (A, B, C) and the program (list of 3-bit numbers).

The program simulates execution until the instruction pointer moves past the program length.
Outputs from 'out' instructions are collected and printed as a comma-separated string.
""""""

from typing import List, Tuple
import sys

class ChronospatialComputer:
    """"""
    A class representing the Chronospatial Computer executing 3-bit opcode instructions.
    """"""

    def __init__(self, program: List[int], reg_a: int, reg_b: int, reg_c: int):
        """"""
        Initialize the computer with registers and program.

        Args:
            program: List of integers (0-7) representing the program instructions and operands.
            reg_a: Initial value for register A.
            reg_b: Initial value for register B.
            reg_c: Initial value for register C.
        """"""
        self.program = program
        self.regs = {'A': reg_a, 'B': reg_b, 'C': reg_c}
        self.ip = 0  # Instruction pointer
        self.output_values: List[int] = []

    def _get_operand_value_combo(self, operand: int) -> int:
        """"""
        Compute the value of a combo operand.

        Combo operands 0..3 -> literal 0..3
        4 -> reg A
        5 -> reg B
        6 -> reg C
        7 -> invalid (not used)

        Args:
            operand: Integer operand (0-7)

        Returns:
            Value of operand as per combo rules.

        Raises:
            ValueError if operand == 7 (invalid).
        """"""
        if 0 <= operand <= 3:
            return operand
        elif operand == 4:
            return self.regs['A']
        elif operand == 5:
            return self.regs['B']
        elif operand == 6:
            return self.regs['C']
        else:
            raise ValueError(""Invalid combo operand 7 encountered"")

    def _adv(self, operand: int):
        """"""
        adv instruction (opcode 0): divide register A by 2^(combo operand), truncate result integer, store in A.
        """"""
        denom_exp = self._get_operand_value_combo(operand)
        denominator = 2 ** denom_exp
        # Integer division truncates towards zero by default with //
        self.regs['A'] = self.regs['A'] // denominator

    def _bxl(self, operand: int):
        """"""
        bxl instruction (opcode 1): B = B XOR literal operand
        """"""
        self.regs['B'] ^= operand

    def _bst(self, operand: int):
        """"""
        bst instruction (opcode 2): B = combo operand % 8
        """"""
        val = self._get_operand_value_combo(operand) % 8
        self.regs['B'] = val

    def _jnz(self, operand: int) -> bool:
        """"""
        jnz instruction (opcode 3): if A != 0 jump to literal operand (instruction pointer = operand)
        Returns True if jump was taken, False otherwise.
        """"""
        if self.regs['A'] != 0:
            self.ip = operand
            return True
        return False

    def _bxc(self, operand: int):
        """"""
        bxc instruction (opcode 4): B = B XOR C; operand ignored
        """"""
        self.regs['B'] ^= self.regs['C']

    def _out(self, operand: int):
        """"""
        out instruction (opcode 5): output combo operand % 8
        """"""
        val = self._get_operand_value_combo(operand) % 8
        self.output_values.append(val)

    def _bdv(self, operand: int):
        """"""
        bdv instruction (opcode 6): B = A // 2^(combo operand), integer division
        """"""
        denom_exp = self._get_operand_value_combo(operand)
        denominator = 2 ** denom_exp
        self.regs['B'] = self.regs['A'] // denominator

    def _cdv(self, operand: int):
        """"""
        cdv instruction (opcode 7): C = A // 2^(combo operand), integer division
        """"""
        denom_exp = self._get_operand_value_combo(operand)
        denominator = 2 ** denom_exp
        self.regs['C'] = self.regs['A'] // denominator

    def run(self):
        """"""
        Execute the program until the instruction pointer goes past program length.
        """"""
        program_len = len(self.program)

        while self.ip < program_len:
            if self.ip + 1 >= program_len:
                # No operand available, halt
                break

            opcode = self.program[self.ip]
            operand = self.program[self.ip + 1]

            # Validate opcode and operand (0-7)
            if not (0 <= opcode <= 7) or not (0 <= operand <=7):
                raise ValueError(f""Invalid opcode or operand at ip={self.ip}: opcode={opcode}, operand={operand}"")

            # Dispatch opcode
            # jnz returns True if jumped => do not increment ip by 2
            if opcode == 0:
                self._adv(operand)
                self.ip += 2
            elif opcode == 1:
                self._bxl(operand)
                self.ip += 2
            elif opcode == 2:
                self._bst(operand)
                self.ip += 2
            elif opcode == 3:
                jumped = self._jnz(operand)
                if not jumped:
                    self.ip += 2
            elif opcode == 4:
                self._bxc(operand)
                self.ip += 2
            elif opcode == 5:
                self._out(operand)
                self.ip += 2
            elif opcode == 6:
                self._bdv(operand)
                self.ip += 2
            elif opcode == 7:
                self._cdv(operand)
                self.ip += 2
            else:
                # Should never happen since opcode 0..7
                raise ValueError(f""Unknown opcode {opcode} at ip {self.ip}"")


def parse_input(input_file: str) -> Tuple[int, int, int, List[int]]:
    """"""
    Parses the input file to extract initial registers and program.

    Input format example:
        Register A: 729
        Register B: 0
        Register C: 0

        Program: 0,1,5,4,3,0

    Args:
        input_file: Path to input file.

    Returns:
        Tuple of (A, B, C, program_list)
    """"""
    reg_a = reg_b = reg_c = 0
    program: List[int] = []

    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip() != '']

    # Parse registers
    for line in lines:
        if line.startswith('Register A:'):
            reg_a = int(line.split(':')[1].strip())
        elif line.startswith('Register B:'):
            reg_b = int(line.split(':')[1].strip())
        elif line.startswith('Register C:'):
            reg_c = int(line.split(':')[1].strip())
        elif line.startswith('Program:'):
            prog_str = line[len('Program:'):].strip()
            program = [int(x) for x in prog_str.split(',') if x.strip() != '']

    if not program:
        raise ValueError(""No program found in input file"")

    return reg_a, reg_b, reg_c, program


def solve_part_one(reg_a: int, reg_b: int, reg_c: int, program: List[int]) -> str:
    """"""
    Runs the Chronospatial Computer simulation and returns the output string.

    Args:
        reg_a: Initial value for register A
        reg_b: Initial value for register B
        reg_c: Initial value for register C
        program: List of opcode and operand integers

    Returns:
        Comma-separated output string produced by 'out' instructions
    """"""
    computer = ChronospatialComputer(program, reg_a, reg_b, reg_c)
    computer.run()
    return ','.join(str(v) for v in computer.output_values)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    try:
        reg_a, reg_b, reg_c, program = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        return

    try:
        output = solve_part_one(reg_a, reg_b, reg_c, program)
        print(output)
    except Exception as e:
        print(f""Error during execution: {e}"", file=sys.stderr)


if __name__ == ""__main__"":
    main()
"
17,system,gpt-4.1-mini,True,198.71956968307495,"""""""
Advent of Code 2024 Day 17: Chronospatial Computer

Simulate a specialized 3-bit instruction computer with registers A, B, and C, executing a given program of opcode-operand pairs.
Collect outputs from the 'out' instructions and return them as a comma-separated string.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple
import sys
import re


class ChronospatialComputer:
    def __init__(self, registers: Dict[str, int], program: List[int]) -> None:
        self.registers = registers  # {'A': int, 'B': int, 'C': int}
        self.program = program      # list of ints (opcode, operand pairs)
        self.ip = 0                 # instruction pointer
        self.outputs: List[int] = []

    def eval_combo_operand(self, operand: int) -> int:
        """"""Evaluate an operand of combo type.

        Combo operand values:
          0..3   -> literal values 0..3
          4      -> register A
          5      -> register B
          6      -> register C
          7      -> invalid, should not appear

        Raises:
            ValueError if operand == 7 (invalid)

        Returns:
            int: the evaluated value
        """"""
        if 0 <= operand <= 3:
            return operand
        elif operand == 4:
            return self.registers['A']
        elif operand == 5:
            return self.registers['B']
        elif operand == 6:
            return self.registers['C']
        else:
            raise ValueError(f""Invalid combo operand: {operand}"")

    def eval_literal_operand(self, operand: int) -> int:
        """"""Literal operand returns operand as is.""""""
        return operand

    def execute_instruction(self) -> bool:
        """"""Executes the instruction at the current instruction pointer.

        Updates registers, outputs, and instruction pointer.

        Returns:
            bool: True if execution can continue; False if halted (ip out of range)
        """"""
        if self.ip < 0 or self.ip + 1 >= len(self.program):
            # Halt if opcode or operand index out of range
            return False

        opcode = self.program[self.ip]
        operand = self.program[self.ip + 1]

        # Validate opcode and operand range
        if not (0 <= opcode <= 7 and 0 <= operand <= 7):
            raise ValueError(f""Opcode or operand out of allowed range: opcode={opcode}, operand={operand}"")

        # For debug: Uncomment to trace execution
        # print(f""IP={self.ip} opcode={opcode} operand={operand} registers={self.registers}"")

        def power_of_two(exp: int) -> int:
            # Handle large or negative exponents
            # 2^exp, integer
            try:
                return 2 ** exp
            except OverflowError:
                # In case exponent is too large, return a large number (will cause division to zero)
                return 2 ** 31  # arbitrarily large

        if opcode == 0:  # adv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in adv instruction"")
            self.registers['A'] = self.registers['A'] // denom
            self.ip += 2

        elif opcode == 1:  # bxl
            # operand: literal
            val = self.eval_literal_operand(operand)
            self.registers['B'] = self.registers['B'] ^ val
            self.ip += 2

        elif opcode == 2:  # bst
            # operand: combo
            val = self.eval_combo_operand(operand) % 8
            self.registers['B'] = val
            self.ip += 2

        elif opcode == 3:  # jnz
            # operand: literal
            val = self.eval_literal_operand(operand)
            if self.registers['A'] != 0:
                # jump to operand literal index
                if val < 0 or val >= len(self.program):
                    # The problem states program halts if ip out of range
                    # So jumping out of range means halt immediately
                    return False
                self.ip = val
            else:
                self.ip += 2

        elif opcode == 4:  # bxc
            # operand ignored
            self.registers['B'] = self.registers['B'] ^ self.registers['C']
            self.ip += 2

        elif opcode == 5:  # out
            # operand: combo
            val = self.eval_combo_operand(operand) % 8
            self.outputs.append(val)
            self.ip += 2

        elif opcode == 6:  # bdv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in bdv instruction"")
            self.registers['B'] = self.registers['A'] // denom
            self.ip += 2

        elif opcode == 7:  # cdv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in cdv instruction"")
            self.registers['C'] = self.registers['A'] // denom
            self.ip += 2

        else:
            # invalid opcode
            raise ValueError(f""Invalid opcode encountered: {opcode}"")

        return True

    def run_program(self) -> List[int]:
        """"""Run the entire program until halt.

        Returns:
            List[int]: collected output values
        """"""
        while self.execute_instruction():
            pass
        return self.outputs


def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the input file to extract initial register values and the program.

    Args:
        input_file (str): Path to the input file

    Returns:
        Tuple[Dict[str, int], List[int]]: ({'A': int, 'B': int, 'C': int}, program list)
    """"""
    registers = {'A': 0, 'B': 0, 'C': 0}
    program: List[int] = []

    # Patterns to capture: 'Register X: <int>' and 'Program: ...'
    reg_pattern = re.compile(r'Register ([ABC]):\s*(-?\d+)')
    program_pattern = re.compile(r'Program:\s*([0-7,\s]+)')

    with open(input_file, 'r') as f:
        content = f.read()

    # Extract registers
    for reg, val in reg_pattern.findall(content):
        registers[reg] = int(val)

    # Extract program
    prog_match = program_pattern.search(content)
    if not prog_match:
        raise ValueError(""Program line not found in input"")

    program_str = prog_match.group(1)
    # Parse comma-separated program integers
    program = [int(x.strip()) for x in program_str.split(',') if x.strip() != '']

    # Validate program length even
    if len(program) % 2 != 0:
        raise ValueError(""Program length must be even (opcode-operand pairs)"")

    # Validate values between 0 and 7 inclusive
    for val in program:
        if not (0 <= val <= 7):
            raise ValueError(f""Program contains invalid 3-bit value: {val}"")

    return registers, program


def solve(program_input_file: str) -> str:
    """"""Main solution function: parse input, run computer, and produce output string.""""""
    registers, program = parse_input(program_input_file)
    computer = ChronospatialComputer(registers, program)
    outputs = computer.run_program()

    # Format output as comma-separated string
    return ','.join(str(output) for output in outputs)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    result = solve(input_file)
    print(result)


if __name__ == '__main__':
    main()
"
18,single-model,gpt-4.1-mini,False,20.319724321365356," """"""
Advent of Code 2022 Day 18: RAM Run

Simulate the falling of bytes that corrupt coordinates in a 2D memory grid (0 to 70 in both dimensions).
After simulating the first 1024 falling bytes, find the shortest path from (0,0) to (70,70) avoiding corrupted cells.

Approach:
- Parse the input list of byte positions as (x,y) coordinates.
- Mark corrupted coordinates for the first 1024 bytes falling.
- Use BFS to find the shortest path from (0,0) to (70,70) considering:
   - Can't move into corrupted cells
   - Can't leave boundaries
   - Allowed moves: up, down, left, right
- If no path exists, return -1.

Usage: python3 solution.py [input_file]
""""""

import sys
from typing import List, Tuple, Set, Deque, Optional
from collections import deque

GridCoord = Tuple[int, int]


def parse_input(input_file: str) -> List[GridCoord]:
    """"""Parse the input file into a list of byte coordinates (x,y).""""""
    corrupted_positions: List[GridCoord] = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            parts = line.split(',')
            if len(parts) != 2:
                # Invalid line format, skip/continue
                continue
            try:
                x = int(parts[0])
                y = int(parts[1])
                if x < 0 or y < 0:
                    # Coordinates cannot be negative
                    continue
                corrupted_positions.append((x, y))
            except ValueError:
                # Non-integer values, skip
                continue
    return corrupted_positions


def bfs_shortest_path(corrupted: Set[GridCoord], width: int, height: int, start: GridCoord, end: GridCoord) -> int:
    """"""
    Perform BFS to find the shortest path from start to end on the grid avoiding corrupted cells.

    Args:
        corrupted: Set of coordinates that are corrupted/blocked.
        width: Grid width (max x coordinate, 0-based)
        height: Grid height (max y coordinate, 0-based)
        start: Starting coordinate (x,y)
        end: Ending coordinate (x,y)

    Returns:
        The length of the shortest path in steps, or -1 if no path exists.
    """"""

    if start == end:
        return 0

    if start in corrupted or end in corrupted:
        # Start or end position corrupted - no path
        return -1

    # Directions: up, down, left, right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    visited: Set[GridCoord] = set()
    queue: Deque[Tuple[GridCoord, int]] = deque()
    queue.append((start, 0))
    visited.add(start)

    while queue:
        (x, y), dist = queue.popleft()

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx <= width and 0 <= ny <= height:
                next_pos = (nx, ny)
                if next_pos == end:
                    return dist + 1
                if next_pos not in corrupted and next_pos not in visited:
                    visited.add(next_pos)
                    queue.append((next_pos, dist + 1))

    # No path found
    return -1


def solve(pixels: List[GridCoord]) -> int:
    """"""
    Solve the puzzle:
    - Simulate the first 1024 bytes falling into memory and corrupt these coordinates
    - Find shortest path from (0,0) to (70,70) avoiding corrupted coordinates

    Args:
        pixels: List of byte coordinates that fall (x,y)

    Returns:
        Minimum number of steps for shortest path, or -1 if unreachable
    """"""

    GRID_MAX = 70

    # Take first 1024 bytes or all if fewer
    corrupted_coords = set(pixels[:1024])

    start = (0, 0)
    end = (GRID_MAX, GRID_MAX)

    steps = bfs_shortest_path(corrupted_coords, GRID_MAX, GRID_MAX, start, end)

    return steps


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    byte_positions = parse_input(input_file)

    result = solve(byte_positions)
    print(result)  # Only print the final answer


if __name__ == ""__main__"":
    main()
"
18,system,gpt-4.1-mini,False,35.87996506690979,threw-error
18,system,gpt-4.1-mini,True,35.88006401062012,"""""""
Advent of Code 2024 Day 17: Chronospatial Computer

Simulate a specialized 3-bit instruction computer with registers A, B, and C, executing a given program of opcode-operand pairs.
Collect outputs from the 'out' instructions and return them as a comma-separated string.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple
import sys
import re


class ChronospatialComputer:
    def __init__(self, registers: Dict[str, int], program: List[int]) -> None:
        self.registers = registers  # {'A': int, 'B': int, 'C': int}
        self.program = program      # list of ints (opcode, operand pairs)
        self.ip = 0                 # instruction pointer
        self.outputs: List[int] = []

    def eval_combo_operand(self, operand: int) -> int:
        """"""Evaluate an operand of combo type.

        Combo operand values:
          0..3   -> literal values 0..3
          4      -> register A
          5      -> register B
          6      -> register C
          7      -> invalid, should not appear

        Raises:
            ValueError if operand == 7 (invalid)

        Returns:
            int: the evaluated value
        """"""
        if 0 <= operand <= 3:
            return operand
        elif operand == 4:
            return self.registers['A']
        elif operand == 5:
            return self.registers['B']
        elif operand == 6:
            return self.registers['C']
        else:
            raise ValueError(f""Invalid combo operand: {operand}"")

    def eval_literal_operand(self, operand: int) -> int:
        """"""Literal operand returns operand as is.""""""
        return operand

    def execute_instruction(self) -> bool:
        """"""Executes the instruction at the current instruction pointer.

        Updates registers, outputs, and instruction pointer.

        Returns:
            bool: True if execution can continue; False if halted (ip out of range)
        """"""
        if self.ip < 0 or self.ip + 1 >= len(self.program):
            # Halt if opcode or operand index out of range
            return False

        opcode = self.program[self.ip]
        operand = self.program[self.ip + 1]

        # Validate opcode and operand range
        if not (0 <= opcode <= 7 and 0 <= operand <= 7):
            raise ValueError(f""Opcode or operand out of allowed range: opcode={opcode}, operand={operand}"")

        # For debug: Uncomment to trace execution
        # print(f""IP={self.ip} opcode={opcode} operand={operand} registers={self.registers}"")

        def power_of_two(exp: int) -> int:
            # Handle large or negative exponents
            # 2^exp, integer
            try:
                return 2 ** exp
            except OverflowError:
                # In case exponent is too large, return a large number (will cause division to zero)
                return 2 ** 31  # arbitrarily large

        if opcode == 0:  # adv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in adv instruction"")
            self.registers['A'] = self.registers['A'] // denom
            self.ip += 2

        elif opcode == 1:  # bxl
            # operand: literal
            val = self.eval_literal_operand(operand)
            self.registers['B'] = self.registers['B'] ^ val
            self.ip += 2

        elif opcode == 2:  # bst
            # operand: combo
            val = self.eval_combo_operand(operand) % 8
            self.registers['B'] = val
            self.ip += 2

        elif opcode == 3:  # jnz
            # operand: literal
            val = self.eval_literal_operand(operand)
            if self.registers['A'] != 0:
                # jump to operand literal index
                if val < 0 or val >= len(self.program):
                    # The problem states program halts if ip out of range
                    # So jumping out of range means halt immediately
                    return False
                self.ip = val
            else:
                self.ip += 2

        elif opcode == 4:  # bxc
            # operand ignored
            self.registers['B'] = self.registers['B'] ^ self.registers['C']
            self.ip += 2

        elif opcode == 5:  # out
            # operand: combo
            val = self.eval_combo_operand(operand) % 8
            self.outputs.append(val)
            self.ip += 2

        elif opcode == 6:  # bdv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in bdv instruction"")
            self.registers['B'] = self.registers['A'] // denom
            self.ip += 2

        elif opcode == 7:  # cdv
            # operand: combo
            exp = self.eval_combo_operand(operand)
            denom = power_of_two(exp)
            if denom == 0:
                raise ZeroDivisionError(""Division by zero in cdv instruction"")
            self.registers['C'] = self.registers['A'] // denom
            self.ip += 2

        else:
            # invalid opcode
            raise ValueError(f""Invalid opcode encountered: {opcode}"")

        return True

    def run_program(self) -> List[int]:
        """"""Run the entire program until halt.

        Returns:
            List[int]: collected output values
        """"""
        while self.execute_instruction():
            pass
        return self.outputs


def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the input file to extract initial register values and the program.

    Args:
        input_file (str): Path to the input file

    Returns:
        Tuple[Dict[str, int], List[int]]: ({'A': int, 'B': int, 'C': int}, program list)
    """"""
    registers = {'A': 0, 'B': 0, 'C': 0}
    program: List[int] = []

    # Patterns to capture: 'Register X: <int>' and 'Program: ...'
    reg_pattern = re.compile(r'Register ([ABC]):\s*(-?\d+)')
    program_pattern = re.compile(r'Program:\s*([0-7,\s]+)')

    with open(input_file, 'r') as f:
        content = f.read()

    # Extract registers
    for reg, val in reg_pattern.findall(content):
        registers[reg] = int(val)

    # Extract program
    prog_match = program_pattern.search(content)
    if not prog_match:
        raise ValueError(""Program line not found in input"")

    program_str = prog_match.group(1)
    # Parse comma-separated program integers
    program = [int(x.strip()) for x in program_str.split(',') if x.strip() != '']

    # Validate program length even
    if len(program) % 2 != 0:
        raise ValueError(""Program length must be even (opcode-operand pairs)"")

    # Validate values between 0 and 7 inclusive
    for val in program:
        if not (0 <= val <= 7):
            raise ValueError(f""Program contains invalid 3-bit value: {val}"")

    return registers, program


def solve(program_input_file: str) -> str:
    """"""Main solution function: parse input, run computer, and produce output string.""""""
    registers, program = parse_input(program_input_file)
    computer = ChronospatialComputer(registers, program)
    outputs = computer.run_program()

    # Format output as comma-separated string
    return ','.join(str(output) for output in outputs)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    result = solve(input_file)
    print(result)


if __name__ == '__main__':
    main()
"
19,single-model,gpt-4.1-mini,True,18.732471227645874,"import sys
from typing import List, Set

""""""
Advent of Code 2022 Day 19: Linen Layout

The puzzle involves determining how many desired towel designs can be formed exactly
by concatenating available towel patterns. Each towel pattern is a fixed sequence of
stripe colors, and designs must be formed by concatenation of these patterns without
rearrangement.

Approach:
- Parse the input: first line lists towel patterns; subsequent lines list desired designs.
- For each design, use dynamic programming or memoized recursion to check if it can be
  segmented into the available towel patterns.
- Count designs that are possible.

Usage:
    python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> (Set[str], List[str]):
    """"""Parse the puzzle input file.

    Args:
        input_file: Path to the input file

    Returns:
        Tuple of available patterns (set) and list of desired designs
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip() != '']

    if not lines:
        raise ValueError(""Input file is empty or invalid format."")

    # First line: available towel patterns
    available_patterns = set(lines[0].split(', '))

    # Remaining lines: desired designs
    designs = lines[1:]

    return available_patterns, designs

def can_form_design(design: str, patterns: Set[str], memo: dict) -> bool:
    """"""Check if a design can be formed by concatenating the available towel patterns.

    Uses memoized recursion to improve efficiency.

    Args:
        design: The design string to check
        patterns: Set of available towel patterns
        memo: Dictionary used for memoization

    Returns:
        True if design can be formed, False otherwise
    """"""
    if design == '':
        return True
    if design in memo:
        return memo[design]

    for i in range(1, len(design) + 1):
        prefix = design[:i]
        if prefix in patterns:
            if can_form_design(design[i:], patterns, memo):
                memo[design] = True
                return True
    memo[design] = False
    return False

def count_possible_designs(patterns: Set[str], designs: List[str]) -> int:
    """"""Count how many designs can be formed by the given towel patterns.

    Args:
        patterns: Set of available towel patterns
        designs: List of desired designs

    Returns:
        Number of possible designs
    """"""
    count = 0
    for design in designs:
        memo = {}
        if can_form_design(design, patterns, memo):
            count += 1
    return count

def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    try:
        patterns, designs = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"")
        return

    result = count_possible_designs(patterns, designs)
    print(result)  # Only print the final answer

# Example test with provided example input data
# This block runs only if this script is invoked directly and helps validate correctness
if __name__ == ""__main__"":
    main()
"
19,system,gpt-4.1-mini,True,130.3029282093048,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution to determine how many target towel designs can be formed by concatenating given towel patterns.

Approach:
- Parse input into a set of towel patterns and a list of target designs.
- For each design, use dynamic programming (word break algorithm) to check if it can be segmented
  into one or more concatenations of the available towel patterns.
- Count and output the total number of possible designs.

Usage: python3 solution.py [input_file]
""""""
from typing import Set, List
import sys


def parse_input(input_file: str) -> (Set[str], List[str]):
    """"""Parse input file to extract towel patterns and target designs.

    Args:
        input_file: Path to the puzzle input file.

    Returns:
        Tuple containing:
          - set of towel patterns (strings)
          - list of design strings to check
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Find the blank line separating patterns from designs
    try:
        blank_index = lines.index('')
    except ValueError:
        # No blank line, fallback: assume first line patterns, rest designs
        blank_index = 1

    # Parse patterns
    pattern_line = lines[0]
    patterns = set(p.strip() for p in pattern_line.split(',') if p.strip())

    # Parse designs
    designs = [line for line in lines[blank_index+1:] if line]

    return patterns, designs


def can_form_design(design: str, pattern_set: Set[str]) -> bool:
    """"""Check if the design string can be segmented into a sequence of towel patterns.

    Uses a dynamic programming approach (word break).

    Args:
        design: The target design string.
        pattern_set: Set of available towel patterns.

    Returns:
        True if the design can be formed by concatenating available patterns, False otherwise.
    """"""
    n = len(design)
    dp = [False] * (n + 1)
    dp[0] = True  # Empty substring can always be formed

    # Optional: Cache max pattern length for optimization
    max_pattern_length = max((len(p) for p in pattern_set), default=0)

    for i in range(1, n + 1):
        # Only check up to max pattern length steps back to optimize
        start_index = max(0, i - max_pattern_length)
        for j in range(start_index, i):
            if dp[j] and design[j:i] in pattern_set:
                dp[i] = True
                break
    return dp[n]


def count_possible_designs(patterns: Set[str], designs: List[str]) -> int:
    """"""Count how many designs can be formed from the given towel patterns.

    Args:
        patterns: Set of available towel patterns.
        designs: List of design strings.

    Returns:
        Count of designs that can be formed.
    """"""
    count = 0
    for design in designs:
        if not design:
            # Empty design trivially formable (if considered valid)
            count += 1
            continue

        # If design contains chars not in any pattern at all, skip early
        # Gather set of all chars from patterns
        # This optimization avoids unnecessary DP on impossible designs
        all_pattern_chars = set(''.join(patterns))
        if any(c not in all_pattern_chars for c in design):
            continue

        if can_form_design(design, patterns):
            count += 1
    return count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    patterns, designs = parse_input(input_file)

    result = count_possible_designs(patterns, designs)

    # Print only the result as required
    print(result)


if __name__ == '__main__':
    main()
"
20,single-model,gpt-4.1-mini,False,72.63818454742432,"from typing import List, Tuple, Dict, Set
import sys
from collections import deque, defaultdict

""""""
Advent of Code 2018 Day 20: Race Condition

This problem involves finding shortest paths on a grid representing a racetrack with walls and track cells.
- Part 1: Find the shortest picoseconds (steps) from Start (S) to End (E) moving orthogonally.
- Part 2: Programs are allowed exactly one cheat, which disables collision for up to 2 steps, allowing to move through walls for these moves.
  The cheat must start on a track cell and end on a track cell, with at most 2 moves through walls.

We must find all distinct cheats defined by their start and end positions when used exactly once, and how much time they save compared to the normal shortest path.

Finally, count how many cheats save at least 100 picoseconds.

Approach:
1. Parse the map, identify S and E, walls and tracks.
2. BFS to get shortest distances on normal track from S to all reachable positions (including E).
3. For all possible cheats (start pos on track, cheat duration 1 or 2 moves through walls, ending on track), compute the path length when applying the cheat once.
4. The cheat path length = dist_normal[S->cheat_start] + cheat_moves (1 or 2 moves through walls) + dist_normal[cheat_end->E]
5. Difference (normal_dist - cheat_path_len) is the saving.

Implementation details:
- Precompute dist_from_start and dist_to_end (reversed graph BFS from E) on normal track.
- For every cell reachable on normal track, and for cheat length 1 or 2, try to move through walls using BFS with cheat moves allowed.
- Collect cheats as (start pos, end pos) with their savings.
- Finally count number with saving >= 100.

This approach uses BFS and careful state management to avoid huge complexity.

Usage: python3 solution.py [input_file]
""""""


def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]:
    """"""Parse the racetrack from input file.

    Args:
      input_file: path to file

    Returns:
      grid: 2D list of chars
      start: coordinates of S (row, col)
      end: coordinates of E (row, col)
    """"""
    grid = []
    start = end = (-1, -1)
    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            row = list(line.rstrip('\n'))
            grid.append(row)
            for c, ch in enumerate(row):
                if ch == 'S':
                    start = (r, c)
                elif ch == 'E':
                    end = (r, c)
    return grid, start, end


def neighbors(r: int, c: int, max_r: int, max_c: int) -> List[Tuple[int, int]]:
    """"""Return orthogonal neighbors inside bounds.
    """"""
    for nr, nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:
        if 0 <= nr < max_r and 0 <= nc < max_c:
            yield nr, nc


def bfs_distances(grid: List[List[str]], start: Tuple[int,int]) -> Dict[Tuple[int,int], int]:
    """"""Compute shortest distances on normal track (not crossing walls) from start.

    Returns dict mapping position to distance.
    Walls ('#') are considered blocked.
    """"""
    rows, cols = len(grid), len(grid[0])
    dist = {}
    queue = deque([start])
    dist[start] = 0
    while queue:
        r, c = queue.popleft()
        for nr, nc in neighbors(r, c, rows, cols):
            if grid[nr][nc] != '#' and (nr, nc) not in dist:
                dist[(nr, nc)] = dist[(r, c)] + 1
                queue.append((nr, nc))
    return dist


def bfs_distances_to_end(grid: List[List[str]], end: Tuple[int,int]) -> Dict[Tuple[int,int], int]:
    """"""Compute shortest distances on normal track from end position (reverse BFS for quick lookup).

    Useful to get dist from any position to end quickly.
    """"""
    # Same as bfs_distances but from end
    return bfs_distances(grid, end)


def find_cheats(
    grid: List[List[str]],
    dist_start: Dict[Tuple[int,int], int],
    dist_end: Dict[Tuple[int,int], int]) -> Dict[int, Set[Tuple[Tuple[int,int], Tuple[int,int]]]]:
    """"""Find and classify all cheats by their savings.

    A cheat is defined by start and end position where cheat enabled and cheat disabled,
    allows passing through walls for 1 or 2 moves.

    Returns dict mapping saving -> set of (cheat_start, cheat_end)
    """"""
    rows, cols = len(grid), len(grid[0])
    cheats_by_saving: Dict[int, Set[Tuple[Tuple[int,int], Tuple[int,int]]]] = defaultdict(set)

    # A cheat is:
    # - start on track cell
    # - one or two moves moving through walls allowed
    # - end on track cell
    # - the program must be on normal track again at the end

    # We will try every position reachable normally as cheat activation start
    # From there, try paths through walls with length 1 or 2 moves
    # BFS with state: current pos, cheat moves used (0 to 2)

    for cheat_start in dist_start.keys():
        if grid[cheat_start[0]][cheat_start[1]] == '#':
            continue  # must start cheat on track

        # BFS starting from cheat_start allowing 1 or 2 moves through walls
        # State: position, cheat_moves_used
        queue = deque()
        visited = dict()  # key: (pos), val: minimal cheat moves used to get here

        # Starting point: no cheat moves used yet
        queue.append( (cheat_start[0], cheat_start[1], 0) )
        visited[(cheat_start[0], cheat_start[1])] = 0

        while queue:
            r, c, cheat_moves_used = queue.popleft()

            # If cheat_moves_used in [1,2] and current cell is track cell (not wall) and != start
            # then potential cheat endpoint
            if cheat_moves_used in (1, 2) and grid[r][c] != '#' and (r,c) != cheat_start:
                # Check if path with cheat:
                # Total moves = dist_start[cheat_start] + cheat_moves_used + dist_end[(r,c)]
                # Normal distance: dist_start[end]
                if (r,c) in dist_end:
                    normal_dist = dist_start.get(grid_end, None) if 'grid_end' in globals() else None  # We'll get global grid_end later
                    # Actually, normal dist from start to end
                    norm_dist = dist_start.get(grid_end, None)
                    # but more robust to pass arg grid_end
                    # We'll do calculation here by args from main

                    # We'll store cheats now with saving calculation done in main.
                    # So here just store cheat start, end, and cheat_moves used
                    # We will calculate savings later.

                    # Store in cheats_by_saving using a temporary key
                    # We will compute saving later after final solution distance known.
                    # To avoid complexity, we store cheats plus their path length:= dist_start[cheat_start] + cheat_moves_used + dist_end[(r,c)]
                    total_cheat_path_len = dist_start[cheat_start] + cheat_moves_used + dist_end[(r, c)]
                    # Actual minimal path length from start to end on normal track:
                    # Will be computed outside.

                    # We cannot store by saving yet, so instead collect separately in a list.
                    cheats_by_saving[-total_cheat_path_len].add( (cheat_start, (r,c)) )

            # Explore neighbors
            for nr, nc in neighbors(r, c, rows, cols):
                next_cell = grid[nr][nc]
                next_cheat_moves_used = cheat_moves_used
                if next_cell == '#':
                    next_cheat_moves_used += 1
                    if next_cheat_moves_used > 2:
                        continue  # cannot cheat through more than 2 moves

                # We must be on track again after cheat ends, but during cheating moves we can be over walls.
                # So we track visits by minimal cheat moves used.

                # Prevent revisiting worse states
                if (nr, nc) not in visited or visited[(nr, nc)] > next_cheat_moves_used:
                    visited[(nr, nc)] = next_cheat_moves_used
                    queue.append( (nr, nc, next_cheat_moves_used) )

    return cheats_by_saving


def find_all_cheats(
    grid: List[List[str]],
    dist_start: Dict[Tuple[int,int], int],
    dist_end: Dict[Tuple[int,int], int],
    start: Tuple[int,int],
    end: Tuple[int,int]) -> Dict[int, Set[Tuple[Tuple[int,int], Tuple[int,int]]]]:
    """"""More complete and corrected version:
    Finds cheats and their savings.

    Returns dict mapping savings -> set of (cheat_start, cheat_end)
    """"""
    rows, cols = len(grid), len(grid[0])
    cheats_by_saving: Dict[int, Set[Tuple[Tuple[int,int], Tuple[int,int]]]] = defaultdict(set)

    # We'll iterate over all positions reachable normally
    # For each, launch BFS to try 1 or 2 moves cheat through walls, ending on track
    # Then compute savings: normal shortest path - (dist_start to cheat_start + cheat_moves + dist_end from cheat_end)

    for cheat_start in dist_start.keys():
        if grid[cheat_start[0]][cheat_start[1]] == '#':
            continue  # cheat must start on track

        # BFS states: (r, c, cheat_moves_used)
        queue = deque()
        visited = dict()  # map (r,c) -> minimal cheat moves used to reach

        queue.append( (cheat_start[0], cheat_start[1], 0) )
        visited[(cheat_start[0], cheat_start[1])] = 0

        while queue:
            r, c, cheat_moves_used = queue.popleft()

            if cheat_moves_used in (1, 2) and grid[r][c] != '#' and (r,c) != cheat_start and (r,c) in dist_end:
                # Calculate savings
                normal_path_len = dist_start[end]
                cheat_path_len = dist_start[cheat_start] + cheat_moves_used + dist_end[(r,c)]
                saving = normal_path_len - cheat_path_len
                if saving > 0:
                    cheats_by_saving[saving].add( (cheat_start, (r,c)) )

            for nr, nc in neighbors(r, c, rows, cols):
                next_cell = grid[nr][nc]
                next_cheat_moves_used = cheat_moves_used
                if next_cell == '#':
                    next_cheat_moves_used += 1
                    if next_cheat_moves_used > 2:
                        continue

                # Only visit if better (lower) cheat_moves_used for that cell
                if (nr, nc) not in visited or visited[(nr, nc)] > next_cheat_moves_used:
                    visited[(nr, nc)] = next_cheat_moves_used
                    queue.append( (nr, nc, next_cheat_moves_used) )

    return cheats_by_saving


def solve_part_one(grid: List[List[str]], start: Tuple[int,int], end: Tuple[int,int]) -> int:
    """"""Find shortest path from S to E on track only.

    Args:
      grid: racetrack map
      start: coordinates of S
      end: coordinates of E

    Returns:
      shortest time (picoseconds) to reach E from S
    """"""
    dist_start = bfs_distances(grid, start)
    if end not in dist_start:
        raise ValueError(""End position is unreachable from start on track."")
    return dist_start[end]


def solve_part_two(grid: List[List[str]], start: Tuple[int,int], end: Tuple[int,int]) -> int:
    """"""Count cheats saving at least 100 picoseconds.

    Args:
      grid: racetrack map
      start: coordinates of S
      end: coordinates of E

    Returns:
      number of cheats saving at least 100 picoseconds
    """"""
    dist_start = bfs_distances(grid, start)
    dist_end = bfs_distances(grid, end)  # distances from end to every reachable position

    if end not in dist_start:
        # No path at all
        return 0

    cheats = find_all_cheats(grid, dist_start, dist_end, start, end)

    # Count cheats with saving >= 100

    count = 0
    for saving, cheat_set in cheats.items():
        if saving >= 100:
            count += len(cheat_set)

    return count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    grid, start, end = parse_input(input_file)

    # Solve part one (shortest path without cheating)
    part_one_result = solve_part_one(grid, start, end)

    # Solve part two (count cheats saving at least 100 picoseconds)
    part_two_result = solve_part_two(grid, start, end)

    # As per problem, print only the final answer for part two
    print(part_two_result)


if __name__ == ""__main__"":
    main()
"
20,system,gpt-4.1-mini,False,902.9904699325562,
21,single-model,gpt-4.1-mini,False,87.77519154548645,"""""""
Advent of Code 2022 Day 21: Keypad Conundrum

Solution overview:
- We have a chain of robots, each controlled by directional keypads.
- The goal is to type 5 given codes on the numeric keypad (last keypad in the chain).
- Each code is typed by a sequence of directional keypad presses on the first keypad
  (the one we press).

Keypads (from last to first robot):
- Numeric keypad: buttons arranged as described with positions and labels.
- Robot 1 directional keypad (controls numeric keypad robot).
- Robot 2 directional keypad (controls Robot 1).
- The directional keypad we use (controls Robot 2).

Constraints:
- Each robot arm position starts at 'A' key on its keypad.
- Moving robot arms only allowed over valid keys (no gaps).
- Buttons pressed on directional keypad are: ^ (up), v (down), < (left), > (right), A (activate/press current button).
- To produce the numeric keypad code, we need shortest possible sequences of presses.

We need to:
- For each code among the 5 given codes, find the shortest possible sequence on the top-level directional keypad
  that results in that code being typed on the numeric keypad.

Key approach:
- Model each keypad as a graph with valid key positions.
- The act of typing a code can be represented as the sequence of moves needed on the numeric keypad robot.
- Then find minimal sequences of presses on intermediate keypad robots to get those moves, recursively.
- Finally, find minimal sequences on the top-level keypad to generate the full instructions.

We use BFS to find shortest paths between keys on each keypad.

Summary of steps:
1. Define keypads with coords and adjacency. Create mapping keypad_label -> neighbors.
2. For each robot layer, precompute shortest sequences to move from any key to any other and activate.
3. For each code digit in numeric keypad, find shortest sequence of moves starting from 'A' on numeric keypad, moving to digit and pressing.
4. Then find shortest sequences to type that numeric keypad sequence on robot 1 keypad.
5. Then find shortest sequences to type that robot 1 keypad sequence on robot 2 keypad.
6. Finally, find shortest sequences to type robot 2 keypad sequence on top-level keypad (our keypad).
7. The length of this final sequence is the number of button presses needed.
8. Compute complexity = length * numeric value of code (ignoring leading zeros).
9. Sum complexities for all 5 codes.

This solution uses BFS and memoization of shortest sequences.
The solution is fully automated for the given 5 codes.

Usage: python3 solution.py [input_file]
""""""
from typing import Dict, Tuple, List, Set
import sys
from collections import deque

# Keypad definitions
# Positions and neighbors define adjacency (no gaps allowed)

# Numeric keypad layout (last robot moves):
# +---+---+---+
# | 7 | 8 | 9 |
# +---+---+---+
# | 4 | 5 | 6 |
# +---+---+---+
# | 1 | 2 | 3 |
# +---+---+---+
#     | 0 | A |
#     +---+---+

NUMPAD_KEYS = [
    (0, 2, '7'), (1, 2, '8'), (2, 2, '9'),
    (0, 1, '4'), (1, 1, '5'), (2, 1, '6'),
    (0, 0, '1'), (1, 0, '2'), (2, 0, '3'),
           (1, -1, '0'), (2, -1, 'A')
]

# Build neighbors map for numeric keypad
# Movement allowed up/down/left/right if button exists

def build_keypad_graph(keys: List[Tuple[int,int,str]]) -> Dict[str, List[str]]:
    pos_to_key = {(x, y): k for x, y, k in keys}
    graph: Dict[str, List[str]] = {k: [] for _, _, k in keys}
    for x, y, k in keys:
        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
            nx, ny = x + dx, y + dy
            if (nx, ny) in pos_to_key:
                graph[k].append(pos_to_key[(nx, ny)])
    return graph

NUMPAD_GRAPH = build_keypad_graph(NUMPAD_KEYS)

# Robot directional keypad (used by robot controlling numeric keypad):
# +---+---+
# | ^ | A |
# +---+---+
# | < | v | >
# +---+---+---+
# Coordinates:
# Row 1:    (0,1) '^', (1,1) 'A'
# Row 0: (-1,0) '<', (0,0) 'v', (1,0) '>'

DIRECTIONAL1_KEYS = [
    (0,1,'^'), (1,1,'A'),
    (-1,0,'<'), (0,0,'v'), (1,0,'>')
]

DIRECTIONAL1_GRAPH = build_keypad_graph(DIRECTIONAL1_KEYS)

# Robot directional keypad for robot 2 (controls robot 1): same layout as DIRECTIONAL1
DIRECTIONAL2_KEYS = DIRECTIONAL1_KEYS
DIRECTIONAL2_GRAPH = DIRECTIONAL1_GRAPH

# Our directional keypad (top level controlling robot 2):
# Same layout as robots above.
OUR_KEYS = DIRECTIONAL1_KEYS
OUR_GRAPH = DIRECTIONAL1_GRAPH

# Mapping of movement keys for directional keypad presses
MOVES = {
    '^': 'up',
    'v': 'down',
    '<': 'left',
    '>': 'right'
}

# For each keypad, define which keys correspond to
# - movement directions for the arm on these keypads
# - the A (activate) button

# Since directional keypads use <, ^, v, > for movement buttons and A for press
# Numeric keypad uses digits + A

# For each keypad we will precompute shortest sequences for transitions


def bfs_shortest_sequence(
    graph: Dict[str, List[str]],
    start: str,
    goal: str
) -> List[str]:
    """"""Find shortest sequence of moves to get from start to goal on keypad graph.
    Returns list of moves which are keys to press on directional keypad
    (e.g. '^', 'v', '<', '>') excluding the final activation press.

    Since movement on keypad means pressing the directional keypad buttons named '^', 'v', etc.,
    the moves correspond to moves on this graph. Here, nodes are keys on the keypad.

    Note: we return the sequence of directional keypad buttons pressed to move the arm.
    """"""
    queue = deque()
    queue.append((start, []))
    seen = {start}

    while queue:
        node, path = queue.popleft()
        if node == goal:
            return path
        for neighbor in graph[node]:
            if neighbor not in seen:
                seen.add(neighbor)
                # Determine which directional button press moves from node to neighbor
                # Movement vector
                # Find the move direction character that transitions node->neighbor

                # Instead of encoding position, we can use coordinates from keypad keys
                # We must find the move key (directional keypad button) that moves from node to neighbor
                # For directional keypads, positions are known and fixed
                # For numeric keypad, moves correspond to directions '^', 'v', '<', '>' depending on difference

                # Let's get positions for current graph
                # We do not have coords here, let's pass them with graph building
                # For now, we assume it's always one step orthogonally

                # Use helper position map
                from_pos = KEY_POSITIONS[CURRENT_KEYPAD][node]
                to_pos = KEY_POSITIONS[CURRENT_KEYPAD][neighbor]
                dx = to_pos[0] - from_pos[0]
                dy = to_pos[1] - from_pos[1]
                move_char = None
                if dx == 0 and dy == 1:
                    move_char = '^'
                elif dx == 0 and dy == -1:
                    move_char = 'v'
                elif dx == -1 and dy == 0:
                    move_char = '<'
                elif dx == 1 and dy == 0:
                    move_char = '>'
                else:
                    # Should never happen due to adjacency
                    continue
                queue.append((neighbor, path + [move_char]))
    # No path found
    return []


def precompute_move_sequences(graph: Dict[str, List[str]],
                              key_positions: Dict[str, Tuple[int,int]]) -> Dict[Tuple[str,str], List[str]]:
    """"""Precompute shortest sequences of moves (directional keypad presses excluding 'A')
    to get from any key to any other key.

    Returns dict keyed by (start, end) to list of moves.
    """"""
    sequences = {}
    keys = list(graph.keys())
    global CURRENT_KEYPAD
    global KEY_POSITIONS

    for start in keys:
        for end in keys:
            CURRENT_KEYPAD = graph
            KEY_POSITIONS = {k: v for k,v in key_positions.items()}  # needed for bfs
            seq = bfs_shortest_path_using_positions(graph, key_positions, start, end)
            sequences[(start, end)] = seq
    return sequences


def bfs_shortest_path_using_positions(
    graph: Dict[str, List[str]],
    positions: Dict[str, Tuple[int,int]],
    start: str,
    end: str
) -> List[str]:
    """"""BFS to find shortest sequence of directional button presses
    to move from start key to end key on given keypad with known key positions.

    Moves are one of '^', 'v', '<', '>' corresponding to direction.
    """"""
    queue = deque()
    queue.append((start, []))
    seen = {start}
    while queue:
        node, path = queue.popleft()
        if node == end:
            return path
        for neighbor in graph[node]:
            if neighbor not in seen:
                seen.add(neighbor)
                dx = positions[neighbor][0] - positions[node][0]
                dy = positions[neighbor][1] - positions[node][1]

                if dx == 0 and dy == 1:
                    move = '^'
                elif dx == 0 and dy == -1:
                    move = 'v'
                elif dx == -1 and dy == 0:
                    move = '<'
                elif dx == 1 and dy == 0:
                    move = '>'
                else:
                    # Invalid move
                    continue
                queue.append((neighbor, path + [move]))
    return []

# Define key positions per keypad for BFS moves
# Format: key -> (x,y)

NUMPAD_POSITIONS = {k: (x,y) for x,y,k in NUMPAD_KEYS}
DIRECTIONAL_POSITIONS = {k: (x,y) for x,y,k in DIRECTIONAL1_KEYS}

# Global current keypad and positions required for BFS helper
CURRENT_KEYPAD = None
KEY_POSITIONS = None


def type_on_keypad(
    code: str,
    initial_pos: str,
    move_sequences: Dict[Tuple[str,str], List[str]],
    pressing_a: bool = True
) -> List[str]:
    """"""Given a code (sequence of keys to press) on a keypad,
    produce the moves (directional button presses) needed to type it,
    starting from initial_pos. For each key in code, move from current pos to that key,
    then press 'A' (activation) if pressing_a is True.

    Returns the full sequence of presses (including 'A').
    """"""
    sequence = []
    pos = initial_pos
    for ch in code:
        # Move arm from pos to ch
        moves = move_sequences[(pos, ch)]
        sequence.extend(moves)
        if pressing_a:
            sequence.append('A')
        pos = ch
    return sequence


def get_numeric_value(code: str) -> int:
    """"""Extract numeric value from code ignoring leading zeros and ignoring final 'A' if present.""""""
    # Code ends with 'A' button, but numeric value ignores it
    numeric_part = ''.join(ch for ch in code if ch.isdigit())
    return int(numeric_part) if numeric_part else 0


# The five codes to be typed on the numeric keypad
CODES = ['029A', '980A', '179A', '456A', '379A']


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    # Input file not used as the codes are fixed in problem description
    # Still read as placeholder
    input_file = sys.argv[1]

    # Build graphs and precompute moves for each keypad

    # Numeric keypad
    numeric_graph = NUMPAD_GRAPH
    numeric_positions = NUMPAD_POSITIONS
    numeric_move_sequences = precompute_move_sequences(numeric_graph, numeric_positions)

    # Robot 1 directional keypad controlling numeric keypad
    r1_graph = DIRECTIONAL1_GRAPH
    r1_positions = DIRECTIONAL_POSITIONS
    r1_move_sequences = precompute_move_sequences(r1_graph, r1_positions)

    # Robot 2 directional keypad controlling robot 1
    r2_graph = DIRECTIONAL2_GRAPH
    r2_positions = DIRECTIONAL_POSITIONS
    r2_move_sequences = precompute_move_sequences(r2_graph, r2_positions)

    # Our directional keypad controlling robot 2
    our_graph = OUR_GRAPH
    our_positions = DIRECTIONAL_POSITIONS
    our_move_sequences = precompute_move_sequences(our_graph, our_positions)

    total_complexity = 0

    for code in CODES:
        # Step 1: For numeric keypad, get moves to type code:
        # Start position is 'A'
        numeric_start = 'A'
        numeric_seq = type_on_keypad(code, numeric_start, numeric_move_sequences, pressing_a=True)
        # numeric_seq is list of directional presses for robot controlling numeric keypad
        # Convert to string
        numeric_seq_str = ''.join(numeric_seq)

        # Step 2: For robot 1 keypad, type numeric_seq_str
        r1_start = 'A'
        r1_seq = type_on_keypad(numeric_seq_str, r1_start, r1_move_sequences, pressing_a=True)
        r1_seq_str = ''.join(r1_seq)

        # Step 3: For robot 2 keypad, type r1_seq_str
        r2_start = 'A'
        r2_seq = type_on_keypad(r1_seq_str, r2_start, r2_move_sequences, pressing_a=True)
        r2_seq_str = ''.join(r2_seq)

        # Step 4: For our keypad, type r2_seq_str
        our_start = 'A'
        our_seq = type_on_keypad(r2_seq_str, our_start, our_move_sequences, pressing_a=True)

        presses_count = len(our_seq)

        # Calculate numeric value ignoring leading zeros (and trailing 'A')
        numeric_val = get_numeric_value(code)

        complexity = presses_count * numeric_val

        total_complexity += complexity

    # Only print final answer
    print(total_complexity)

if __name__ == '__main__':
    main()
"
21,system,gpt-4.1-mini,False,814.6077556610107,
22,single-model,gpt-4.1-mini,True,21.34328055381775,"""""""
Advent of Code 2022 Day 22: Monkey Market
Solution implements the pseudorandom sequence generation described to find the 2000th new secret number for each buyer and sum them.

Approach:
- Parse each initial secret number from the input file.
- For each buyer, iterate 2000 times to compute the next secret number following the specified process:
  * Multiply secret number by 64, mix (XOR), and prune (mod 16777216).
  * Divide secret number by 32 (floor), mix, prune.
  * Multiply secret number by 2048, mix, prune.
- Sum all 2000th new secret numbers from each buyer.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys
import math

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of initial secret numbers.

    Args:
        input_file: Path to the input file

    Returns:
        List of integers representing initial secret numbers of buyers
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f if line.strip()]
    return [int(line) for line in lines]


def next_secret_number(secret_num: int) -> int:
    """"""Given the current secret number, generate the next secret number
    following the problem's specific process.

    Steps:
      1. Multiply secret_num by 64, mix (XOR), then prune.
      2. Divide secret_num by 32 (floor), mix, prune.
      3. Multiply secret_num by 2048, mix, prune.

    Args:
        secret_num: Current secret number

    Returns:
        Next secret number after applying the transformations
    """"""
    MODULO = 16777216  # 2^24

    # Step 1: multiply by 64, mix, prune
    val = secret_num * 64
    secret_num = (secret_num ^ val) % MODULO

    # Step 2: divide by 32 (floor), mix, prune
    val = secret_num // 32  # integer division (floor)
    secret_num = (secret_num ^ val) % MODULO

    # Step 3: multiply by 2048, mix, prune
    val = secret_num * 2048
    secret_num = (secret_num ^ val) % MODULO

    return secret_num


def simulate_secret_numbers(initial_secrets: List[int], steps: int) -> int:
    """"""Simulate the creation of secret numbers for each buyer and sum the
    secret number after the given number of steps for each buyer.

    Args:
        initial_secrets: List of initial secret numbers for each buyer
        steps: Number of new secret numbers to generate for each

    Returns:
        Sum of the secret number after 'steps' iterations for all buyers
    """"""
    total = 0
    for secret in initial_secrets:
        current = secret
        for _ in range(steps):
            current = next_secret_number(current)
        total += current
    return total


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    initial_secrets = parse_input(input_file)

    # Problem specifies 2000 new secret numbers per buyer
    steps = 2000
    result = simulate_secret_numbers(initial_secrets, steps)

    # ONLY print the final result to STDOUT
    print(result)

# If examples are needed for testing, include here:
# Example inputs from the description:
# 1, 10, 100, 2024 -> after 2000 steps: [8685429, 4700978, 15273692, 8667524]
# sum = 37327623

def _test():
    example_secrets = [1, 10, 100, 2024]
    expected = 37327623
    actual = simulate_secret_numbers(example_secrets, 2000)
    assert actual == expected, f""Example test failed: expected {expected}, got {actual}""

if __name__ == ""__main__"":
    _test()  # Run example test
    main()
"
22,system,gpt-4.1-mini,True,142.2858030796051,"""""""
Advent of Code Monkey Market (Day 22)

Simulate each buyer's pseudorandom secret number sequence for 2000 iterations.
Each iteration consists of three steps applying multiplication, division, XOR mixing, and pruning modulo 2^24.
After simulating all buyers, output the sum of their 2000th secret numbers.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

MODULO = 16777216  # 2^24
ITERATIONS = 2000


def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input file into a list of initial secret numbers.

    Args:
        input_file: Path to the input file.

    Returns:
        List of integers representing initial secret numbers for each buyer.
    """"""
    secret_numbers = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line == '':
                continue
            try:
                num = int(line)
                secret_numbers.append(num)
            except ValueError:
                # Ignore invalid lines
                continue
    return secret_numbers


def transform_one_iteration(secret: int) -> int:
    """"""Apply the three-step transformation to generate the next secret number from the current one.

    Args:
        secret: Current secret number.

    Returns:
        Updated secret number after one iteration.
    """"""
    # Step 1: multiply by 64, XOR, prune
    val = (secret * 64) & 0xFFFFFFFFFFFFFFFF  # safely handle larger intermediates
    secret ^= val
    secret %= MODULO

    # Step 2: divide by 32 (floor), XOR, prune
    val = secret // 32
    secret ^= val
    secret %= MODULO

    # Step 3: multiply by 2048, XOR, prune
    val = (secret * 2048) & 0xFFFFFFFFFFFFFFFF
    secret ^= val
    secret %= MODULO

    return secret


def simulate_secret_numbers(initial_secrets: List[int], iterations: int = ITERATIONS) -> List[int]:
    """"""Simulate the secret number sequence for each buyer.

    Args:
        initial_secrets: List of initial secret numbers.
        iterations: Number of iterations to simulate.

    Returns:
        List of secret numbers at the specified iteration for each buyer.
    """"""
    results = []
    for secret in initial_secrets:
        current = secret
        for _ in range(iterations):
            current = transform_one_iteration(current)
        results.append(current)
    return results


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    initial_secrets = parse_input(input_file)

    if not initial_secrets:
        # No buyers, output zero
        print(0)
        return

    final_secrets = simulate_secret_numbers(initial_secrets, ITERATIONS)

    total_sum = sum(final_secrets)

    print(total_sum)


if __name__ == ""__main__"":
    main()
"
23,single-model,gpt-4.1-mini,True,16.988250255584717,"import sys
from typing import Dict, Set, List, Tuple
import itertools

""""""
Advent of Code 2022 Day 23: LAN Party

We are given a list of bidirectional connections between computers.

Goal:
- Find all sets of three distinct computers where every pair in the trio is connected (a triangle).
- Among these sets, count how many have at least one computer whose name starts with 't'.

Approach:
- Parse the input into an adjacency list.
- Find all combinations of 3 distinct computers.
- For each combination, check if all pairs are connected.
- Filter those that contain at least one computer starting with 't'.
- Count and output the result.

This solution efficiently builds adjacency data and tests each triple without redundant checks.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> Dict[str, Set[str]]:
    """"""Parse the input file and build a graph as adjacency sets.

    Args:
        input_file: Path to input file

    Returns:
        Dictionary mapping each node to a set of connected nodes.
    """"""
    graph: Dict[str, Set[str]] = {}

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            comp1, comp2 = line.split('-')
            if comp1 not in graph:
                graph[comp1] = set()
            if comp2 not in graph:
                graph[comp2] = set()
            graph[comp1].add(comp2)
            graph[comp2].add(comp1)
    return graph


def find_triangles(graph: Dict[str, Set[str]]) -> List[Tuple[str, str, str]]:
    """"""Find all sets of three mutually connected computers.

    Args:
        graph: Adjacency dictionary

    Returns:
        List of sorted tuples, each a set of three interconnected computers
    """"""
    triangles = []
    nodes = sorted(graph.keys())

    # For each combination of three distinct nodes
    for trio in itertools.combinations(nodes, 3):
        a, b, c = trio
        # Check if each pair is connected (undirected)
        if (b in graph[a] and c in graph[a] and
            a in graph[b] and c in graph[b] and
            a in graph[c] and b in graph[c]):
            triangles.append(trio)
    return triangles


def count_triangles_with_t(triangles: List[Tuple[str, str, str]]) -> int:
    """"""Count triangles that have at least one computer starting with 't'.

    Args:
        triangles: List of triples

    Returns:
        Count satisfying the condition
    """"""
    count = 0
    for trio in triangles:
        if any(node.startswith('t') for node in trio):
            count += 1
    return count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    graph = parse_input(input_file)
    triangles = find_triangles(graph)
    result = count_triangles_with_t(triangles)

    # Output only the final result
    print(result)


# Test the example given in the description (for debugging only)
if __name__ == ""__main__"":
    main()"
23,system,gpt-4.1-mini,True,130.9585349559784,"""""""
Advent of Code 2023 Day 23: LAN Party

Problem:
Given an undirected graph of computers connected by edges, find all unique triplets
of computers where each is directly connected to the other two (forming triangles).
Count how many of these triangles contain at least one computer whose name starts with 't'.

Approach:
- Parse input into an adjacency list (dictionary of sets) for fast neighbor lookups.
- For each node `a`, iterate over pairs of its neighbors `(b, c)` where lex order a < b < c,
  to avoid duplicate triangle counting.
- Check if `b` and `c` are connected; if yes, record this triangle.
- Count only those triangles that include at least one computer starting with 't'.

Usage: python3 solution.py [input_file]
""""""
from typing import Dict, Set
import sys
import itertools


def parse_input(input_file: str) -> Dict[str, Set[str]]:
    """"""Parse the input file to build an undirected graph adjacency list.

    Args:
        input_file: Path to input file containing lines of 'computerA-computerB'

    Returns:
        Adjacency dictionary mapping each computer to a set of its connected neighbors.
    """"""
    adjacency: Dict[str, Set[str]] = {}
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            a, b = line.split('-')
            # Add edge a <-> b
            if a not in adjacency:
                adjacency[a] = set()
            if b not in adjacency:
                adjacency[b] = set()
            adjacency[a].add(b)
            adjacency[b].add(a)
    return adjacency


def count_triangles_with_t(adjacency: Dict[str, Set[str]]) -> int:
    """"""Count triangles (triplets of computers fully connected) that contain at least one name starting with 't'.

    Args:
        adjacency: Graph adjacency dictionary

    Returns:
        Integer count of qualifying triangles
    """"""
    count = 0
    # Sort nodes to enforce lexicographical ordering a < b < c
    sorted_nodes = sorted(adjacency.keys())

    for a in sorted_nodes:
        neighbors = adjacency[a]
        # Filter neighbors greater than a to maintain ordering a < b < c
        neighbors_filtered = [n for n in neighbors if n > a]
        # Check all pairs (b, c) from neighbors_filtered
        for b, c in itertools.combinations(neighbors_filtered, 2):
            # Check if b and c are connected
            if c in adjacency[b]:  # Triangle found: (a, b, c)
                # Check if any in (a, b, c) starts with 't'
                if a.startswith('t') or b.startswith('t') or c.startswith('t'):
                    count += 1
    return count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]
    adjacency = parse_input(input_file)
    result = count_triangles_with_t(adjacency)
    print(result)


if __name__ == '__main__':
    main()
"
24,single-model,gpt-4.1-mini,True,35.286212682724,"import sys
import re
from typing import Dict, Tuple, List, Optional

""""""
Advent of Code 2023 Day 24: Crossed Wires

Simulate a circuit of boolean logic gates based on input wire initial values and gate definitions.
Each gate has two input wires and one output wire, applying AND, OR or XOR operations.

Once all dependent inputs for a gate's output wire are known, calculate output.
No loops present, so repeated processing until all wires are resolved.

Finally, combine bits on wires that start with 'z' in lexicographical order (z00 is least significant bit)
and output that binary number as a decimal integer.

Usage: python3 solution.py [input_file]
""""""

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[Tuple[str, str, str, str]]]:
    """"""
    Parse the puzzle input file into initial wire values and gate definitions.

    Args:
        input_file: path to input file

    Returns:
        initial_values: Dict mapping wire names to their initial 0/1 values
        gates: List of tuples (input_wire1, operator, input_wire2, output_wire)
    """"""
    initial_values: Dict[str, int] = {}
    gates: List[Tuple[str, str, str, str]] = []

    wire_value_pattern = re.compile(r'^([a-z0-9]+): ([01])$')
    gate_pattern = re.compile(r'^([a-z0-9]+) (AND|OR|XOR) ([a-z0-9]+) -> ([a-z0-9]+)$')

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            m_val = wire_value_pattern.match(line)
            if m_val:
                wire_name = m_val.group(1)
                wire_val = int(m_val.group(2))
                initial_values[wire_name] = wire_val
                continue

            m_gate = gate_pattern.match(line)
            if m_gate:
                in1 = m_gate.group(1)
                op = m_gate.group(2)
                in2 = m_gate.group(3)
                out = m_gate.group(4)
                gates.append((in1, op, in2, out))
                continue

            # If line is neither initial value nor gate definition, ignore or raise error?
            # For safety, we ignore blank lines and comments.

    return initial_values, gates


def apply_gate(op: str, val1: int, val2: int) -> int:
    """"""
    Apply boolean logic gate operation between two inputs.

    Args:
        op: Operation string 'AND', 'OR', or 'XOR'
        val1: First input value (0 or 1)
        val2: Second input value (0 or 1)

    Returns:
        Resulting value after operation (0 or 1)
    """"""
    if op == 'AND':
        return val1 & val2
    if op == 'OR':
        return val1 | val2
    if op == 'XOR':
        return val1 ^ val2
    raise ValueError(f""Unknown gate operation: {op}"")


def simulate_gates(initial_values: Dict[str, int],
                   gates: List[Tuple[str, str, str, str]]) -> Dict[str, int]:
    """"""
    Simulate the logic gate system until all gate outputs are computed.

    Args:
        initial_values: Known initial wire values
        gates: List of gate definitions

    Returns:
        Final dictionary of wire values after simulation
    """"""

    wire_values: Dict[str, int] = dict(initial_values)  # current known wire values
    # For quick access, map output wire to the gate that produces it
    out_wire_to_gate = {}
    for in1, op, in2, out in gates:
        out_wire_to_gate[out] = (in1, op, in2)

    # Track which gates have been processed
    processed_outputs = set(wire_values.keys())

    # We'll keep processing gates until all output wires of gates are assigned
    # or no progress possible (should not happen as there are no loops)

    # Prepare a set of output wires we want to compute
    output_wires = set(out_wire_to_gate.keys())

    # While there remain gates whose output not yet computed
    while not output_wires.issubset(wire_values.keys()):
        progress_made = False

        for out in output_wires:
            # Skip if already computed
            if out in wire_values:
                continue

            in1, op, in2 = out_wire_to_gate[out]

            # Both inputs need to have values
            if in1 in wire_values and in2 in wire_values:
                val1 = wire_values[in1]
                val2 = wire_values[in2]
                wire_values[out] = apply_gate(op, val1, val2)
                progress_made = True

        if not progress_made:
            # No further progress possible, but output wires remain not computed
            # Means incomplete input or logic loop (not expected per problem)
            break

    return wire_values


def extract_and_compute_result(wire_values: Dict[str, int]) -> int:
    """"""
    Combine the bits on wires starting with 'z' in lex order,
    with the lex smallest wire name as least significant bit,
    to form a binary number and return its decimal value.

    Args:
        wire_values: Dict of wire values

    Returns:
        Decimal integer representation of the combined bits
    """"""

    z_wires = [w for w in wire_values if w.startswith('z')]
    if not z_wires:
        # No wires starting with z, output 0
        return 0

    # Sort lexicographically; lex smallest wire is least significant bit
    z_wires.sort()

    bits = ''.join(str(wire_values[w]) for w in reversed(z_wires))
    # reversed because lex smallest is least significant bit -> last bit in string

    # Convert binary string to int
    return int(bits, 2)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    initial_values, gates = parse_input(input_file)

    wire_values = simulate_gates(initial_values, gates)

    result = extract_and_compute_result(wire_values)

    print(result)


if __name__ == '__main__':
    main()
"
24,system,gpt-4.1-mini,True,243.21573853492737,"""""""
Advent of Code 2024 Day 24: Crossed Wires

Simulate a combinational boolean logic circuit with wires and gates (AND, OR, XOR).
Given initial wire values and gate connections, compute all wire values in topological order.
Finally, combine all 'z' wires sorted by their numeric suffix into a binary number and output its decimal value.

Usage: python3 solution.py [input_file]
""""""
from typing import Dict, List, Tuple, Optional
import sys
import re
from collections import deque

class Gate:
    def __init__(self, input1: str, gate_type: str, input2: str, output: str):
        self.input1 = input1
        self.input2 = input2
        self.gate_type = gate_type
        self.output = output
        self.unresolved_inputs = 2  # Initially assume both inputs unknown

    def evaluate(self, wire_values: Dict[str, int]) -> int:
        v1 = wire_values.get(self.input1)
        v2 = wire_values.get(self.input2)
        if v1 is None or v2 is None:
            # Not ready yet
            return None
        if self.gate_type == 'AND':
            return v1 & v2
        elif self.gate_type == 'OR':
            return v1 | v2
        elif self.gate_type == 'XOR':
            return v1 ^ v2
        else:
            raise ValueError(f""Unknown gate type: {self.gate_type}"")

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[Gate]]:
    """"""Parse puzzle input into initial wire values and gate definitions.

    Args:
        input_file: Path to input file

    Returns:
        Tuple of:
        - dict of wire name to initial value (int 0 or 1)
        - list of Gate objects
    """"""
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Split input into two sections separated by a blank line
    try:
        blank_idx = lines.index('')
    except ValueError:
        # No blank line?
        blank_idx = -1

    if blank_idx == -1:
        initial_lines = lines
        gate_lines = []
    else:
        initial_lines = lines[:blank_idx]
        gate_lines = lines[blank_idx+1:]

    wire_values: Dict[str, int] = {}
    gates: List[Gate] = []

    # Parse initial wire values: format 'wxx: x'
    initial_re = re.compile(r'^([a-zA-Z0-9]+):\s*([01])$')
    for line in initial_lines:
        if not line:
            continue
        m = initial_re.match(line)
        if m:
            wire = m.group(1)
            val = int(m.group(2))
            wire_values[wire] = val
        else:
            # Defensive: if line does not match, ignore (or raise?)
            raise ValueError(f""Invalid initial wire line: {line}"")

    # Parse gates: format 'wire1 GATE wire2 -> wire_out'
    gate_re = re.compile(r'^([a-zA-Z0-9]+)\s+(AND|OR|XOR)\s+([a-zA-Z0-9]+)\s+->\s+([a-zA-Z0-9]+)$')
    for line in gate_lines:
        if not line:
            continue
        m = gate_re.match(line)
        if not m:
            raise ValueError(f""Invalid gate definition line: {line}"")
        in1, gate_type, in2, out = m.groups()
        gates.append(Gate(in1, gate_type, in2, out))

    return wire_values, gates


def simulate_circuit(wire_values: Dict[str, Optional[int]], gates: List[Gate]) -> Dict[str, int]:
    """"""Simulate the circuit by topological evaluation.

    Args:
        wire_values: dict mapping wire name to known initial values or None
        gates: list of Gate objects

    Returns:
        dict of wire values after simulation
    """"""
    # Build wire to dependent gates mapping
    wire_to_gates: Dict[str, List[Gate]] = {}

    # For each gate, track how many inputs are unresolved
    for gate in gates:
        # Count how many inputs are unknown
        unresolved = 0
        if wire_values.get(gate.input1) is None:
            unresolved += 1
        if wire_values.get(gate.input2) is None:
            unresolved += 1
        gate.unresolved_inputs = unresolved

        # Register this gate in dependency map for inputs
        wire_to_gates.setdefault(gate.input1, []).append(gate)
        wire_to_gates.setdefault(gate.input2, []).append(gate)

    # Queue for wires whose values are known and can propagate
    queue = deque()
    for wire, val in wire_values.items():
        if val is not None:
            queue.append(wire)

    # Ensure all wires encountered in gates are in wire_values with None if missing
    for gate in gates:
        if gate.output not in wire_values:
            wire_values[gate.output] = None
        # Also ensure inputs exist in wire_values (may not have initial values)
        if gate.input1 not in wire_values:
            wire_values[gate.input1] = None
        if gate.input2 not in wire_values:
            wire_values[gate.input2] = None

    while queue:
        wire = queue.popleft()
        wire_val = wire_values[wire]
        if wire_val is None:
            # Defensive: skip wires without known value
            continue

        # For each gate depending on this wire, reduce unresolved inputs count
        for gate in wire_to_gates.get(wire, []):
            # If output already known, skip
            if wire_values.get(gate.output) is not None:
                continue
            # Reduce unresolved inputs if this was unknown before for that gate
            # The gate.unresolved_inputs was set initially, so decrement for each known input encountered
            # But decrementing multiple times if both inputs feed into same gate must be prevented.
            # Safer to count unresolved each time:
            # count of inputs that are None
            count_unresolved = 0
            if wire_values.get(gate.input1) is None:
                count_unresolved += 1
            if wire_values.get(gate.input2) is None:
                count_unresolved += 1
            gate.unresolved_inputs = count_unresolved
            if gate.unresolved_inputs == 0:
                # Both inputs known, evaluate
                out_val = gate.evaluate(wire_values)
                if out_val is None:
                    # Defensive: should not happen due to above check
                    raise RuntimeError(f""Gate {gate.output} evaluation: inputs missing"")
                wire_values[gate.output] = out_val
                queue.append(gate.output)

    # At this point all possible wires that can be resolved should be set
    return wire_values


def sort_z_wires(wire_values: Dict[str, int]) -> List[int]:
    """"""Get values of all wires starting with 'z', sorted by numeric suffix.

    Args:
        wire_values: dict wire name -> int

    Returns:
        List of bit values (ints), least significant bit first (z00)
    """"""
    z_wires = []
    pattern = re.compile(r'^z(\d+)$')

    for wire in wire_values.keys():
        m = pattern.match(wire)
        if m:
            index = int(m.group(1))
            val = wire_values[wire]
            if val is None:
                # Treat unknown z bits as 0 (or raise?) Problem does not say missing bits.
                val = 0
            z_wires.append((index, val))

    # Sort by numeric suffix ascending
    z_wires.sort(key=lambda x: x[0])

    return [v[1] for v in z_wires]


def bits_to_decimal(bits: List[int]) -> int:
    """"""Convert list of bits (lsb first) to decimal integer.

    Args:
        bits: list of 0/1 integers

    Returns:
        Integer value
    """"""
    val = 0
    for i, bit in enumerate(bits):
        if bit not in (0, 1):
            raise ValueError(f""Invalid bit value {bit} at index {i}"")
        val |= (bit << i)
    return val


def solve(input_file: str) -> int:
    wire_values, gates = parse_input(input_file)
    final_wire_values = simulate_circuit(wire_values, gates)
    z_bits = sort_z_wires(final_wire_values)
    result = bits_to_decimal(z_bits)
    return result


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        result = solve(input_file)
        print(result)
    except Exception as e:
        print(f""Error: {e}"", file=sys.stderr)
        sys.exit(1)


# Optional: include example test runner if desired
# But per problem instructions only print final result

if __name__ == '__main__':
    main()
"
25,single-model,gpt-4.1-mini,False,35.10308241844177," """"""
Advent of Code 2022 Day 25: Code Chronicle
Solution implementation based on the provided plan.

This puzzle involves parsing schematic diagrams of locks and keys, represented as grids of '#' and '.' characters,
where each schematic is 7 rows of 5 columns with specific properties for locks and keys.
Locks have the top row completely filled (#) and the bottom row empty (.),
representing pins extending downward from the top of each column.
Keys have the bottom row completely filled (#) and the top row empty (.),
representing keys extending upward from the bottom of each column.

We convert each schematic into a list of heights per column:
 - For locks: pin heights counting # downward from top until the first '.' in that column
 - For keys: key heights counting # upward from bottom until the first '.' in that column

A lock and a key fit together if for every column, the sum of their heights is <= 6 (since schematic height is 7 rows, indices 0-6),
meaning pins and keys do not overlap.

We then count the number of unique lock/key pairs that fit together.

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple
import sys
import re

SCHEMATIC_HEIGHT: int = 7
SCHEMATIC_WIDTH: int = 5


def parse_input(input_file: str) -> Tuple[List[List[int]], List[List[int]]]:
    """"""Parse the puzzle input schematics into lists of lock and key heights.

    Args:
        input_file: Path to the input file containing schematics.

    Returns:
        A tuple (locks, keys) where each is a list of lists of integers representing the heights per column.
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f if line.strip() != '']

    # Each schematic consists of 7 lines of 5 characters each
    if len(lines) % SCHEMATIC_HEIGHT != 0:
        raise ValueError(f""Input does not contain a multiple of {SCHEMATIC_HEIGHT} lines per schematic."")

    schematics: List[List[str]] = []
    for i in range(0, len(lines), SCHEMATIC_HEIGHT):
        schematic = lines[i:i+SCHEMATIC_HEIGHT]
        if any(len(row) != SCHEMATIC_WIDTH for row in schematic):
            raise ValueError(""Each schematic line must be exactly 5 characters long."")
        schematics.append(schematic)

    locks: List[List[int]] = []
    keys: List[List[int]] = []

    for schematic in schematics:
        # Determine if this schematic is a lock or a key
        # Locks: top row all '#', bottom row all '.'
        # Keys: bottom row all '#', top row all '.'
        top_row = schematic[0]
        bottom_row = schematic[-1]

        if all(c == '#' for c in top_row) and all(c == '.' for c in bottom_row):
            heights = compute_lock_heights(schematic)
            locks.append(heights)
        elif all(c == '.' for c in top_row) and all(c == '#' for c in bottom_row):
            heights = compute_key_heights(schematic)
            keys.append(heights)
        else:
            # Unknown schematic type, ignore or raise error
            raise ValueError(""Schematic does not match lock or key pattern."")

    return locks, keys


def compute_lock_heights(schematic: List[str]) -> List[int]:
    """"""Compute the pin heights for a lock schematic.

    Args:
        schematic: List of 7 strings of length 5 representing the schematic.

    Returns:
        List of 5 integers representing pin heights for each column.

    The height is counted downward from top row until first '.' in that column,
    minus one (since rows start from 0). For example, if all 7 rows are '#', height is 6.
    If top is '#', and next is '.', height is 0.
    """"""
    heights = []
    for col in range(SCHEMATIC_WIDTH):
        height = -1
        for row in range(SCHEMATIC_HEIGHT):
            if schematic[row][col] == '#':
                height = row
            else:
                break
        heights.append(height)
    return heights


def compute_key_heights(schematic: List[str]) -> List[int]:
    """"""Compute the key heights for a key schematic.

    Args:
        schematic: List of 7 strings of length 5 representing the schematic.

    Returns:
        List of 5 integers representing key heights for each column.

    The height is counted upward from bottom row until first '.' in that column,
    counted as bottom row index (6) minus first '.' row index.
    For example, if all 7 rows are '#', height is 6.
    If bottom is '#' and next is '.', height is 0.
    """"""
    heights = []
    for col in range(SCHEMATIC_WIDTH):
        height = -1
        for row in range(SCHEMATIC_HEIGHT - 1, -1, -1):
            if schematic[row][col] == '#':
                height = SCHEMATIC_HEIGHT - 1 - row
            else:
                break
        if height == -1:
            # No '#' in this column (should not happen for keys but handle gracefully)
            height = 0
        heights.append(height)
    return heights


def fit_lock_key(lock: List[int], key: List[int]) -> bool:
    """"""Check if a given key fits a given lock without overlapping pins.

    Args:
        lock: List of integers representing pin heights per column.
        key: List of integers representing key heights per column.

    Returns:
        True if the sum of lock and key heights in every column is <= 6 (no overlap), False otherwise.
    """"""
    for l_height, k_height in zip(lock, key):
        # If either is -1 (meaning no pin or key), treat missing pins as height 0
        l_h = l_height if l_height >= 0 else 0
        k_h = k_height if k_height >= 0 else 0
        if l_h + k_h > 6:
            return False
    return True


def count_fitting_pairs(locks: List[List[int]], keys: List[List[int]]) -> int:
    """"""Count the number of unique lock/key pairs that fit together.

    Args:
        locks: List of lock heights.
        keys: List of key heights.

    Returns:
        The count of unique pairs where key fits the lock.
    """"""
    count = 0
    for lock in locks:
        for key in keys:
            if fit_lock_key(lock, key):
                count += 1
    return count


def main() -> None:
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    try:
        locks, keys = parse_input(input_file)
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        sys.exit(1)

    result = count_fitting_pairs(locks, keys)

    # Print only the final result
    print(result)


if __name__ == ""__main__"":
    main()
"
25,system,gpt-4.1-mini,True,137.2981560230255,"""""""
Advent of Code Day 25: Code Chronicle

This solution parses schematic grids of locks and keys, extracts pin heights per column for each schematic,
then counts how many unique lock/key pairs fit together without overlapping pins.

Locks have pins extending downward from the top row; keys have pins extending upward from the bottom row.
Two fit if for every column, sum of lock pin height and key pin height \u2264 total grid height.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[List[str]], List[List[str]], int, int]:
    """"""Parse the input file into separate lock and key schematic grids.

    Args:
        input_file: Path to input file.

    Returns:
        A tuple with:
         - list of lock schematics (each schematic is list of strings)
         - list of key schematics (each schematic is list of strings)
         - grid height (int)
         - grid width (int)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f]

    # Remove any trailing empty lines
    while lines and lines[-1] == '':
        lines.pop()

    # We need to split the input into schematic blocks separated by blank lines
    schematics: List[List[str]] = []
    current: List[str] = []

    for line in lines:
        if line.strip() == '':
            if current:
                schematics.append(current)
                current = []
        else:
            current.append(line)
    if current:
        schematics.append(current)

    if not schematics:
        raise ValueError(""No schematics found in input."")

    # Validate all schematics have the same grid size
    h = len(schematics[0])
    w = len(schematics[0][0]) if h > 0 else 0
    for schematic in schematics:
        if len(schematic) != h:
            raise ValueError(""Inconsistent schematic heights."")
        for row in schematic:
            if len(row) != w:
                raise ValueError(""Inconsistent schematic widths."")

    locks = []
    keys = []

    # Classify each schematic as lock or key:
    # Lock: top row fully or mostly '#' and bottom row mostly '.'
    # Key: top row mostly '.' and bottom row mostly '#'

    def is_lock(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Locks have top row mostly '#' and bottom row mostly '.'
        # We'll require top row to be all '#'
        if all(c == '#' for c in top) and all(c == '.' for c in bottom):
            return True
        return False

    def is_key(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Keys have top row mostly '.' and bottom row mostly '#'
        if all(c == '.' for c in top) and all(c == '#' for c in bottom):
            return True
        return False

    for schematic in schematics:
        if is_lock(schematic):
            locks.append(schematic)
        elif is_key(schematic):
            keys.append(schematic)
        else:
            raise ValueError(""Unrecognized schematic type (neither lock nor key)."")

    return locks, keys, h, w


def extract_lock_heights(lock_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each lock schematic.

    Args:
        lock_schematics: List of lock grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each lock
    """"""
    locks_heights = []
    for schematic in lock_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from top downward
            for row in range(grid_height):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        locks_heights.append(heights)
    return locks_heights


def extract_key_heights(key_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each key schematic.

    Args:
        key_schematics: List of key grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each key
    """"""
    keys_heights = []
    for schematic in key_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from bottom upward
            for row in range(grid_height - 1, -1, -1):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        keys_heights.append(heights)
    return keys_heights


def count_compatible_pairs(locks_heights: List[List[int]], keys_heights: List[List[int]], grid_height: int) -> int:
    """"""Count the number of unique lock/key pairs that fit together without pin overlap.

    Args:
        locks_heights: List of pin heights per column for each lock
        keys_heights: List of pin heights per column for each key
        grid_height: Total height of grid

    Returns:
        Integer count of compatible pairs
    """"""
    compatible_count = 0
    for l_idx, lock in enumerate(locks_heights):
        for k_idx, key in enumerate(keys_heights):
            # Check per column
            for col in range(len(lock)):
                if lock[col] + key[col] > grid_height:
                    # Overlap, no fit
                    break
            else:
                # No break => fits
                compatible_count += 1
    return compatible_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    locks, keys, h, w = parse_input(input_file)

    # Extract pin heights
    lock_heights = extract_lock_heights(locks, h, w)
    key_heights = extract_key_heights(keys, h, w)

    # Count compatible pairs
    result = count_compatible_pairs(lock_heights, key_heights, h)

    print(result)


if __name__ == '__main__':
    main()
"
1,single-model,o3-mini,False,13.809261798858643,threw-error
2,single-model,o3-mini,False,16.434154987335205,threw-error
3,single-model,o3-mini,False,12.332103967666626,threw-error
4,single-model,o3-mini,True,12.888856887817383,"#!/usr/bin/env python3
""""""
Advent of Code Day 4: Ceres Search

This solution reads a word search grid from the puzzle input and counts the number of occurrences of the word ""XMAS"". The word can appear horizontally, vertically, diagonally, and in reverse order. The approach is to iterate over every grid cell and check in all eight directions if the next three letters (for a total of 4 including the start) form the word ""XMAS"".

Usage: python3 solution.py [input_file]
""""""

from typing import List
import sys

# All eight possible directions (dx, dy): horizontal, vertical, diagonal
DIRECTIONS = [
    (-1, -1), (-1, 0), (-1, 1),
    (0, -1),           (0, 1),
    (1, -1),  (1, 0),  (1, 1)
]

TARGET_WORD = ""XMAS""
TARGET_LENGTH = len(TARGET_WORD)


def parse_input(input_file: str) -> List[str]:
    """"""
    Reads the puzzle input file and returns a list of strings, each representing a row in the letter grid.

    Args:
        input_file: Path to the input file

    Returns:
        A list of strings representing the grid. Each string is a row from the grid.
    """"""
    with open(input_file, 'r') as f:
        # Strip the newline from each line and filter out empty lines
        lines = [line.strip() for line in f if line.strip()]
    return lines


def count_word_occurrences(grid: List[str], word: str) -> int:
    """"""
    Counts occurrences of a given word in the grid. The word can be found in any of eight directions.

    Args:
        grid: The grid of letters as a list of strings
        word: The target word to search for

    Returns:
        The count of occurrences of the word.
    """"""
    if not grid:
        return 0

    rows = len(grid)
    cols = len(grid[0])
    count = 0

    # Iterate over every cell in the grid
    for r in range(rows):
        for c in range(cols):
            # Check in each direction
            for dr, dc in DIRECTIONS:
                # Compute the end position for the word if starting from cell (r, c)
                end_r = r + dr * (TARGET_LENGTH - 1)
                end_c = c + dc * (TARGET_LENGTH - 1)
                # If the end position is out of bounds, skip this direction
                if not (0 <= end_r < rows and 0 <= end_c < cols):
                    continue
                # Build the candidate word by traversing the direction
                candidate = []
                for i in range(TARGET_LENGTH):
                    nr = r + dr * i
                    nc = c + dc * i
                    candidate.append(grid[nr][nc])
                candidate_word = ''.join(candidate)
                if candidate_word == word:
                    count += 1
    return count


def solve_part_one(grid: List[str]) -> int:
    """"""
    Solves the puzzle by counting the occurrences of ""XMAS"" in the grid.

    Args:
        grid: The parsed grid from the input

    Returns:
        The number of times ""XMAS"" appears in the grid
    """"""
    return count_word_occurrences(grid, TARGET_WORD)


def main() -> None:
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Compute solution for part one
    result = solve_part_one(grid)

    # ONLY PRINT THE FINAL RESULT
    print(result)

    # Optional: Additional debugging can be done here if necessary by writing to stderr.


if __name__ == ""__main__"":
    main()
"
4,system,o3-mini,False,7.80345344543457,threw-error
4,system,o3-mini,True,7.803569078445435,"""""""
Advent of Code Day 25: Code Chronicle

This solution parses schematic grids of locks and keys, extracts pin heights per column for each schematic,
then counts how many unique lock/key pairs fit together without overlapping pins.

Locks have pins extending downward from the top row; keys have pins extending upward from the bottom row.
Two fit if for every column, sum of lock pin height and key pin height \u2264 total grid height.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[List[str]], List[List[str]], int, int]:
    """"""Parse the input file into separate lock and key schematic grids.

    Args:
        input_file: Path to input file.

    Returns:
        A tuple with:
         - list of lock schematics (each schematic is list of strings)
         - list of key schematics (each schematic is list of strings)
         - grid height (int)
         - grid width (int)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f]

    # Remove any trailing empty lines
    while lines and lines[-1] == '':
        lines.pop()

    # We need to split the input into schematic blocks separated by blank lines
    schematics: List[List[str]] = []
    current: List[str] = []

    for line in lines:
        if line.strip() == '':
            if current:
                schematics.append(current)
                current = []
        else:
            current.append(line)
    if current:
        schematics.append(current)

    if not schematics:
        raise ValueError(""No schematics found in input."")

    # Validate all schematics have the same grid size
    h = len(schematics[0])
    w = len(schematics[0][0]) if h > 0 else 0
    for schematic in schematics:
        if len(schematic) != h:
            raise ValueError(""Inconsistent schematic heights."")
        for row in schematic:
            if len(row) != w:
                raise ValueError(""Inconsistent schematic widths."")

    locks = []
    keys = []

    # Classify each schematic as lock or key:
    # Lock: top row fully or mostly '#' and bottom row mostly '.'
    # Key: top row mostly '.' and bottom row mostly '#'

    def is_lock(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Locks have top row mostly '#' and bottom row mostly '.'
        # We'll require top row to be all '#'
        if all(c == '#' for c in top) and all(c == '.' for c in bottom):
            return True
        return False

    def is_key(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Keys have top row mostly '.' and bottom row mostly '#'
        if all(c == '.' for c in top) and all(c == '#' for c in bottom):
            return True
        return False

    for schematic in schematics:
        if is_lock(schematic):
            locks.append(schematic)
        elif is_key(schematic):
            keys.append(schematic)
        else:
            raise ValueError(""Unrecognized schematic type (neither lock nor key)."")

    return locks, keys, h, w


def extract_lock_heights(lock_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each lock schematic.

    Args:
        lock_schematics: List of lock grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each lock
    """"""
    locks_heights = []
    for schematic in lock_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from top downward
            for row in range(grid_height):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        locks_heights.append(heights)
    return locks_heights


def extract_key_heights(key_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each key schematic.

    Args:
        key_schematics: List of key grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each key
    """"""
    keys_heights = []
    for schematic in key_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from bottom upward
            for row in range(grid_height - 1, -1, -1):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        keys_heights.append(heights)
    return keys_heights


def count_compatible_pairs(locks_heights: List[List[int]], keys_heights: List[List[int]], grid_height: int) -> int:
    """"""Count the number of unique lock/key pairs that fit together without pin overlap.

    Args:
        locks_heights: List of pin heights per column for each lock
        keys_heights: List of pin heights per column for each key
        grid_height: Total height of grid

    Returns:
        Integer count of compatible pairs
    """"""
    compatible_count = 0
    for l_idx, lock in enumerate(locks_heights):
        for k_idx, key in enumerate(keys_heights):
            # Check per column
            for col in range(len(lock)):
                if lock[col] + key[col] > grid_height:
                    # Overlap, no fit
                    break
            else:
                # No break => fits
                compatible_count += 1
    return compatible_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    locks, keys, h, w = parse_input(input_file)

    # Extract pin heights
    lock_heights = extract_lock_heights(locks, h, w)
    key_heights = extract_key_heights(keys, h, w)

    # Count compatible pairs
    result = count_compatible_pairs(lock_heights, key_heights, h)

    print(result)


if __name__ == '__main__':
    main()
"
5,single-model,o3-mini,False,16.608728170394897,threw-error
6,single-model,o3-mini,False,30.04589557647705,threw-error
7,single-model,o3-mini,False,14.669738531112671,threw-error
8,single-model,o3-mini,True,16.497196435928345,"""""""
Advent of Code Day 8: Resonant Collinearity

This solution reads the puzzle input which is a grid map containing antennas represented by a single character (digit or letter).
For each frequency (character), it collects all antenna positions. For every pair of antennas with the same frequency, it computes
two potential antinodes using the formulae:
    P1 = 2*A - B
    P2 = 2*B - A

Only positions that lie within the bounds of the map are counted. The final answer is the number of unique antinode positions.

Usage: python3 solution.py [input_file]
""""""

from typing import List, Tuple, Set, Dict
import sys


def parse_input(input_file: str) -> Tuple[List[str], int, int, Dict[str, List[Tuple[int, int]]]]:
    """"""
    Parse the input file into a grid and collect antenna positions by frequency.

    Args:
        input_file: Path to puzzle input file

    Returns:
        A tuple containing:
          - grid: List of strings representing the rows of the map
          - rows: number of rows
          - cols: number of columns
          - antennas: dictionary mapping frequency (character) to a list of (row, col) positions where that antenna occurs
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip(""\n"") for line in f if line.rstrip(""\n"") != '']

    if not lines:
        return [], 0, 0, {}

    rows = len(lines)
    cols = len(lines[0])
    antennas: Dict[str, List[Tuple[int, int]]] = {}

    # Collect positions of antennas (non-dot characters) along with their frequency
    for r, line in enumerate(lines):
        if len(line) != cols:
            # if lines are not the same length, we assume irregular input, but we take the length of first line as map bounds
            cols = max(cols, len(line))
        for c, ch in enumerate(line):
            if ch != '.':
                antennas.setdefault(ch, []).append((r, c))

    return lines, rows, cols, antennas


def solve_puzzle(grid: List[str], rows: int, cols: int, antennas: Dict[str, List[Tuple[int, int]]]) -> int:
    """"""
    For each frequency group, compute potential antinode positions from every pair of antennas.
    Only count locations that fall within the map bounds.

    Args:
        grid: The grid of characters representing the map
        rows: Number of rows in the map
        cols: Number of columns in the map
        antennas: Dictionary mapping frequency to list of (row, col) antenna positions

    Returns:
        The total number of unique antinode positions within the map bounds.
    """"""
    antinodes: Set[Tuple[int, int]] = set()

    # For each frequency, consider each pair among antennas with that frequency
    for freq, positions in antennas.items():
        n = len(positions)
        if n < 2:
            # less than 2 antennas, cannot form a pair
            continue

        # Compare each pair once
        for i in range(n):
            for j in range(i + 1, n):
                a = positions[i]
                b = positions[j]
                # Compute the two potential antinode positions
                # They are given by: p1 = 2*a - b, p2 = 2*b - a
                p1 = (2 * a[0] - b[0], 2 * a[1] - b[1])
                p2 = (2 * b[0] - a[0], 2 * b[1] - a[1])

                # Only add if they fall within the grid bounds
                if 0 <= p1[0] < rows and 0 <= p1[1] < cols:
                    antinodes.add(p1)
                if 0 <= p2[0] < rows and 0 <= p2[1] < cols:
                    antinodes.add(p2)

    return len(antinodes)


def main():
    # Ensure proper usage
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse the puzzle input
    grid, rows, cols, antennas = parse_input(input_file)

    # Solve the puzzle
    result = solve_puzzle(grid, rows, cols, antennas)

    # Only print the final result to STDOUT
    print(result)

    # (Optional) Example testing code with assertions can be added here if needed for debugging and validation.
    # However, per requirements, STDOUT should only print the final result.


if __name__ == '__main__':
    main()
"
8,system,o3-mini,False,20.989017248153687,threw-error
8,system,o3-mini,True,20.98905897140503,"""""""
Advent of Code Day 25: Code Chronicle

This solution parses schematic grids of locks and keys, extracts pin heights per column for each schematic,
then counts how many unique lock/key pairs fit together without overlapping pins.

Locks have pins extending downward from the top row; keys have pins extending upward from the bottom row.
Two fit if for every column, sum of lock pin height and key pin height \u2264 total grid height.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[List[str]], List[List[str]], int, int]:
    """"""Parse the input file into separate lock and key schematic grids.

    Args:
        input_file: Path to input file.

    Returns:
        A tuple with:
         - list of lock schematics (each schematic is list of strings)
         - list of key schematics (each schematic is list of strings)
         - grid height (int)
         - grid width (int)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f]

    # Remove any trailing empty lines
    while lines and lines[-1] == '':
        lines.pop()

    # We need to split the input into schematic blocks separated by blank lines
    schematics: List[List[str]] = []
    current: List[str] = []

    for line in lines:
        if line.strip() == '':
            if current:
                schematics.append(current)
                current = []
        else:
            current.append(line)
    if current:
        schematics.append(current)

    if not schematics:
        raise ValueError(""No schematics found in input."")

    # Validate all schematics have the same grid size
    h = len(schematics[0])
    w = len(schematics[0][0]) if h > 0 else 0
    for schematic in schematics:
        if len(schematic) != h:
            raise ValueError(""Inconsistent schematic heights."")
        for row in schematic:
            if len(row) != w:
                raise ValueError(""Inconsistent schematic widths."")

    locks = []
    keys = []

    # Classify each schematic as lock or key:
    # Lock: top row fully or mostly '#' and bottom row mostly '.'
    # Key: top row mostly '.' and bottom row mostly '#'

    def is_lock(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Locks have top row mostly '#' and bottom row mostly '.'
        # We'll require top row to be all '#'
        if all(c == '#' for c in top) and all(c == '.' for c in bottom):
            return True
        return False

    def is_key(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Keys have top row mostly '.' and bottom row mostly '#'
        if all(c == '.' for c in top) and all(c == '#' for c in bottom):
            return True
        return False

    for schematic in schematics:
        if is_lock(schematic):
            locks.append(schematic)
        elif is_key(schematic):
            keys.append(schematic)
        else:
            raise ValueError(""Unrecognized schematic type (neither lock nor key)."")

    return locks, keys, h, w


def extract_lock_heights(lock_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each lock schematic.

    Args:
        lock_schematics: List of lock grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each lock
    """"""
    locks_heights = []
    for schematic in lock_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from top downward
            for row in range(grid_height):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        locks_heights.append(heights)
    return locks_heights


def extract_key_heights(key_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each key schematic.

    Args:
        key_schematics: List of key grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each key
    """"""
    keys_heights = []
    for schematic in key_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from bottom upward
            for row in range(grid_height - 1, -1, -1):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        keys_heights.append(heights)
    return keys_heights


def count_compatible_pairs(locks_heights: List[List[int]], keys_heights: List[List[int]], grid_height: int) -> int:
    """"""Count the number of unique lock/key pairs that fit together without pin overlap.

    Args:
        locks_heights: List of pin heights per column for each lock
        keys_heights: List of pin heights per column for each key
        grid_height: Total height of grid

    Returns:
        Integer count of compatible pairs
    """"""
    compatible_count = 0
    for l_idx, lock in enumerate(locks_heights):
        for k_idx, key in enumerate(keys_heights):
            # Check per column
            for col in range(len(lock)):
                if lock[col] + key[col] > grid_height:
                    # Overlap, no fit
                    break
            else:
                # No break => fits
                compatible_count += 1
    return compatible_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    locks, keys, h, w = parse_input(input_file)

    # Extract pin heights
    lock_heights = extract_lock_heights(locks, h, w)
    key_heights = extract_key_heights(keys, h, w)

    # Count compatible pairs
    result = count_compatible_pairs(lock_heights, key_heights, h)

    print(result)


if __name__ == '__main__':
    main()
"
9,single-model,o3-mini,False,31.945310592651367,threw-error
10,single-model,o3-mini,False,14.551138162612915,threw-error
11,single-model,o3-mini,True,15.07104229927063,"#!/usr/bin/env python3
""""""
Advent of Code Day 11: Plutonian Pebbles

The puzzle describes an evolving sequence of stones, each engraved with a number. On each blink the stones are transformed simultaneously based on the following rules (applied in order):

1. If the stone's number is 0, replace it with a stone marked 1.
2. Otherwise, if the stone's number has an even number of digits, split the stone into two stones. The first stone gets the left half of the digits and the second stone gets the right half. Leading zeroes are dropped (e.g. 1000 becomes stones 10 and 0).
3. If neither of the above rules applies, replace the stone with a stone whose number is the original number multiplied by 2024.

The initial arrangement of stones is provided as a series of integers separated by whitespace. After blinking 25 times, the task is to determine how many stones are present.

The implementation reads the input from a file provided as an argument, processes the transformations for 25 iterations, and prints the final number of stones.

Usage: python3 solution.py [input_file]
""""""

from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""
    Parse the puzzle input file and return the initial list of stone engravings as integers.

    Args:
        input_file (str): The path to the input file

    Returns:
        List[int]: A list of integers representing the initial stone engravings
    """"""
    try:
        with open(input_file, 'r') as f:
            # Split input by any whitespace and filter out empty strings
            content = f.read().strip()
            if not content:
                return []
            tokens = content.split()
            # Convert each token to integer
            return [int(token) for token in tokens]
    except Exception as e:
        sys.stderr.write(f""Error reading file {input_file}: {e}\n"")
        sys.exit(1)


def evolve_stones(stones: List[int]) -> List[int]:
    """"""
    Given a list of stones, evolve them for one blink based on the rules:
      1. If a stone is 0, replace it with 1.
      2. If a stone's number (except 0) has an even number of digits, split it into two stones.
      3. Otherwise, replace the stone with the stone's number multiplied by 2024.

    Args:
        stones (List[int]): The current arrangement of stones

    Returns:
        List[int]: The new arrangement after one blink
    """"""
    new_stones: List[int] = []
    for stone in stones:
        # Rule 1: If stone is 0, 0 becomes 1
        if stone == 0:
            new_stones.append(1)
            continue
        # Convert the stone's number to string to check digit count
        s = str(stone)
        if len(s) % 2 == 0:  # Even number of digits
            # Rule 2: split into two stones
            mid = len(s) // 2
            left_str, right_str = s[:mid], s[mid:]
            # Convert to integer to remove any leading zeroes
            left_num = int(left_str)
            right_num = int(right_str)
            new_stones.append(left_num)
            new_stones.append(right_num)
        else:
            # Rule 3: multiply stone by 2024
            new_stones.append(stone * 2024)
    return new_stones


def simulate_blinks(initial_stones: List[int], blink_count: int) -> List[int]:
    """"""
    Simulate the evolution of stones for a given number of blinks.

    Args:
        initial_stones (List[int]): Initial list of stones
        blink_count (int): Number of transformation steps (blinks) to simulate

    Returns:
        List[int]: The final arrangement of stones after simulation
    """"""
    stones = initial_stones
    for i in range(blink_count):
        stones = evolve_stones(stones)
    return stones


def solve_puzzle(parsed_data: List[int]) -> int:
    """"""
    Solve the puzzle by simulating 25 blinks on the initial arrangement and returning the count of stones.

    Args:
        parsed_data (List[int]): The initial list of stone numbers

    Returns:
        int: The total number of stones after 25 blinks
    """"""
    blink_count = 25
    final_stones = simulate_blinks(parsed_data, blink_count)
    return len(final_stones)


def main():
    # Check command-line arguments
    if len(sys.argv) < 2:
        sys.stderr.write(""Usage: python3 solution.py [input_file]\n"")
        sys.exit(1)

    input_file = sys.argv[1]
    initial_stones = parse_input(input_file)

    # Solve the puzzle
    solution = solve_puzzle(initial_stones)
    # ONLY output the result to STDOUT
    print(solution)

    # If desired, we could add sample testing code here using assertions and debugging logs to STDERR
    # For example, testing provided examples (commented out):
    # Example test: initial = [0, 1, 10, 99, 999] -> after 1 blink -> [1, 2024, 1, 0, 9, 9, 2021976]
    # test_after_one = evolve_stones([0, 1, 10, 99, 999])
    # assert test_after_one == [1, 2024, 1, 0, 9, 9, 2021976], f""Test failed: {test_after_one}""


if __name__ == ""__main__"":
    main()
"
11,system,o3-mini,False,10.262983560562134,threw-error
11,system,o3-mini,True,10.263112306594849,"""""""
Advent of Code Day 25: Code Chronicle

This solution parses schematic grids of locks and keys, extracts pin heights per column for each schematic,
then counts how many unique lock/key pairs fit together without overlapping pins.

Locks have pins extending downward from the top row; keys have pins extending upward from the bottom row.
Two fit if for every column, sum of lock pin height and key pin height \u2264 total grid height.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[List[str]], List[List[str]], int, int]:
    """"""Parse the input file into separate lock and key schematic grids.

    Args:
        input_file: Path to input file.

    Returns:
        A tuple with:
         - list of lock schematics (each schematic is list of strings)
         - list of key schematics (each schematic is list of strings)
         - grid height (int)
         - grid width (int)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f]

    # Remove any trailing empty lines
    while lines and lines[-1] == '':
        lines.pop()

    # We need to split the input into schematic blocks separated by blank lines
    schematics: List[List[str]] = []
    current: List[str] = []

    for line in lines:
        if line.strip() == '':
            if current:
                schematics.append(current)
                current = []
        else:
            current.append(line)
    if current:
        schematics.append(current)

    if not schematics:
        raise ValueError(""No schematics found in input."")

    # Validate all schematics have the same grid size
    h = len(schematics[0])
    w = len(schematics[0][0]) if h > 0 else 0
    for schematic in schematics:
        if len(schematic) != h:
            raise ValueError(""Inconsistent schematic heights."")
        for row in schematic:
            if len(row) != w:
                raise ValueError(""Inconsistent schematic widths."")

    locks = []
    keys = []

    # Classify each schematic as lock or key:
    # Lock: top row fully or mostly '#' and bottom row mostly '.'
    # Key: top row mostly '.' and bottom row mostly '#'

    def is_lock(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Locks have top row mostly '#' and bottom row mostly '.'
        # We'll require top row to be all '#'
        if all(c == '#' for c in top) and all(c == '.' for c in bottom):
            return True
        return False

    def is_key(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Keys have top row mostly '.' and bottom row mostly '#'
        if all(c == '.' for c in top) and all(c == '#' for c in bottom):
            return True
        return False

    for schematic in schematics:
        if is_lock(schematic):
            locks.append(schematic)
        elif is_key(schematic):
            keys.append(schematic)
        else:
            raise ValueError(""Unrecognized schematic type (neither lock nor key)."")

    return locks, keys, h, w


def extract_lock_heights(lock_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each lock schematic.

    Args:
        lock_schematics: List of lock grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each lock
    """"""
    locks_heights = []
    for schematic in lock_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from top downward
            for row in range(grid_height):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        locks_heights.append(heights)
    return locks_heights


def extract_key_heights(key_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each key schematic.

    Args:
        key_schematics: List of key grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each key
    """"""
    keys_heights = []
    for schematic in key_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from bottom upward
            for row in range(grid_height - 1, -1, -1):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        keys_heights.append(heights)
    return keys_heights


def count_compatible_pairs(locks_heights: List[List[int]], keys_heights: List[List[int]], grid_height: int) -> int:
    """"""Count the number of unique lock/key pairs that fit together without pin overlap.

    Args:
        locks_heights: List of pin heights per column for each lock
        keys_heights: List of pin heights per column for each key
        grid_height: Total height of grid

    Returns:
        Integer count of compatible pairs
    """"""
    compatible_count = 0
    for l_idx, lock in enumerate(locks_heights):
        for k_idx, key in enumerate(keys_heights):
            # Check per column
            for col in range(len(lock)):
                if lock[col] + key[col] > grid_height:
                    # Overlap, no fit
                    break
            else:
                # No break => fits
                compatible_count += 1
    return compatible_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    locks, keys, h, w = parse_input(input_file)

    # Extract pin heights
    lock_heights = extract_lock_heights(locks, h, w)
    key_heights = extract_key_heights(keys, h, w)

    # Count compatible pairs
    result = count_compatible_pairs(lock_heights, key_heights, h)

    print(result)


if __name__ == '__main__':
    main()
"
12,single-model,o3-mini,False,14.043068647384644,threw-error
13,single-model,o3-mini,False,15.591195821762085,threw-error
14,single-model,o3-mini,False,19.35495352745056,threw-error
15,single-model,o3-mini,False,30.601914167404175,threw-error
16,single-model,o3-mini,False,15.0675528049469,threw-error
17,single-model,o3-mini,False,30.107502937316895,threw-error
18,single-model,o3-mini,False,38.19926047325134,threw-error
19,single-model,o3-mini,False,8.903229236602783,threw-error
20,single-model,o3-mini,False,42.69952368736267,threw-error
21,single-model,o3-mini,False,70.77034521102905,threw-error
22,single-model,o3-mini,True,26.617878913879395,"#!/usr/bin/env python3
""""""
Advent of Code Day 22: Monkey Market

In this puzzle, each buyer has an initial secret number. To produce the next secret number in their sequence, the following process is applied:

 1. Multiply the secret number by 64, then mix this result into the secret number via a bitwise XOR, and finally prune by taking modulo 16777216.
 2. Divide the secret number by 32 (using floor division), mix the result via XOR, and prune by modulo 16777216.
 3. Multiply the secret number by 2048, mix via XOR, and prune by modulo 16777216.

For each buyer, given an initial secret number from the input, we simulate generating 2000 secret numbers (each new secret number is produced by applying the above 3-step process) and then take the 2000th generated secret number for that buyer. The final answer is the sum of those 2000th secret numbers for all buyers.

Usage: python3 solution.py [input_file]
""""""

from typing import List
import sys

MOD_VALUE = 16777216  # 2^24
NUM_ITERATIONS = 2000


def parse_input(input_file: str) -> List[int]:
    """"""
    Parse the puzzle input file to obtain the list of initial secret numbers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers, each representing an initial secret number for a buyer.
    """"""
    secret_numbers = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    # Each line should be an integer
                    secret_numbers.append(int(line))
    except Exception as e:
        # Print error to stderr and re-raise
        sys.stderr.write(f""Error reading input file: {e}\n"")
        raise
    return secret_numbers


def next_secret(current: int) -> int:
    """"""
    Compute the next secret number given the current secret number using the specified process:

    1. Multiply by 64, mix via XOR, then prune modulo 16777216.
    2. Divide (floor division) by 32, mix via XOR, then prune modulo 16777216.
    3. Multiply by 2048, mix via XOR, then prune modulo 16777216.

    Args:
        current: The current secret number

    Returns:
        The next secret number.
    """"""
    # Step 1: Multiply by 64, mix and prune
    step1_value = (current * 64)
    current = (current ^ step1_value) % MOD_VALUE

    # Step 2: Divide by 32 (floor division), mix and prune
    step2_value = current // 32
    current = (current ^ step2_value) % MOD_VALUE

    # Step 3: Multiply by 2048, mix and prune
    step3_value = (current * 2048)
    current = (current ^ step3_value) % MOD_VALUE

    return current


def simulate_secret_number(initial: int, iterations: int = NUM_ITERATIONS) -> int:
    """"""
    Simulate the generation of secret numbers starting from the initial secret number
    for a specified number of iterations, and return the secret number obtained
    after the final iteration.

    Args:
        initial: The initial secret number for a buyer
        iterations: Number of secret numbers to generate

    Returns:
        The secret number after the specified number of iterations.
    """"""
    current = initial
    for _ in range(iterations):
        current = next_secret(current)
    return current


def solve_part_one(initial_numbers: List[int]) -> int:
    """"""
    For each buyer's initial secret number, simulate the generation of 2000 secret numbers
    and return the sum of the resulting 2000th secret numbers.

    Args:
        initial_numbers: List of initial secret numbers

    Returns:
        Sum of the 2000th secret numbers for each buyer
    """"""
    total_sum = 0
    for num in initial_numbers:
        final_secret = simulate_secret_number(num, NUM_ITERATIONS)
        total_sum += final_secret
    return total_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        sys.stderr.write(""Usage: python3 solution.py [input_file]\n"")
        sys.exit(1)

    input_file = sys.argv[1]

    # Parse input
    initial_numbers = parse_input(input_file)
    if not initial_numbers:
        sys.stderr.write(""Warning: Input file is empty or contains no valid secret numbers.\n"")
        print(0)
        return

    # Solve part one
    result = solve_part_one(initial_numbers)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(result)

    # Optionally, you can include self-test checks here for the provided examples:
    # Provided example input:
    # 1, 10, 100, 2024
    # Expected 2000th secret numbers in the example:
    # 1: 8685429
    # 10: 4700978
    # 100: 15273692
    # 2024: 8667524
    # Their sum: 37327623

    # Uncomment below block to run example tests
    """"""
    test_input = [1, 10, 100, 2024]
    expected_secrets = [8685429, 4700978, 15273692, 8667524]
    computed_secrets = [simulate_secret_number(x, NUM_ITERATIONS) for x in test_input]
    assert computed_secrets == expected_secrets, f""Test failed: {computed_secrets} != {expected_secrets}""
    test_sum = sum(expected_secrets)
    computed_sum = solve_part_one(test_input)
    assert computed_sum == test_sum, f""Test failed: {computed_sum} != {test_sum}""
    """"""


if __name__ == ""__main__"":
    main()
"
22,system,o3-mini,False,16.28007960319519,threw-error
22,system,o3-mini,True,16.280147790908813,"""""""
Advent of Code Day 25: Code Chronicle

This solution parses schematic grids of locks and keys, extracts pin heights per column for each schematic,
then counts how many unique lock/key pairs fit together without overlapping pins.

Locks have pins extending downward from the top row; keys have pins extending upward from the bottom row.
Two fit if for every column, sum of lock pin height and key pin height \u2264 total grid height.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> Tuple[List[List[str]], List[List[str]], int, int]:
    """"""Parse the input file into separate lock and key schematic grids.

    Args:
        input_file: Path to input file.

    Returns:
        A tuple with:
         - list of lock schematics (each schematic is list of strings)
         - list of key schematics (each schematic is list of strings)
         - grid height (int)
         - grid width (int)
    """"""
    with open(input_file, 'r') as f:
        lines = [line.rstrip('\n') for line in f]

    # Remove any trailing empty lines
    while lines and lines[-1] == '':
        lines.pop()

    # We need to split the input into schematic blocks separated by blank lines
    schematics: List[List[str]] = []
    current: List[str] = []

    for line in lines:
        if line.strip() == '':
            if current:
                schematics.append(current)
                current = []
        else:
            current.append(line)
    if current:
        schematics.append(current)

    if not schematics:
        raise ValueError(""No schematics found in input."")

    # Validate all schematics have the same grid size
    h = len(schematics[0])
    w = len(schematics[0][0]) if h > 0 else 0
    for schematic in schematics:
        if len(schematic) != h:
            raise ValueError(""Inconsistent schematic heights."")
        for row in schematic:
            if len(row) != w:
                raise ValueError(""Inconsistent schematic widths."")

    locks = []
    keys = []

    # Classify each schematic as lock or key:
    # Lock: top row fully or mostly '#' and bottom row mostly '.'
    # Key: top row mostly '.' and bottom row mostly '#'

    def is_lock(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Locks have top row mostly '#' and bottom row mostly '.'
        # We'll require top row to be all '#'
        if all(c == '#' for c in top) and all(c == '.' for c in bottom):
            return True
        return False

    def is_key(sch: List[str]) -> bool:
        top = sch[0]
        bottom = sch[-1]
        # Keys have top row mostly '.' and bottom row mostly '#'
        if all(c == '.' for c in top) and all(c == '#' for c in bottom):
            return True
        return False

    for schematic in schematics:
        if is_lock(schematic):
            locks.append(schematic)
        elif is_key(schematic):
            keys.append(schematic)
        else:
            raise ValueError(""Unrecognized schematic type (neither lock nor key)."")

    return locks, keys, h, w


def extract_lock_heights(lock_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each lock schematic.

    Args:
        lock_schematics: List of lock grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each lock
    """"""
    locks_heights = []
    for schematic in lock_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from top downward
            for row in range(grid_height):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        locks_heights.append(heights)
    return locks_heights


def extract_key_heights(key_schematics: List[List[str]], grid_height: int, grid_width: int) -> List[List[int]]:
    """"""Extract pin heights for each key schematic.

    Args:
        key_schematics: List of key grids (each a list of strings)
        grid_height: Number of rows
        grid_width: Number of columns

    Returns:
        List of lists of pin heights per column for each key
    """"""
    keys_heights = []
    for schematic in key_schematics:
        heights = []
        for col in range(grid_width):
            count = 0
            # Count consecutive '#' from bottom upward
            for row in range(grid_height - 1, -1, -1):
                if schematic[row][col] == '#':
                    count += 1
                else:
                    break
            heights.append(count)
        keys_heights.append(heights)
    return keys_heights


def count_compatible_pairs(locks_heights: List[List[int]], keys_heights: List[List[int]], grid_height: int) -> int:
    """"""Count the number of unique lock/key pairs that fit together without pin overlap.

    Args:
        locks_heights: List of pin heights per column for each lock
        keys_heights: List of pin heights per column for each key
        grid_height: Total height of grid

    Returns:
        Integer count of compatible pairs
    """"""
    compatible_count = 0
    for l_idx, lock in enumerate(locks_heights):
        for k_idx, key in enumerate(keys_heights):
            # Check per column
            for col in range(len(lock)):
                if lock[col] + key[col] > grid_height:
                    # Overlap, no fit
                    break
            else:
                # No break => fits
                compatible_count += 1
    return compatible_count


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        sys.exit(1)

    input_file = sys.argv[1]

    locks, keys, h, w = parse_input(input_file)

    # Extract pin heights
    lock_heights = extract_lock_heights(locks, h, w)
    key_heights = extract_key_heights(keys, h, w)

    # Count compatible pairs
    result = count_compatible_pairs(lock_heights, key_heights, h)

    print(result)


if __name__ == '__main__':
    main()
"
23,single-model,o3-mini,False,9.78546404838562,threw-error
24,single-model,o3-mini,False,22.46822476387024,threw-error
25,single-model,o3-mini,False,36.147377252578735,threw-error
