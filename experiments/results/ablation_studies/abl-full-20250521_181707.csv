success,day,name,code,debug_attempts,debug_suggestions,n_retreived_puzzles,keywords,concepts,time
True,1,baseline,"""""""
Advent of Code 2023 Day 1: Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers (list1, list2).
    """"""
    list1: List[int] = []
    list2: List[int] = []
    with open(input_file, 'r') as f:
        lines = f.readlines()
        for line in lines:
            num1, num2 = map(int, line.split())
            list1.append(num1)
            list2.append(num2)
    return list1, list2


def solve_part_one(list1: List[int], list2: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        list1: The first list of integers.
        list2: The second list of integers.

    Returns:
        The sum of the absolute differences between the paired numbers after sorting.
    """"""
    sorted_list1 = sorted(list1)
    sorted_list2 = sorted(list2)
    total_distance = 0
    for i in range(len(sorted_list1)):
        total_distance += abs(sorted_list1[i] - sorted_list2[i])
    return total_distance


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    list1, list2 = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(list1, list2)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",3,"['The code in `parse_input` reads only one number from each line instead of two as given in the test input. `num1, num2 = map(int, lines[i].split())` only appends `num1` to the lists, which is incorrect. The code needs to be corrected to append both numbers from each line to appropriate lists. In the first loop, list1.append(num2) needs to be added, and in the second loop, list2.append(num2) needs to be added.']",3,"list processing,sorting,absolute difference,summation","sorting algorithms,list manipulation,mathematical operations",75.67273616790771
True,2,baseline,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys


def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of reports, where each report is a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of reports, where each report is a list of integers.
    """"""
    reports: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            try:
                levels = [int(level) for level in line.strip().split()]
                reports.append(levels)
            except ValueError:
                print(f""Warning: Skipping line due to invalid input: {line.strip()}"", file=sys.stderr)
            except Exception as e:
                print(f""An unexpected error occurred: {e}"", file=sys.stderr)
                sys.exit(1) # Exit if there is a critical error during parsing.

    return reports


def is_increasing(report: List[int]) -> bool:
    """"""Check if a given list of integers is strictly increasing with differences between 1 and 3.

    Args:
        report: A list of levels (integers) representing a report.

    Returns:
        True if the sequence is strictly increasing with differences between 1 and 3, False otherwise.
    """"""
    if len(report) < 2:
        return True  # A report with fewer than two levels is considered safe.

    for i in range(len(report) - 1):
        if report[i] >= report[i + 1] or not 1 <= abs(report[i + 1] - report[i]) <= 3:
            return False
    return True


def is_decreasing(report: List[int]) -> bool:
    """"""Check if a given list of integers is strictly decreasing with differences between 1 and 3.

    Args:
        report: A list of levels (integers) representing a report.

    Returns:
        True if the sequence is strictly decreasing with differences between 1 and 3, False otherwise.
    """"""
    if len(report) < 2:
        return True  # A report with fewer than two levels is considered safe.

    for i in range(len(report) - 1):
        if report[i] <= report[i + 1] or not 1 <= abs(report[i + 1] - report[i]) <= 3:
            return False
    return True


def is_safe(report: List[int]) -> bool:
    """"""Determine if a report is safe, by checking if it is either strictly increasing or strictly decreasing.

    Args:
        report: A list of levels representing a report.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    return is_increasing(report) or is_decreasing(report)


def solve_part_one(reports: List[List[int]]) -> int:
    """"""Count the number of safe reports in the given list of reports.

    Args:
        reports: A list of reports.

    Returns:
        The total number of safe reports.
    """"""
    safe_reports_count = 0
    for report in reports:
        if is_safe(report):
            safe_reports_count += 1
    return safe_reports_count


def main():
    """"""Main function to solve the Advent of Code problem.

    Parses the input, solves part one, and prints the solution.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    reports = parse_input(input_file)
    part_one_solution = solve_part_one(reports)

    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"data analysis,report validation,numerical sequence","sequence analysis,conditional logic,monotonicity check",58.49019193649292
True,3,baseline,"import re
import sys


def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a string.

    Args:
        input_file: Path to the input file

    Returns:
        The input string.
    """"""
    try:
        with open(input_file, 'r') as f:
            return f.read().strip()
    except FileNotFoundError:
        print(f""Error: File not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading file: {e}"", file=sys.stderr)
        sys.exit(1)


def solve_part_one(corrupted_memory: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        corrupted_memory: The corrupted memory string.

    Returns:
        Solution for part one (the sum of valid multiplications).
    """"""
    total_sum = 0
    pattern = r""mul\((\d{1,3}),(\d{1,3})\)""
    matches = re.finditer(pattern, corrupted_memory)

    for match in matches:
        try:
            x_str = match.group(1)
            y_str = match.group(2)
            x = int(x_str)
            y = int(y_str)

            if 1 <= x <= 999 and 1 <= y <= 999:
                total_sum += x * y
            else:
                pass
        except ValueError:
            pass  # Ignore if conversion to int fails
        except IndexError:
            pass  # Ignore if group doesn't exist

    return total_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    corrupted_memory = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(corrupted_memory)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",1,[],1,"string parsing,pattern matching,arithmetic,data extraction","regular expressions,string manipulation",47.72589826583862
True,4,baseline,"""""""
Advent of Code 2023 Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list representing the grid of characters.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid


def search_direction(grid: List[List[str]], row: int, col: int, direction: Tuple[int, int], word: str) -> bool:
    """"""Search for the remaining characters of 'XMAS' in the specified direction.

    Args:
        grid: The grid of characters.
        row: Starting row index.
        col: Starting column index.
        direction: A tuple representing the row and column increment for each step.
        word: The target word (""XMAS"").

    Returns:
        True if the remaining characters of 'XMAS' are found in the specified direction, False otherwise.
    """"""
    delta_row, delta_col = direction
    for i in range(1, len(word)):
        new_row = row + i * delta_row
        new_col = col + i * delta_col

        if not (0 <= new_row < len(grid) and 0 <= new_col < len(grid[0])):
            return False  # Out of bounds

        if grid[new_row][new_col] != word[i]:
            return False  # Character mismatch

    return True  # Found ""MAS"" in the specified direction

def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: The 2D list representing the grid of characters.

    Returns:
        The total number of occurrences of ""XMAS"" in the grid.
    """"""
    word = ""XMAS""
    count = 0
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    if rows == 0 or cols == 0:
        return 0  # Empty grid

    directions = [
        (0, 1),  # Right
        (0, -1), # Left
        (1, 0),  # Down
        (-1, 0), # Up
        (1, 1),  # Down-Right
        (-1, -1),# Up-Left
        (1, -1), # Down-Left
        (-1, 1)  # Up-Right
    ]

    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 'X':
                for direction in directions:
                    if search_direction(grid, row, col, direction, word):
                        count += 1

    return count


def main():
    """"""Main function to execute the solution.

    Parses the input, solves the puzzle, and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)

    part_one_solution = solve_part_one(grid)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"string search,grid search,pattern matching,word search","string manipulation,grid traversal,pattern recognition",63.169833183288574
False,5,baseline,,6,"['The primary issue was in the `validate_update_sequence` function. The logic incorrectly checked for rule violations. Specifically, it checked if `page2 in rules and page1 in rules[page2]:` in reverse order, but the intended logic is to check if `page2` *should* be before `page1` based on the rules. Also the initial check was incorrect in that it should have returned False when page1 should be before page2 due to the ordering constraint. The condition was corrected to `if page1 in rules and page2 in rules[page1]: return False`. The reverse order rule check was also removed since that should not affect the validation.', ""The primary issue was within the `validate_update_sequence` function's logic. The original code incorrectly invalidated sequences. The logic has been corrected to accurately validate the sequence based on the provided rules. The median calculation was changed to integer division `//` to return an integer.\n\nSpecifically:\n1.  The validation logic in `validate_update_sequence` function was wrong. The error in logic was identified and corrected. Now it accurately validates the sequences.\n2. The return type of median was changed to int. Make sure to return sum of integers and not floats.\n3. The problem description requires the sum of integers. The validation logic and median calculation has been updated to return the correct answer. Make sure to read the problem description again.""]",3,"ordering,validation,median,rules,sequence,sorting","graph traversal (implicitly),topological sort (conceptually),rule-based validation",155.42191743850708
False,6,baseline,,6,"[""The original implementation got stuck in cycles and didn't fully explore the grid, leading to a lower than expected number of visited positions. To address this I've added a check for repeated states within the simulation loop. The `visited_states` set keeps track of the guard's row, column, and direction at each step. Before each iteration, the current state is checked against `visited_states`. If the state has been visited before, the loop breaks, preventing infinite loops. This ensures that the guard explores as much of the grid as possible before terminating. It is essential to track the direction in addition to row/col position as the same row/col can be visited multiple times if the guard is facing different directions."", ""The primary issue is that the guard gets stuck in a loop. To fix this:\n\n1.  Track Visited States: The `visited_states` set is used to store the guard's row, column, and direction at each step. Before moving the guard, check if the current state (row, col, direction) is already in `visited_states`. If it is, break the loop to prevent an infinite loop.\n2. Ensure correct bounds checking. The positions added to visited positions need to be within the bounds of the grid.\n""]",3,"grid simulation,pathfinding,state machine,guard patrol","simulation,coordinate manipulation,conditional logic",212.95014595985413
True,7,baseline,"""""""
Advent of Code 2023 Day 7: Bridge Repair
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of tuples.

    Each tuple contains the target value and a list of numbers for an equation.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple is (target_value, list_of_numbers).
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            try:
                target, numbers_str = line.strip().split(': ')
                target = int(target)
                numbers = [int(num) for num in numbers_str.split()]
                equations.append((target, numbers))
            except ValueError:
                print(f""Skipping invalid line: {line.strip()}"", file=sys.stderr)
                continue
    return equations

def generate_operator_combinations(num_count: int) -> List[List[str]]:
    """"""Generate all possible combinations of '+' and '*' operators.

    Args:
        num_count: The number of numbers in the equation.

    Returns:
        A list of lists, where each inner list is a combination of operators.
    """"""
    if num_count <= 1:
        return []

    operators = ['+', '*']
    combinations = []

    def generate(index: int, current_combination: List[str]):
        if index == num_count - 1:
            combinations.append(current_combination.copy())
            return

        for operator in operators:
            current_combination.append(operator)
            generate(index + 1, current_combination)
            current_combination.pop()  # Backtrack

    generate(0, [])
    return combinations

def evaluate_expression(numbers: List[int], operators: List[str]) -> int:
    """"""Evaluate an expression from left to right without operator precedence.

    Args:
        numbers: A list of numbers.
        operators: A list of operators.

    Returns:
        The result of the evaluation.
    """"""
    result = numbers[0]
    for i in range(len(operators)):
        operator = operators[i]
        next_number = numbers[i + 1]
        if operator == '+':
            result += next_number
        elif operator == '*':
            result *= next_number
        else:
            raise ValueError(f""Invalid operator: {operator}"")
    return result

def solve_part_one(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        equations: A list of tuples, where each tuple is (target_value, list_of_numbers).

    Returns:
        The sum of the target values of the valid equations.
    """"""
    total_sum = 0
    for target, numbers in equations:
        if not numbers:
            continue # Skip equations with no numbers.

        if len(numbers) == 1:
            if target == numbers[0]:
                total_sum += target
            continue

        operator_combinations = generate_operator_combinations(len(numbers))

        for operators in operator_combinations:
            result = evaluate_expression(numbers, operators)
            if result == target:
                total_sum += target
                break  # Move to the next equation once a valid combination is found

    return total_sum

def main():
    """"""Main function to run the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    equations = parse_input(input_file)
    part_one_solution = solve_part_one(equations)

    print(part_one_solution)

    # Example test cases
    test_input = ""190: 10 19\n3267: 81 40 27\n83: 17 5\n156: 15 6\n7290: 6 8 6 15\n161011: 16 10 13\n192: 17 8 14\n21037: 9 7 18 13\n292: 11 6 16 20""
    test_equations = parse_input(""test.txt"") # Create a test.txt file with the content of test_input

if __name__ == ""__main__"":
    main()
",0,[],3,"arithmetic,expression evaluation,combinatorial search","recursion,backtracking",73.3688051700592
True,8,baseline,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[List[str]], Dict[str, List[Tuple[int, int]]]]:
    """"""Parse the puzzle input from file into grid and antenna locations.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - grid: A list of lists of characters representing the grid.
        - antennas: A dictionary mapping frequencies to lists of (row, col) tuples.
    """"""
    grid: List[List[str]] = []
    antennas: Dict[str, List[Tuple[int, int]]] = defaultdict(list)
    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            row = list(line.strip())
            grid.append(row)
            for c, char in enumerate(row):
                if char != '.':
                    antennas[char].append((r, c))
    return grid, antennas


def solve_part_one(grid: List[List[str]], antennas: Dict[str, List[Tuple[int, int]]]) -> int:
    """"""Solve part one of the puzzle: count unique antinode locations.

    Args:
        grid: The grid representing antenna locations.
        antennas: A dictionary mapping frequencies to antenna locations.

    Returns:
        The number of unique antinode locations.
    """"""
    antinode_locations: Set[Tuple[int, int]] = set()
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    for frequency, locations in antennas.items():
        for i in range(len(locations)):
            for j in range(i + 1, len(locations)):
                antenna1_row, antenna1_col = locations[i]
                antenna2_row, antenna2_col = locations[j]

                # Calculate two possible antinode locations
                antinode1_row = 2 * antenna1_row - antenna2_row
                antinode1_col = 2 * antenna1_col - antenna2_col
                antinode2_row = 2 * antenna2_row - antenna1_row
                antinode2_col = 2 * antenna2_col - antenna1_col

                # Check if the antinode locations are within the grid bounds
                if 0 <= antinode1_row < rows and 0 <= antinode1_col < cols:
                    antinode_locations.add((antinode1_row, antinode1_col))
                if 0 <= antinode2_row < rows and 0 <= antinode2_col < cols:
                    antinode_locations.add((antinode2_row, antinode2_col))

    return len(antinode_locations)


def main():
    """"""Main function to parse input, solve the problem, and print the result.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid, antennas = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(grid, antennas)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Test with examples (if available)
    # [Example testing code]

if __name__ == ""__main__"":
    main()
",0,[],3,"grid,geometry,collinearity,distance,antenna,antinode","geometry,distance calculation,coordinate geometry,line equation",116.28118753433228
False,9,baseline,,6,[],1,"disk compaction,checksum,string manipulation,file system","parsing,simulation,arithmetic",191.254634141922
True,10,baseline,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
from collections import deque

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a 2D list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of integers representing the elevation grid.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            row = [int(c) for c in line.strip()]
            grid.append(row)
    return grid

def identify_trailheads(grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Identify all trailheads (locations with elevation 0) in the grid.

    Args:
        grid: A 2D list of integers representing the elevation grid.

    Returns:
        A list of tuples (row, col) representing the coordinates of all trailheads.
    """"""
    trailheads = []
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if grid[row][col] == 0:
                trailheads.append((row, col))
    return trailheads

def calculate_trailhead_score_bfs(grid: List[List[int]], start_row: int, start_col: int) -> int:
    """"""Calculate the score of a single trailhead using Breadth-First Search (BFS).

    Args:
        grid: A 2D list of integers representing the elevation grid.
        start_row: The row coordinate of the trailhead.
        start_col: The column coordinate of the trailhead.

    Returns:
        The number of reachable locations with elevation 9 from the trailhead.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    visited[start_row][start_col] = True
    reachable_9s = 0
    queue = deque([(start_row, start_col)])

    while queue:
        row, col = queue.popleft()

        if grid[row][col] == 9:
            reachable_9s += 1

        # Explore neighbors (up, down, left, right)
        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]

        for new_row, new_col in neighbors:
            # Check boundaries and elevation increase
            if 0 <= new_row < rows and 0 <= new_col < cols and not visited[new_row][new_col] and grid[new_row][new_col] == grid[row][col] + 1:
                visited[new_row][new_col] = True
                queue.append((new_row, new_col))

    return reachable_9s


def solve_part_one(grid: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: A 2D list of integers representing the elevation grid.

    Returns:
        The sum of the scores of all trailheads in the grid.
    """"""
    trailheads = identify_trailheads(grid)
    total_score = 0
    for row, col in trailheads:
        total_score += calculate_trailhead_score_bfs(grid, row, col)
    return total_score


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)

    part_one_solution = solve_part_one(grid)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],1,"grid traversal,pathfinding,elevation map,reachability","breadth-first search,depth-first search,graph traversal,recursion",67.29501056671143
True,11,baseline,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re
# Import other necessary libraries

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial arrangement of stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        stones = [int(s) for s in line.split()]
        return stones


def solve_part_one(initial_stones: List[int]) -> int:
    """"""Solve part one of the puzzle: Determine the number of stones after 25 iterations.

    Args:
        initial_stones: A list of integers representing the initial stone arrangement.

    Returns:
        The number of stones after 25 iterations.
    """"""
    current_stones = initial_stones

    for _ in range(25):
        next_stones: List[int] = []
        for stone in current_stones:
            if stone == 0:
                next_stones.append(1)
            else:
                stone_str = str(stone)
                if len(stone_str) % 2 == 0:
                    mid = len(stone_str) // 2
                    left_half_str = stone_str[:mid]
                    right_half_str = stone_str[mid:]
                    try:
                        left_half = int(left_half_str)
                        right_half = int(right_half_str)
                        next_stones.append(left_half)
                        next_stones.append(right_half)
                    except ValueError:
                        print(f""ValueError converting halves: {left_half_str}, {right_half_str}"", file=sys.stderr)

                else:
                    next_stones.append(stone * 2024)

        current_stones = next_stones

    return len(current_stones)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_stones = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_stones)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Test with examples (if available)
    # example_stones = [0, 1, 10, 99, 999]
    # expected_stones = 7
    # result = solve_part_one(example_stones)
    # print(f'{example_stones=}')
    # print(f'{result=}')
    # assert result == expected_stones


if __name__ == ""__main__"":
    main()
",0,[],2,"simulation,number transformation,sequence manipulation,integer arithmetic","iteration,conditional logic,string manipulation (digit counting, splitting),list processing",67.46266388893127
True,12,baseline,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D grid of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    grid = []
    try:
        with open(input_file, 'r') as f:
            for line in f:
                grid.append(list(line.strip()))
    except FileNotFoundError:
        print(f""Error: Input file not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)

    # Basic check for rectangular grid (more robust checks could be added)
    if not grid:
        print(""Warning: Empty grid"", file=sys.stderr)
        return grid
    row_len = len(grid[0])
    for row in grid:
        if len(row) != row_len:
            print(""Error: Non-rectangular grid"", file=sys.stderr)
            sys.exit(1)
    return grid


def dfs(grid: List[List[str]], row: int, col: int, plant_type: str, visited: Set[Tuple[int, int]], region: List[Tuple[int, int]]) -> None:
    """"""Depth-first search to identify a connected region of the same plant type.

    Args:
        grid: The 2D grid.
        row: Current row coordinate.
        col: Current column coordinate.
        plant_type: The plant type to search for.
        visited: Set of visited cells.
        region: List to store the coordinates of the region.
    """"""
    rows = len(grid)
    cols = len(grid[0])

    if row < 0 or row >= rows or col < 0 or col >= cols or (row, col) in visited or grid[row][col] != plant_type:
        return

    visited.add((row, col))
    region.append((row, col))

    dfs(grid, row + 1, col, plant_type, visited, region)  # Down
    dfs(grid, row - 1, col, plant_type, visited, region)  # Up
    dfs(grid, row, col + 1, plant_type, visited, region)  # Right
    dfs(grid, row, col - 1, plant_type, visited, region)  # Left


def calculate_perimeter(grid: List[List[str]], region: List[Tuple[int, int]]) -> int:
    """"""Calculate the perimeter of a region.

    Args:
        grid: The 2D grid.
        region: List of cell coordinates in the region.

    Returns:
        The perimeter of the region.
    """"""
    perimeter = 0
    rows = len(grid)
    cols = len(grid[0])

    for row, col in region:
        # Check neighbors
        neighbors = [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]
        for r, c in neighbors:
            if r < 0 or r >= rows or c < 0 or c >= cols or (r, c) not in region:
                perimeter += 1

    return perimeter

def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: Processed input data

    Returns:
        Solution for part one
    """"""
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0
    visited: Set[Tuple[int, int]] = set()
    total_cost = 0
    regions_data = [] # List of tuples (plant_type, area, perimeter) for debugging/inspection.

    for row in range(rows):
        for col in range(cols):
            if (row, col) not in visited:
                plant_type = grid[row][col]
                region: List[Tuple[int, int]] = []
                dfs(grid, row, col, plant_type, visited, region)

                area = len(region)
                perimeter = calculate_perimeter(grid, region)
                cost = area * perimeter
                total_cost += cost

                regions_data.append((plant_type, area, perimeter)) # Store data for debugging

    return total_cost


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"grid processing,region identification,area calculation,perimeter calculation,connected components,graph traversal","depth-first search,breadth-first search,flood fill,connected components analysis",68.44300484657288
True,13,baseline,"""""""
Advent of Code 2023 Day 13: Claw Contraption
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re

def parse_input(input_file: str) -> List[Dict[str, int]]:
    """"""Parse the puzzle input from file into a list of claw machine configurations.

    Args:
        input_file: Path to the input file

    Returns:
        A list of dictionaries, where each dictionary represents a claw machine
        and contains the A and B button movements in X and Y axes and the prize coordinates.
    """"""
    claw_machines = []
    with open(input_file, 'r') as f:
        machine_data = []
        for line in f:
            line = line.strip()
            if line:
                machine_data.append(line)
            if len(machine_data) == 3:
                machine = {}
                # Parse Button A data
                match = re.match(r'Button A: X\+([-\d]+), Y\+([-\d]+)', machine_data[0])
                if match:
                    machine['A_x'] = int(match.group(1))
                    machine['A_y'] = int(match.group(2))

                # Parse Button B data
                match = re.match(r'Button B: X\+([-\d]+), Y\+([-\d]+)', machine_data[1])
                if match:
                    machine['B_x'] = int(match.group(1))
                    machine['B_y'] = int(match.group(2))

                # Parse Prize data
                match = re.match(r'Prize: X=([-\d]+), Y=([-\d]+)', machine_data[2])
                if match:
                    machine['prize_x'] = int(match.group(1))
                    machine['prize_y'] = int(match.group(2))

                claw_machines.append(machine)
                machine_data = []

    return claw_machines


def solve_claw_machine(machine: Dict[str, int]) -> int:
    """"""Determine the minimum token cost to win the prize for a given claw machine.

    Args:
        machine: A dictionary representing a claw machine.

    Returns:
        The minimum token cost to win the prize for that machine. Returns float('inf') if impossible.
    """"""
    min_cost = float('inf')
    for a_presses in range(101):
        for b_presses in range(101):
            claw_x = machine['A_x'] * a_presses + machine['B_x'] * b_presses
            claw_y = machine['A_y'] * a_presses + machine['B_y'] * b_presses

            if claw_x == machine['prize_x'] and claw_y == machine['prize_y']:
                cost = 3 * a_presses + 1 * b_presses
                min_cost = min(min_cost, cost)

    return min_cost


def solve_part_one(claw_machines: List[Dict[str, int]]) -> Tuple[int, int]:
    """"""Solve part one of the puzzle.

    Args:
        claw_machines: A list of claw machine configurations.

    Returns:
        A tuple containing the maximum number of prizes won and the minimum total token cost.
    """"""
    winning_costs = []
    for machine in claw_machines:
        winning_costs.append(solve_claw_machine(machine))

    num_prizes_won = sum(1 for cost in winning_costs if cost != float('inf'))
    min_total_token_cost = sum(cost for cost in winning_costs if cost != float('inf'))

    return num_prizes_won, min_total_token_cost


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    claw_machines = parse_input(input_file)

    num_prizes, min_cost = solve_part_one(claw_machines)

    print(min_cost)


if __name__ == ""__main__"":
    main()
",0,[],2,"optimization,linear equations,integer solutions,claw machine,token cost,maximize prizes","Diophantine equations,brute force,linear programming,system of equations",69.57545900344849
False,14,baseline,,6,"['The error lies in the `calculate_quadrant_counts` function. The condition `x > center_x` should be `x >= center_x` and `y > center_y` should be `y >= center_y` in order to appropriately count robots that appear on the middle lines into quadrants 2, 3, and 4. This is a logical error that can be corrected by changing the comparison operator in the if/elif statements.', ""The error in the code lies in the `calculate_quadrant_counts` function. The conditions `x < center_x`, `x >= center_x`, `y < center_y`, and `y >= center_y` determine which quadrant a robot belongs to. The original implementation had a floating point division for `center_x` and `center_y`, and thus comparison between int `x` and float `center_x` may fail unexpectedly.\n\nHere's how to fix the problem:\n1. Use integer division `//` to calculate `center_x` and `center_y`.\n\nBy making this change, you ensure that the robot positions are correctly assigned to their respective quadrants, leading to the correct safety factor calculation.""]",2,"grid simulation,robot movement,wraparound,quadrant calculation,safety factor","modular arithmetic,coordinate manipulation,simulation",162.02229762077332
False,15,baseline,,6,"[""The robot's position `r` and `c` are updated *only* when a box is pushed. If the box cannot be pushed due to being blocked, the robot's would-be location is never saved. Update the robot position at the end of each successful move, regardless of whether it pushes a box or just moves to an empty cell. Also, update the grid with the new values, since the grid is never updated. The robot updates its position *outside* the box-pushing if statement, but still inside the loop, so it will update when pushing an empty spot. This leads to a wrong final robot location and subsequently wrong GPS sum calculation."", ""The error was in the `simulate_robot_movement` function. When pushing a box, the code updates the grid after updating the robot position. To fix this, ensure that the grid is updated to reflect the robot's previous and current positions before the robot's position variables `r` and `c` are updated. The correct order is to first update the grid with the new box and empty spaces, then update the robot's position, and finally, update the `robot_position` tuple.""]",3,"simulation,robotics,grid,box pushing,GPS coordinates","state transition,coordinate manipulation",179.4898636341095
False,16,baseline,,6,"[""The code incorrectly parses the input maze due to replacing '\\n' before splitting the lines, leading to the maze being processed incorrectly. Remove `replace('\\n', '')` from the parse_input function. After this change, the code should correctly read the maze and run the BFS algorithm as intended."", 'The original code used a deque for BFS, which explores nodes in a first-in, first-out manner. To improve the search, the code was modified to use A* search with a priority queue implemented using `heapq`. This prioritizes nodes with lower cost, potentially leading to a faster and more accurate solution. The queue now stores tuples of `(cost, row, col, direction)`, and `heapq.heappop` is used to retrieve the node with the lowest cost. The `heapq.heappush` inserts elements into the priority queue maintaining heap invariants.']",3,"maze,pathfinding,grid,shortest path,reindeer,search","graph traversal,breadth-first search,A*,state space search",181.1388783454895
True,17,baseline,"""""""
Advent of Code 2023 Day 17: Chronospatial Computer
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from file into registers and program.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - registers: A dictionary containing the initial values of registers A, B, and C.
            - program: A list of integers representing the program instructions.
    """"""
    registers: Dict[str, int] = {}
    program: List[int] = []

    with open(input_file, 'r') as f:
        lines = f.readlines()
        for line in lines:
            line = line.strip()
            if line.startswith(""Register""): # Registers section
                parts = line.split(':')
                register_name = parts[0].split()[1] # Extract A, B, or C
                register_value = int(parts[1].strip())
                registers[register_name] = register_value

            elif line.startswith(""Program""): #Program section
                program_str = line.split("":"")[1].strip()
                program = [int(x) for x in program_str.split("","")]

    return registers, program


def solve_part_one(registers: Dict[str, int], program: List[int]) -> str:
    """"""Solve part one of the puzzle.

    Args:
        registers: A dictionary containing the initial values of registers A, B, and C.
        program: A list of integers representing the program instructions.

    Returns:
        A comma-separated string of values generated by the `out` instruction.
    """"""
    instruction_pointer = 0
    output: List[int] = []

    while instruction_pointer < len(program):
        opcode = program[instruction_pointer]

        if instruction_pointer + 1 >= len(program):
            break # Halt if trying to read operand beyond the end

        operand = program[instruction_pointer + 1]

        if opcode == 0:  # adv
            divisor = 2 ** get_combo_operand_value(registers, operand)
            registers['A'] = registers['A'] // divisor  # Integer truncation
        elif opcode == 1:  # bxl
            registers['B'] = registers['B'] ^ operand
        elif opcode == 2:  # bst
            registers['B'] = get_combo_operand_value(registers, operand) % 8
        elif opcode == 3:  # jnz
            if registers['A'] != 0:
                instruction_pointer = operand
                continue # Skip incrementing the instruction pointer
        elif opcode == 4:  # bxc
            registers['B'] = registers['B'] ^ registers['C']
        elif opcode == 5:  # out
            output_value = get_combo_operand_value(registers, operand) % 8
            output.append(output_value)
        elif opcode == 6:  # bdv
            divisor = 2 ** get_combo_operand_value(registers, operand)
            registers['B'] = registers['A'] // divisor  # Integer truncation
        elif opcode == 7:  # cdv
            divisor = 2 ** get_combo_operand_value(registers, operand)
            registers['C'] = registers['A'] // divisor  # Integer truncation

        instruction_pointer += 2

    return "","".join(map(str, output))


def get_combo_operand_value(registers: Dict[str, int], operand: int) -> int:
    """"""Helper function to get the value of a combo operand.
    """"""
    if 0 <= operand <= 3:
        return operand
    elif operand == 4:
        return registers['A']
    elif operand == 5:
        return registers['B']
    elif operand == 6:
        return registers['C']
    else:
        return 0  # Should not happen, but handling it for safety


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    registers, program = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(registers, program)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",3,[],1,"computer simulation,instruction set,registers,program execution,bitwise operations,arithmetic operations,modulo operation","Finite State Machine,Interpreter,Bitwise Operations,Modulo Arithmetic,Conditional Jumps",132.57959938049316
True,18,baseline,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import deque

def parse_input(input_file: str) -> Tuple[Set[Tuple[int, int]]]:
    """"""Parse the puzzle input from file into corrupted cells.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing the set of corrupted cells.
    """"""
    corrupted_cells: Set[Tuple[int, int]] = set()
    with open(input_file, 'r') as f:
        for i, line in enumerate(f):
            if i >= 1024:
                break
            line = line.strip()
            if not line:
                continue # Skip empty lines
            try:
                x, y = map(int, line.split(','))
                corrupted_cells.add((x, y))
            except ValueError:
                print(f""Warning: Invalid input line: {line}"", file=sys.stderr)
                continue

    return corrupted_cells

def solve_part_one(corrupted_cells: Set[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        corrupted_cells: A set of corrupted cell coordinates.

    Returns:
        The minimum number of steps to reach the exit, or -1 if unreachable.
    """"""
    queue: deque[Tuple[int, int, int]] = deque([(0, 0, 0)])  # (x, y, distance)
    visited: Set[Tuple[int, int]] = set([(0, 0)])

    while queue:
        x, y, distance = queue.popleft()

        if (x, y) == (70, 70):
            return distance

        # Possible moves: right, left, down, up
        moves = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]

        for next_x, next_y in moves:
            # Check boundaries, corrupted cells, and visited cells
            if (0 <= next_x <= 70 and 0 <= next_y <= 70 and
                    (next_x, next_y) not in corrupted_cells and
                    (next_x, next_y) not in visited):
                visited.add((next_x, next_y))
                queue.append((next_x, next_y, distance + 1))

    return -1  # No path found

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    corrupted_cells = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(corrupted_cells)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],1,"shortest path,grid traversal,pathfinding,memory corruption,coordinate grid","breadth-first search,A* search,graph traversal,simulation",64.12826299667358
True,19,baseline,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and designs.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - patterns: A list of towel patterns (strings).
        - designs: A list of desired designs (strings).
    """"""
    with open(input_file, 'r') as f:
        data = f.read().strip()

    parts = data.split('\n\n')
    patterns = [p.strip() for p in parts[0].split(',')]
    designs = [d.strip() for d in parts[1].split('\n') if d.strip()]

    return patterns, designs


def is_design_possible(design: str, patterns: List[str]) -> bool:
    """"""Determines whether a given design can be constructed from the given patterns using Dynamic Programming.

    Args:
        design: The design string to check.
        patterns: The list of available towel patterns.

    Returns:
        True if the design can be constructed, False otherwise.
    """"""
    n = len(design)
    dp = [False] * (n + 1)
    dp[0] = True  # Empty string can always be constructed

    for i in range(1, n + 1):
        for pattern in patterns:
            if i >= len(pattern) and design[i - len(pattern):i] == pattern and dp[i - len(pattern)]:
                dp[i] = True
                break  # If we found one pattern, no need to check others for this i

    return dp[n]


def solve_part_one(patterns: List[str], designs: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        patterns: List of towel patterns.
        designs: List of designs.

    Returns:
        The number of designs that are possible to construct.
    """"""
    count = 0
    for design in designs:
        if is_design_possible(design, patterns):
            count += 1

    return count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    patterns, designs = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(patterns, designs)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"string manipulation,pattern matching,string decomposition","string matching,decomposition,recursion (possible),dynamic programming (possible)",68.05705547332764
False,20,baseline,,6,[],1,"grid traversal,pathfinding,optimization,cheating,shortest path","breadth-first search,A* search,dynamic programming",226.62929677963257
False,21,baseline,,6,"[""The error is in the `calculate_complexity_of_code` function. The regular expression incorrectly removes all '0' characters *before* removing 'A' characters, leading to incorrect complexity calculations. Furthermore, the removal of leading zeros is not necessary and problematic in some edge cases. To fix this, the order of the substitutions should be swapped, and the leading zero removal should be removed. The code should first remove the 'A' characters, and then '0' characters and calculate the numeric value."", ""The `bfs_shortest_path` function was incorrectly appending 'A' to the path when the target digit was found. The 'A' press should be done after the path *to* the digit is found. I have updated `bfs_shortest_path` to return the path to the digit *without* the 'A'. I have then added the 'A' to the path concatenation within `calculate_shortest_path_for_code`.""]",3,"pathfinding,shortest path,keypad,robot,string manipulation","graph traversal,breadth-first search,dynamic programming (potentially for optimization),string generation",195.78520822525024
True,22,baseline,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers, where each integer is the initial secret number of a buyer.
    """"""
    initial_secrets = []
    with open(input_file, 'r') as f:
        for line in f:
            try:
                initial_secrets.append(int(line.strip()))
            except ValueError:
                print(f""Error: Could not convert line to integer: {line.strip()}"", file=sys.stderr)
                return []  # Or raise an exception, depending on the desired error handling
    return initial_secrets


def mix(secret: int, value: int) -> int:
    """"""Mixes a value into the secret number using bitwise XOR.

    Args:
        secret: The current secret number.
        value: The value to mix in.

    Returns:
        The updated secret number after the XOR operation.
    """"""
    return secret ^ value


def prune(secret: int) -> int:
    """"""Prunes the secret number by taking it modulo 16777216.

    Args:
        secret: The current secret number.

    Returns:
        The updated secret number after the modulo operation.
    """"""
    return secret % 16777216


def generate_secret_number(initial_secret: int) -> int:
    """"""Generates the 2000th secret number for a buyer.

    Args:
        initial_secret: The initial secret number of a buyer.

    Returns:
        The 2000th secret number generated for that buyer.
    """"""
    secret = initial_secret
    for _ in range(2000):
        # 1. Multiply by 64, XOR, and prune.
        secret = mix(secret * 64, secret)
        secret = prune(secret)

        # 2. Divide by 32 (floor division), XOR, and prune.
        secret = mix(secret // 32, secret)
        secret = prune(secret)

        # 3. Multiply by 2048, XOR, and prune.
        secret = mix(secret * 2048, secret)
        secret = prune(secret)

    return secret


def solve_part_one(initial_secrets: List[int]) -> int:
    """"""Solves part one of the puzzle.

    Args:
        initial_secrets: A list of initial secret numbers.

    Returns:
        The sum of the 2000th secret number generated by each buyer.
    """"""
    total_sum = 0
    for initial_secret in initial_secrets:
        total_sum += generate_secret_number(initial_secret)
    return total_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    initial_secrets = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(initial_secrets)
    print(part_one_solution)

    # Example Usage / Tests (Optional)
    # test_input = [1, 10, 100, 2024]
    # expected_output = 37327623
    # if solve_part_one(test_input) == expected_output:
    #    print(""Test case passed!"")
    # else:
    #    print(""Test case failed!"")

if __name__ == ""__main__"":
    main()
",0,[],1,"pseudorandom number generation,simulation,bitwise operations,modulo arithmetic","Iteration,Modular Arithmetic,Bitwise Operations",49.62380242347717
True,23,baseline,"'''
Advent of Code 2023 Day 23: LAN Party
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
'''

from typing import List, Dict, Tuple, Set, Optional
import sys
from itertools import combinations

def parse_input(input_file: str) -> Tuple[Dict[str, Set[str]], Set[str]]:
    """"""Parse the puzzle input from file into an adjacency list and a set of computer names.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A dictionary representing the graph (adjacency list).
        - A set of all computer names.
    """"""
    graph: Dict[str, Set[str]] = {}
    computer_names: Set[str] = set()

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                computer1, computer2 = line.split('-')
            except ValueError:
                print(f""Invalid input line: {line}"", file=sys.stderr)
                continue

            computer_names.add(computer1)
            computer_names.add(computer2)

            if computer1 not in graph:
                graph[computer1] = set()
            if computer2 not in graph:
                graph[computer2] = set()

            graph[computer1].add(computer2)
            graph[computer2].add(computer1)

    return graph, computer_names


def find_cliques(graph: Dict[str, Set[str]], computer_names: Set[str]) -> List[Set[str]]:
    """"""Find all cliques of size 3 in the graph.

    Args:
        graph: The graph represented as an adjacency list.
        computer_names: A set of all computer names.

    Returns:
        A list of sets, where each set represents a clique of size 3.
    """"""
    cliques: List[Set[str]] = []
    for combo in combinations(computer_names, 3):
        a, b, c = combo
        if (b in graph[a] and
            c in graph[a] and
            a in graph[b] and
            c in graph[b] and
            a in graph[c] and
            b in graph[c]):
            cliques.append(set(combo))

    return cliques


def count_t_cliques(cliques: List[Set[str]]) -> int:
    """"""Count the number of cliques that contain at least one computer name starting with 't'.

    Args:
        cliques: A list of sets, where each set represents a clique.

    Returns:
        The number of cliques that contain at least one computer name starting with 't'.
    """"""
    count = 0
    for clique in cliques:
        for computer in clique:
            if computer.startswith('t'):
                count += 1
                break  # Only need one 't' computer per clique
    return count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    try:
        graph, computer_names = parse_input(input_file)
    except FileNotFoundError:
        print(f""Error: Input file '{input_file}' not found."", file=sys.stderr)
        return
    except Exception as e:
        print(f""Error parsing input: {e}"", file=sys.stderr)
        return

    # Find cliques
    cliques = find_cliques(graph, computer_names)

    # Count cliques with 't'
    t_clique_count = count_t_cliques(cliques)

    # Print the result
    print(t_clique_count)


if __name__ == ""__main__"":
    main()
",1,[],2,"graph theory,clique detection,string manipulation,network analysis","graph traversal,set theory,string matching",84.74787759780884
True,24,baseline,"""""""
Advent of Code 2023 Day 24: Crossed Wires
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Optional
import sys
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[Tuple[Optional[str], Optional[str], str, str]]]:
    """"""Parse the puzzle input from file.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - initial_values: A dictionary of initial wire values.
        - gates: A list of gate definitions.
    """"""
    initial_values: Dict[str, int] = {}
    gates: List[Tuple[Optional[str], Optional[str], str, str]] = []

    with open(input_file, 'r') as f:
        lines = f.read().splitlines()

    # Split into initial values and gate definitions
    split_index = lines.index('')
    initial_value_lines = lines[:split_index]
    gate_definition_lines = lines[split_index + 1:]

    # Parse initial values
    for line in initial_value_lines:
        wire, value = line.split(': ')
        initial_values[wire] = int(value)

    # Parse gate definitions
    for line in gate_definition_lines:
        match = re.match(r'^(?:([a-z0-9]+) )?(AND|OR|XOR) (?:([a-z0-9]+) )?-> ([a-z0-9]+)$', line)
        if match:
            input_1, operation, input_2, output = match.groups()
            gates.append((input_1, input_2, operation, output))
        else:
            match = re.match(r'^([a-z0-9]+) -> ([a-z0-9]+)$', line)
            if match:
                input_1, output = match.groups()
                gates.append((input_1, None, 'SIGNAL', output))
            else:
                print(f""Unexpected line format: {line}"", file=sys.stderr)

    return initial_values, gates


def simulate_circuit(initial_values: Dict[str, int], gates: List[Tuple[Optional[str], Optional[str], str, str]]) -> Dict[str, int]:
    """"""Simulate the boolean logic circuit.

    Args:
        initial_values: A dictionary of initial wire values.
        gates: A list of gate definitions.

    Returns:
        A dictionary of final wire values.
    """"""
    wire_values: Dict[str, int] = initial_values.copy()
    max_iterations = 100  # Avoid infinite loops in case of issues
    iteration = 0
    changed = True #Keeps iterating while there are still changes

    while changed and iteration < max_iterations:
        changed = False
        iteration += 1

        for input_1, input_2, operation, output in gates:

            # Handle SIGNAL operation (direct assignment)
            if operation == 'SIGNAL':
                if input_1 in wire_values:
                    if output not in wire_values or wire_values[output] != wire_values[input_1]:
                        wire_values[output] = wire_values[input_1]
                        changed = True
                continue

            #Evaluate the gates only if we have all the inputs.
            if input_1 in wire_values and input_2 in wire_values:
                val_1 = wire_values[input_1]
                val_2 = wire_values[input_2]

                if operation == 'AND':
                    result = val_1 & val_2
                elif operation == 'OR':
                    result = val_1 | val_2
                elif operation == 'XOR':
                    result = val_1 ^ val_2
                else:
                    print(f""Unknown operation: {operation}"", file=sys.stderr)
                    continue

                #Only update the output value if it is not there, or it changed.
                if output not in wire_values or wire_values[output] != result:
                    wire_values[output] = result
                    changed = True

    return wire_values


def extract_z_wire_values(wire_values: Dict[str, int]) -> List[int]:
    """"""Extract the values of wires starting with 'z'.

    Args:
        wire_values: A dictionary of wire values.

    Returns:
        A list of 'z' wire values, sorted by wire name.
    """"""
    z_wires = [(wire, value) for wire, value in wire_values.items() if wire.startswith('z')]
    z_wires.sort(key=lambda x: x[0])  # Sort by wire name
    return [value for wire, value in z_wires]


def binary_to_decimal(binary_values: List[int]) -> int:
    """"""Convert a list of binary values to a decimal number.

    Args:
        binary_values: A list of integers (0 or 1) representing the binary number.

    Returns:
        The decimal equivalent.
    """"""
    decimal_value = 0
    for i, bit in enumerate(binary_values):
        decimal_value += bit * (2 ** i)
    return decimal_value


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_values, gates = parse_input(input_file)

    # Simulate circuit
    wire_values = simulate_circuit(initial_values, gates)

    # Extract Z wire values
    z_wire_values = extract_z_wire_values(wire_values)

    # Binary to decimal conversion
    decimal_number = binary_to_decimal(z_wire_values)

    # Generate output
    print(decimal_number)


if __name__ == ""__main__"":
    main()
",3,[],2,"boolean logic,circuit simulation,bit manipulation,data dependencies,binary conversion,decimal conversion","graph traversal,topological sort,dataflow analysis",164.7290165424347
False,25,baseline,,6,['The `calculate_column_heights_keys` function iterates through the rows in the wrong order. It should iterate from the bottom up in terms of row indices to correctly calculate height of keys. You should iterate the rows as `lines[schematic_height - 1 - row][col]` instead of `lines[row][col]`.'],1,"string manipulation,pattern matching,height calculation,schematic analysis","parsing,iteration,conditional logic",147.37883305549622
True,1,disable_preprocessing,"'''Advent of Code 2023 Day 1: Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
'''

import sys

def parse_input(input_file):
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file (str): Path to the input file

    Returns:
        tuple(list[int], list[int]): Two lists containing the parsed integers.
    """"""
    list1 = []
    list2 = []

    try:
        with open(input_file, 'r') as f:
            for line in f:
                num1, num2 = map(int, line.strip().split())
                list1.append(num1)
                list2.append(num2)
    except FileNotFoundError:
        print(f""Error: The file '{input_file}' was not found."")
        sys.exit(1)
    except ValueError:
        print(f""Error: Invalid input format in '{input_file}'. Each line should contain two integers separated by whitespace."")
        sys.exit(1)

    return list1, list2


def calculate_total_distance(list1, list2):
    """"""Calculates the total distance between two lists of integers.

    Args:
        list1 (list[int]): The first list of integers.
        list2 (list[int]): The second list of integers.

    Returns:
        int: The total distance between the two lists.
    """"""
    total_distance = 0
    for i in range(len(list1)):
        total_distance += abs(list1[i] - list2[i])
    return total_distance


def solve_puzzle(input_file):
    """"""Solves the puzzle by parsing the input, sorting the lists, and calculating the total distance.

    Args:
        input_file (str): Path to the input file

    Returns:
        int: The total distance between the two lists.
    """"""
    list1, list2 = parse_input(input_file)
    list1.sort()
    list2.sort()
    total_distance = calculate_total_distance(list1, list2)
    return total_distance


def main():
    """"""Main function to execute the puzzle solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    result = solve_puzzle(input_file)
    print(result)


if __name__ == ""__main__"":
    main()",0,[],3,,,115.96558403968811
True,2,disable_preprocessing,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of reports, where each report is a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of reports, where each report is a list of integers.
    """"""
    reports = []
    with open(input_file, 'r') as f:
        for line in f:
            report = [int(x) for x in line.strip().split()]
            reports.append(report)
    return reports


def is_gradually_increasing(report: List[int]) -> bool:
    """"""Check if a report is gradually increasing.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is gradually increasing, False otherwise.
    """"""
    if len(report) <= 1:
        return True
    for i in range(1, len(report)):
        if report[i] < report[i - 1] or not 1 <= report[i] - report[i - 1] <= 3:
            return False
    return True


def is_gradually_decreasing(report: List[int]) -> bool:
    """"""Check if a report is gradually decreasing.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is gradually decreasing, False otherwise.
    """"""
    if len(report) <= 1:
        return True
    for i in range(1, len(report)):
        if report[i] > report[i - 1] or not 1 <= report[i - 1] - report[i] <= 3:
            return False
    return True


def is_safe_report(report: List[int]) -> bool:
    """"""Determine if a report is safe.

    Args:
        report: A list of integers representing a report.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    return is_gradually_increasing(report) or is_gradually_decreasing(report)


def count_safe_reports(reports: List[List[int]]) -> int:
    """"""Count the number of safe reports.

    Args:
        reports: A list of reports, where each report is a list of integers.

    Returns:
        The number of safe reports.
    """"""
    safe_count = 0
    for report in reports:
        if is_safe_report(report):
            safe_count += 1
    return safe_count


def main():
    """"""Main function to solve the puzzle.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    reports = parse_input(input_file)
    safe_reports_count = count_safe_reports(reports)
    print(safe_reports_count)


if __name__ == ""__main__"":
    main()
",0,[],3,,,57.86518335342407
True,3,disable_preprocessing,"""""""
Advent of Code 2023 Day 3: Mull It Over
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
import sys
import re
from typing import List, Tuple

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a string.

    Args:
        input_file: Path to the input file

    Returns:
        A string containing the corrupted memory.
    """"""
    try:
        with open(input_file, 'r') as f:
            return f.read().strip()
    except FileNotFoundError:
        print(f""Error: File not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading input file: {e}"", file=sys.stderr)
        sys.exit(1)

def solve_part_one(corrupted_memory: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        corrupted_memory: A string representing the corrupted memory.

    Returns:
        The sum of the results of valid multiplications.
    """"""
    # Define the regular expression pattern
    pattern = r""mul\((\d{1,3}),(\d{1,3})\)""

    # Find all matches in the corrupted memory
    matches = re.findall(pattern, corrupted_memory)

    # Initialize the accumulator
    total_sum = 0

    # Iterate through the matches and accumulate the results
    for match in matches:
        try:
            x = int(match[0])
            y = int(match[1])

            # Validate that X and Y are within the valid range (0-999)
            if 0 <= x <= 999 and 0 <= y <= 999:
                total_sum += x * y
            else:
                # Skip invalid matches
                continue
        except ValueError as e:
            print(f""ValueError: {e}. Skipping match."", file=sys.stderr)
            continue # Skip if conversion to integer fails (shouldn't happen due to regex)

    return total_sum

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    corrupted_memory = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(corrupted_memory)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],3,,,62.282644510269165
True,4,disable_preprocessing,"""""""
Advent of Code 2023 Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys


def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of characters representing the grid.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid


def check_direction(grid: List[List[str]], row: int, col: int, word: str, direction: Tuple[int, int]) -> bool:
    """"""Check if the word exists starting from a given cell in a given direction.

    Args:
        grid: The 2D grid of characters.
        row: The starting row index.
        col: The starting column index.
        word: The word to search for.
        direction: A tuple representing the direction (row_delta, col_delta).

    Returns:
        True if the word is found, False otherwise.
    """"""
    row_delta, col_delta = direction
    current_word = """"
    current_row, current_col = row, col

    for _ in range(len(word)):
        if 0 <= current_row < len(grid) and 0 <= current_col < len(grid[0]):
            current_word += grid[current_row][current_col]
            if current_word == word:
                return True
            current_row += row_delta
            current_col += col_delta
        else:
            return False

    return False


def solve(grid: List[List[str]]) -> int:
    """"""Solve the puzzle and return the number of times ""XMAS"" appears in the grid.

    Args:
        grid: The 2D grid of characters.

    Returns:
        The number of times ""XMAS"" appears in the grid.
    """"""
    word = ""XMAS""
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]
    count = 0

    for row in range(len(grid)):
        for col in range(len(grid[0])):
            for direction in directions:
                if check_direction(grid, row, col, word, direction):
                    count += 1

    return count


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    result = solve(grid)
    print(result)


if __name__ == ""__main__"":
    main()
",0,[],3,,,111.63131356239319
False,5,disable_preprocessing,,6,[],3,,,163.49075412750244
True,6,disable_preprocessing,"""""""
Advent of Code 2023 Day 6: Guard Gallivant
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> Tuple[List[List[str]], int, int, int]:
    """"""Parse the puzzle input from file into a 2D grid, and find the guard's starting position and direction.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - grid: 2D list of characters representing the map.
            - row: Starting row of the guard.
            - col: Starting column of the guard.
            - direction: Starting direction of the guard (0: up, 1: right, 2: down, 3: left).
    """"""
    with open(input_file, 'r') as f:
        lines = f.read().splitlines()

    grid = [list(line) for line in lines]
    row, col, direction = 0, 0, 0

    for r in range(len(grid)):
        for c in range(len(grid[r])):
            if grid[r][c] == '^':
                row, col = r, c
                direction = 0
                break
            elif grid[r][c] == '>':
                row, col = r, c
                direction = 1
                break
            elif grid[r][c] == 'v':
                row, col = r, c
                direction = 2
                break
            elif grid[r][c] == '<':
                row, col = r, c
                direction = 3
                break
        else:
            continue
        break

    return grid, row, col, direction


def solve(grid: List[List[str]], start_row: int, start_col: int, start_direction: int) -> int:
    """"""Simulate the guard's movement and count the number of distinct positions visited.

    Args:
        grid: 2D list of characters representing the map.
        start_row: Starting row of the guard.
        start_col: Starting column of the guard.
        start_direction: Starting direction of the guard (0: up, 1: right, 2: down, 3: left).

    Returns:
        The number of distinct positions visited by the guard.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    row, col, direction = start_row, start_col, start_direction
    visited: Set[Tuple[int, int]] = set()
    visited.add((row, col))
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]

    while 0 <= row < rows and 0 <= col < cols:
        next_row = row + directions[direction][0]
        next_col = col + directions[direction][1]

        if not (0 <= next_row < rows and 0 <= next_col < cols):
            break

        if grid[next_row][next_col] == '#':
            direction = (direction + 1) % 4
        else:
            row, col = next_row, next_col
            visited.add((row, col))

    return len(visited)


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid, start_row, start_col, start_direction = parse_input(input_file)
    distinct_positions = solve(grid, start_row, start_col, start_direction)
    print(distinct_positions)


if __name__ == ""__main__"":
    main()
",0,[],3,,,68.61943030357361
True,7,disable_preprocessing,"""""""
Advent of Code 2023 Day 7: Bridge Repair
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of (target, numbers) tuples.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple contains (target_value, list_of_numbers).
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            parts = line.strip().split(':')
            target = int(parts[0])
            numbers = [int(x) for x in parts[1].strip().split()]
            equations.append((target, numbers))
    return equations

def solve_equation(target: int, numbers: List[int]) -> bool:
    """"""Recursively checks if the equation can be solved with '+' or '*'.

    Args:
        target: The target value to reach.
        numbers: The list of numbers in the equation.

    Returns:
        True if the equation is solvable, False otherwise.
    """"""
    if not numbers:
        return False  # Should not happen if initial call is correct

    if len(numbers) == 1:
        return numbers[0] == target

    def solve_recursive(current_result: int, remaining_numbers: List[int]) -> bool:
        if not remaining_numbers:
            return current_result == target

        next_number = remaining_numbers[0]
        rest_of_numbers = remaining_numbers[1:]

        return solve_recursive(current_result + next_number, rest_of_numbers) or \
               solve_recursive(current_result * next_number, rest_of_numbers)

    return solve_recursive(numbers[0], numbers[1:])

def solve_part_one(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Solves part one of the puzzle.

    Args:
        equations: A list of (target, numbers) tuples.

    Returns:
        The sum of the target values of the solvable equations.
    """"""
    total_sum = 0
    for target, numbers in equations:
        if solve_equation(target, numbers):
            total_sum += target
    return total_sum

def main():
    """"""Main function to read input, solve the puzzle, and print the result.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    equations = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(equations)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],2,,,75.75689053535461
True,8,disable_preprocessing,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[List[str]], Dict[str, List[Tuple[int, int]]]]:
    """"""Parse the puzzle input from file into appropriate data structures.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - map: A 2D list of characters representing the antenna map.
            - antennas: A dictionary where keys are antenna frequencies and values are lists of (row, column) tuples.
    """"""
    map_data: List[List[str]] = []
    antennas: Dict[str, List[Tuple[int, int]]] = defaultdict(list)

    with open(input_file, 'r') as f:
        for row, line in enumerate(f):
            line = line.strip()
            map_row: List[str] = list(line)
            map_data.append(map_row)
            for col, char in enumerate(line):
                if re.match(r'[a-zA-Z0-9]', char):
                    antennas[char].append((row, col))

    return map_data, antennas


def calculate_antinodes(map_data: List[List[str]], antennas: Dict[str, List[Tuple[int, int]]]) -> Set[Tuple[int, int]]:
    """"""Calculate the unique antinode locations.

    Args:
        map_data: A 2D list of characters representing the antenna map.
        antennas: A dictionary of lists of (row, column) tuples.

    Returns:
        A set of (row, column) tuples representing the unique antinode locations.
    """"""
    antinodes: Set[Tuple[int, int]] = set()
    map_height = len(map_data)
    map_width = len(map_data[0]) if map_height > 0 else 0

    for frequency, antenna_locations in antennas.items():
        for i in range(len(antenna_locations)):
            for j in range(i + 1, len(antenna_locations)):
                r1, c1 = antenna_locations[i]
                r2, c2 = antenna_locations[j]

                # Antinode 1
                row = 2 * r1 - r2
                col = 2 * c1 - c2
                if 0 <= row < map_height and 0 <= col < map_width:
                    antinodes.add((row, col))

                # Antinode 2
                row = 2 * r2 - r1
                col = 2 * c2 - c1
                if 0 <= row < map_height and 0 <= col < map_width:
                    antinodes.add((row, col))

    return antinodes


def solve_part_one(map_data: List[List[str]], antennas: Dict[str, List[Tuple[int, int]]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        map_data: A 2D list of characters representing the antenna map.
        antennas: A dictionary of lists of (row, column) tuples.

    Returns:
        Solution for part one (number of unique antinode locations).
    """"""
    antinodes = calculate_antinodes(map_data, antennas)
    return len(antinodes)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    map_data, antennas = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(map_data, antennas)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,,,124.09959483146667
False,9,disable_preprocessing,,6,[],3,,,170.94821524620056
True,10,disable_preprocessing,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> Tuple[List[List[int]], List[Tuple[int, int]]]:
    """"""Parse the puzzle input from file into a 2D grid and a list of trailheads.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - grid: A 2D list of integers representing the map.
        - trailheads: A list of tuples (row, col) representing the coordinates of trailheads.
    """"""
    grid: List[List[int]] = []
    trailheads: List[Tuple[int, int]] = []

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            row = [int(c) for c in line.strip()]
            grid.append(row)
            for c, height in enumerate(row):
                if height == 0:
                    trailheads.append((r, c))

    return grid, trailheads


def dfs(row: int, col: int, grid: List[List[int]], visited: Set[Tuple[int, int]]) -> int:
    """"""Depth-First Search to find reachable 9s from a given position.

    Args:
        row: The row index of the current position.
        col: The column index of the current position.
        grid: The 2D grid representing the map.
        visited: A set of tuples (row, col) representing visited positions.

    Returns:
        The number of reachable 9s from the current position.
    """"""
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):
        return 0

    if (row, col) in visited:
        return 0

    visited.add((row, col))

    if grid[row][col] == 9:
        return 1

    count = 0
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for dr, dc in directions:
        new_row = row + dr
        new_col = col + dc

        if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] == grid[row][col] + 1:
            count += dfs(new_row, new_col, grid, visited)

    return count


def solve_part_one(grid: List[List[int]], trailheads: List[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: The 2D grid representing the map.
        trailheads: A list of tuples (row, col) representing the coordinates of trailheads.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    total_score = 0
    for trailhead in trailheads:
        visited: Set[Tuple[int, int]] = set()
        total_score += dfs(trailhead[0], trailhead[1], grid, visited)

    return total_score


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid, trailheads = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(grid, trailheads)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],3,,,76.96843075752258
True,11,disable_preprocessing,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_string: str) -> List[str]:
    """"""Parse the puzzle input from a string into a list of strings.

    Args:
        input_string: The input string containing stone values separated by spaces.

    Returns:
        A list of strings, where each string represents a stone's engraved number.
    """"""
    if not input_string:
        return []
    return input_string.split()


def transform_stone(stone: str) -> List[str]:
    """"""Apply the transformation rules to a single stone.

    Args:
        stone: A string representing the stone's engraved number.

    Returns:
        A list of strings representing the transformed stone(s).
    """"""
    if stone == ""0"":
        return [""1""]
    elif len(stone) % 2 == 0:
        half_len = len(stone) // 2
        left = str(int(stone[:half_len]))  # Remove leading zeros
        right = str(int(stone[half_len:])) # Remove leading zeros
        return [left, right]
    else:
        return [str(int(stone) * 2024)]


def blink(stones: List[str]) -> List[str]:
    """"""Simulate one blink and update the stone arrangement.

    Args:
        stones: A list of strings representing the current stone arrangement.

    Returns:
        A list of strings representing the updated stone arrangement after one blink.
    """"""
    transformed_stones = []
    for stone in stones:
        transformed_stones.append(transform_stone(stone))

    # Flatten the list of lists into a single list
    updated_stones = []
    for stone_list in transformed_stones:
        updated_stones.extend(stone_list)

    return updated_stones


def solve(initial_stones: List[str], num_blinks: int) -> int:
    """"""Simulate the blinking process and count the final number of stones.

    Args:
        initial_stones: A list of strings representing the initial stone arrangement.
        num_blinks: The number of blinks to simulate.

    Returns:
        The total number of stones after the specified number of blinks.
    """"""
    stones = initial_stones
    for _ in range(num_blinks):
        stones = blink(stones)
    return len(stones)


def main():
    """"""Main function to execute the solution.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    with open(input_file, 'r') as f:
        input_string = f.read().strip()

    initial_stones = parse_input(input_string)
    num_blinks = 25
    final_stone_count = solve(initial_stones, num_blinks)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(final_stone_count)

if __name__ == ""__main__"":
    main()
",3,[],3,,,104.80464911460876
True,12,disable_preprocessing,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list representing the garden map.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                grid.append(list(line))
    return grid


def flood_fill(grid: List[List[str]], visited: Set[Tuple[int, int]], row: int, col: int, current_region_cells: List[Tuple[int, int]]) -> None:
    """"""Performs flood fill to identify a connected region.

    Args:
        grid: The 2D grid representing the garden map.
        visited: A set to store visited cell coordinates.
        row: The row index of the current cell.
        col: The column index of the current cell.
        current_region_cells: A list to store the coordinates of cells in the current region.

    Returns:
        None (modifies visited and current_region_cells in place).
    """"""
    rows = len(grid)
    cols = len(grid[0])
    plant_type = grid[row][col]

    if (row, col) in visited:
        return

    visited.add((row, col))
    current_region_cells.append((row, col))

    # Check adjacent cells
    neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]
    for r, c in neighbors:
        if 0 <= r < rows and 0 <= c < cols and grid[r][c] == plant_type and (r, c) not in visited:
            flood_fill(grid, visited, r, c, current_region_cells)


def calculate_area_and_perimeter(grid: List[List[str]], region_cells: List[Tuple[int, int]]) -> Tuple[int, int]:
    """"""Calculates the area and perimeter of a region.

    Args:
        grid: The 2D grid representing the garden map.
        region_cells: A list of tuples representing the coordinates of cells in the region.

    Returns:
        A tuple containing the area and perimeter of the region.
    """"""
    area = len(region_cells)
    perimeter = 0
    rows = len(grid)
    cols = len(grid[0])

    for row, col in region_cells:
        # Check neighbors
        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]
        for r, c in neighbors:
            if not (0 <= r < rows and 0 <= c < cols) or grid[r][c] != grid[row][col]:
                perimeter += 1

    return area, perimeter


def solve(grid: List[List[str]]) -> int:
    """"""Solves the garden groups problem.

    Args:
        grid: The 2D grid representing the garden map.

    Returns:
        The total price of fencing all regions.
    """"""
    rows = len(grid)
    if rows == 0:
        return 0
    cols = len(grid[0])

    visited: Set[Tuple[int, int]] = set()
    regions: List[Dict[str, any]] = []
    total_price = 0

    for row in range(rows):
        for col in range(cols):
            if (row, col) not in visited:
                current_region_cells: List[Tuple[int, int]] = []
                flood_fill(grid, visited, row, col, current_region_cells)
                area, perimeter = calculate_area_and_perimeter(grid, current_region_cells)
                plant_type = grid[row][col]
                regions.append({'plant': plant_type, 'area': area, 'perimeter': perimeter})
                total_price += area * perimeter

    return total_price


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Solve the problem
    total_price = solve(grid)

    # Print the result
    print(total_price)

if __name__ == ""__main__"":
    main()
",0,[],3,,,91.54574584960938
True,13,disable_preprocessing,"'''Advent of Code 2023 Day 13: Claw Contraption
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
'''
import re
import sys
from typing import List, Optional, Tuple


class Machine:
    '''Represents a claw machine with its button behaviors and prize location.'''

    def __init__(self, a_x: int, a_y: int, b_x: int, b_y: int, prize_x: int, prize_y: int) -> None:
        self.a_x = a_x
        self.a_y = a_y
        self.b_x = b_x
        self.b_y = b_y
        self.prize_x = prize_x
        self.prize_y = prize_y


def parse_input(input_file: str) -> List[Machine]:
    '''Parse the puzzle input from file into a list of Machine objects.

    Args:
        input_file: Path to the input file

    Returns:
        A list of Machine objects.
    '''
    machines: List[Machine] = []
    with open(input_file, 'r') as f:
        machine_data = f.read().split('\n\n')

    for data in machine_data:
        if not data.strip():
            continue
        lines = data.strip().split('\n')

        a_x, a_y = map(int, re.findall(r'[-+]?\d+', lines[0]))
        b_x, b_y = map(int, re.findall(r'[-+]?\d+', lines[1]))
        prize_x, prize_y = map(int, re.findall(r'[-+]?\d+', lines[2]))

        machine = Machine(a_x, a_y, b_x, b_y, prize_x, prize_y)
        machines.append(machine)

    return machines


def solve_for_A_and_B_presses(machine: Machine) -> Optional[int]:
    '''Solve the system of equations to find the number of A and B presses.

    Args:
        machine: A Machine object.

    Returns:
        The minimum cost (tokens) to win the prize, or None if the prize cannot be won.
    '''
    a_x = machine.a_x
    a_y = machine.a_y
    b_x = machine.b_x
    b_y = machine.b_y
    prize_x = machine.prize_x
    prize_y = machine.prize_y

    # Solve the system of equations:
    # A_x * a + B_x * b = prize_x
    # A_y * a + B_y * b = prize_y
    # Using Cramer's rule:
    det = a_x * b_y - b_x * a_y

    if det == 0:
        return None  # No unique solution

    a = (prize_x * b_y - b_x * prize_y) / det
    b = (a_x * prize_y - prize_x * a_y) / det

    if 0 <= a <= 100 and 0 <= b <= 100 and a == int(a) and b == int(b):
        cost = 3 * a + 1 * b
        return int(cost)

    return None


def find_minimum_cost_and_count_winnable_prizes(machines: List[Machine]) -> Tuple[int, int]:
    '''Find the minimum cost for each winnable prize and count the total number of winnable prizes.

    Args:
        machines: The list of Machine objects.

    Returns:
        A tuple containing the total number of winnable prizes and the minimum total cost to win all possible prizes.
    '''
    total_cost = 0
    winnable_prizes = 0

    for machine in machines:
        cost = solve_for_A_and_B_presses(machine)
        if cost is not None:
            winnable_prizes += 1
            total_cost += cost

    return winnable_prizes, total_cost


def main():
    '''Main function to solve the puzzle.'''
    if len(sys.argv) < 2:
        print('Usage: python3 solution.py [input_file]')
        return

    input_file = sys.argv[1]
    machines = parse_input(input_file)

    winnable_prizes, total_cost = find_minimum_cost_and_count_winnable_prizes(machines)

    # Output the result
    print(total_cost)


if __name__ == '__main__':
    main()
",0,[],3,,,76.22215247154236
True,14,disable_preprocessing,"""""""
Advent of Code 2023 Day 14: Restroom Redoubt
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

class Robot:
    """"""Represents a robot with its position and velocity.""""""
    def __init__(self, x: int, y: int, vx: int, vy: int):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy

def parse_input(input_file: str) -> Tuple[List[Robot], int, int]:
    """"""Parse the puzzle input from file into Robot objects and grid dimensions.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of Robot objects, the grid width, and the grid height.
    """"""
    robots: List[Robot] = []
    with open(input_file, 'r') as f:
        for line in f:
            match = re.match(r'p=(\d+),(\d+) v=(-?\d+),(-?\d+)', line)
            if match:
                x, y, vx, vy = map(int, match.groups())
                robots.append(Robot(x, y, vx, vy))

    width = 101
    height = 103
    return robots, width, height


def simulate(robots: List[Robot], width: int, height: int, time: int) -> List[Robot]:
    """"""Simulate the robots' movement for a given time.

    Args:
        robots: A list of Robot objects.
        width: The width of the grid.
        height: The height of the grid.
        time: The simulation time.

    Returns:
        The updated list of Robot objects with their final positions.
    """"""
    for _ in range(time):
        for robot in robots:
            robot.x = (robot.x + robot.vx) % width
            robot.y = (robot.y + robot.vy) % height
    return robots


def count_quadrants(robots: List[Robot], width: int, height: int) -> Tuple[int, int, int, int]:
    """"""Count the number of robots in each quadrant.

    Args:
        robots: A list of Robot objects with their final positions.
        width: The width of the grid.
        height: The height of the grid.

    Returns:
        A tuple containing the number of robots in each quadrant (q1, q2, q3, q4).
    """"""
    q1 = 0
    q2 = 0
    q3 = 0
    q4 = 0
    mid_x = width // 2
    mid_y = height // 2
    for robot in robots:
        if robot.x > mid_x and robot.y < mid_y:
            q1 += 1
        elif robot.x < mid_x and robot.y < mid_y:
            q2 += 1
        elif robot.x < mid_x and robot.y > mid_y:
            q3 += 1
        elif robot.x > mid_x and robot.y > mid_y:
            q4 += 1
    return q1, q2, q3, q4


def calculate_safety_factor(q1: int, q2: int, q3: int, q4: int) -> int:
    """"""Calculate the safety factor by multiplying the number of robots in each quadrant.

    Args:
        q1: The number of robots in quadrant 1.
        q2: The number of robots in quadrant 2.
        q3: The number of robots in quadrant 3.
        q4: The number of robots in quadrant 4.

    Returns:
        The safety factor.
    """"""
    return q1 * q2 * q3 * q4


def main():
    """"""Main function to solve the puzzle.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    robots, width, height = parse_input(input_file)

    # Simulate
    robots = simulate(robots, width, height, 100)

    # Count quadrants
    q1, q2, q3, q4 = count_quadrants(robots, width, height)

    # Calculate safety factor
    safety_factor = calculate_safety_factor(q1, q2, q3, q4)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(safety_factor)

if __name__ == ""__main__"":
    main()
",0,[],3,,,74.27478575706482
False,15,disable_preprocessing,,6,"['The `IndexError: list index out of range` error indicates that the code is trying to access an index that is outside the bounds of the list. This is because the `grid` variable is updated twice, both after East-facing movement and South-facing movement. However, `moved` is only ever reset at the top of the while loop. It should be set to false after each movement so that it is not true if only east moved and not south or vice versa. Consider resetting `moved` to false or create two boolean flags for each direction. Set the boolean flag to `True` if the corresponding sea cucumbers moved, otherwise leave it as `False`. Finally, update the `moved` flag to True if any of the boolean flags is true.', 'The error was caused by a failure to correctly update the grid between the east-facing and south-facing movement simulations. The fix involves ensuring that the grid is updated with the result of the east-facing movement *before* the south-facing movement calculation begins. Specifically, `grid = copy.deepcopy(next_grid)` should be placed immediately after the east-facing movement loop completes, and again immediately after the south-facing movement loop. This ensures that each movement phase operates on the correct state of the grid.']",3,,,157.14597249031067
True,16,disable_preprocessing,"""""""
Advent of Code 2023 Day 16: Reindeer Maze
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set, Optional
import sys
import heapq

def parse_input(input_file: str) -> Tuple[List[List[str]], Tuple[int, int], Tuple[int, int]]:
    """"""Parse the puzzle input from file into a 2D grid and identify start/end positions.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - grid: 2D list of strings representing the maze.
        - start_position: (row, col) tuple of the starting position.
        - end_position: (row, col) tuple of the ending position.
    """"""
    grid: List[List[str]] = []
    start_position: Optional[Tuple[int, int]] = None
    end_position: Optional[Tuple[int, int]] = None

    with open(input_file, 'r') as f:
        for r, line in enumerate(f):
            row = list(line.strip())
            grid.append(row)
            for c, cell in enumerate(row):
                if cell == 'S':
                    start_position = (r, c)
                elif cell == 'E':
                    end_position = (r, c)

    if start_position is None or end_position is None:
        raise ValueError(""Start or end position not found in the input."")

    return grid, start_position, end_position


def move_forward(state: Tuple[int, int, int], grid: List[List[str]]) -> Optional[Tuple[int, int, int]]:
    """"""Calculate the next position based on the current direction, handling wrapping and walls.

    Args:
        state: (row, col, direction) tuple representing the current state.
        grid: 2D list of strings representing the maze.

    Returns:
        A new (row, col, direction) tuple if the move is valid, otherwise None.
    """"""
    row, col, direction = state
    rows, cols = len(grid), len(grid[0])

    if direction == 0:  # East
        next_col = (col + 1) % cols
        next_row = row
    elif direction == 1:  # South
        next_row = (row + 1) % rows
        next_col = col
    elif direction == 2:  # West
        next_col = (col - 1) % cols
        next_row = row
    elif direction == 3:  # North
        next_row = (row - 1) % rows
        next_col = col
    else:
        raise ValueError(""Invalid direction."")

    if grid[next_row][next_col] == '#':
        return None

    return next_row, next_col, direction


def rotate(state: Tuple[int, int, int], rotation: str) -> Tuple[int, int, int]:
    """"""Calculate the new direction based on the rotation.

    Args:
        state: (row, col, direction) tuple representing the current state.
        rotation: 'L' or 'R' representing the rotation direction.

    Returns:
        A new (row, col, direction) tuple with updated direction.
    """"""
    row, col, direction = state

    if rotation == 'L':
        new_direction = (direction - 1) % 4
    elif rotation == 'R':
        new_direction = (direction + 1) % 4
    else:
        raise ValueError(""Invalid rotation."")

    return row, col, new_direction


def heuristic(current_position: Tuple[int, int], end_position: Tuple[int, int]) -> int:
    """"""Calculate the Manhattan distance between two positions.

    Args:
        current_position: (row, col) tuple of the current position.
        end_position: (row, col) tuple of the end position.

    Returns:
        The Manhattan distance between the two positions.
    """"""
    return abs(current_position[0] - end_position[0]) + abs(current_position[1] - end_position[1])


def solve_maze(grid: List[List[str]], start_position: Tuple[int, int], end_position: Tuple[int, int]) -> int:
    """"""Solve the maze using A* search and return the lowest score.

    Args:
        grid: 2D list of strings representing the maze.
        start_position: (row, col) tuple of the starting position.
        end_position: (row, col) tuple of the ending position.

    Returns:
        The lowest score (integer) to reach the end position.
    """"""
    start_row, start_col = start_position
    end_row, end_col = end_position
    start_direction = 0  # East
    start_state = (start_row, start_col, start_direction)

    pq: List[Tuple[int, Tuple[int, int, int]]] = [(heuristic((start_row, start_col), (end_row, end_col)), 0, start_state)] # (heuristic, score, state)
    visited: Set[Tuple[int, int, int]] = set()

    while pq:
        _, score, current_state = heapq.heappop(pq)
        row, col, direction = current_state

        if (row, col) == (end_row, end_col):
            return score

        if current_state in visited:
            continue

        visited.add(current_state)

        # Move forward
        next_state = move_forward(current_state, grid)
        if next_state:
            next_row, next_col, next_direction = next_state
            new_score = score + 1
            heapq.heappush(pq, (new_score + heuristic((next_row, next_col), (end_row, end_col)), new_score, next_state))

        # Rotate left
        next_state = rotate(current_state, 'L')
        next_row, next_col, next_direction = next_state
        new_score = score + 1000
        heapq.heappush(pq, (new_score + heuristic((next_row, next_col), (end_row, end_col)), new_score, next_state))

        # Rotate right
        next_state = rotate(current_state, 'R')
        next_row, next_col, next_direction = next_state
        new_score = score + 1000
        heapq.heappush(pq, (new_score + heuristic((next_row, next_col), (end_row, end_col)), new_score, next_state))

    return -1 # No path found


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid, start_position, end_position = parse_input(input_file)

    # Solve the maze
    lowest_score = solve_maze(grid, start_position, end_position)

    # Print the result
    print(lowest_score)

if __name__ == ""__main__"":
    main()
",0,[],3,,,78.6665449142456
True,17,disable_preprocessing,"""""""
Advent of Code 2023 Day 17: Chronospatial Computer
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re


def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from file into registers and program. Registers are the initial state and program are the instructions.

    Args:
        input_file: Path to the input file

    Returns:
        Tuple of registers and program. Registers is a Dict mapping register name to initial value. Program is a List of integers.
    """"""
    registers = {}
    program = []

    with open(input_file, 'r') as f:
        lines = f.readlines()
        for line in lines:
            if line.startswith(""Register""): # Parse register values
                match = re.match(r""Register (A|B|C): (-?\d+)"", line)
                if match:
                    register_name = match.group(1)
                    register_value = int(match.group(2))
                    registers[register_name] = register_value

            elif line.startswith(""Program:""): # Parse the program
                program_str = line.split("": "")[1].strip()
                program = [int(x) for x in program_str.split("","")]

    return registers, program


def get_combo_operand_value(operand: int, registers: Dict[str, int]) -> int:
    """"""Determines the value of a combo operand.

    Args:
        operand: The operand value (0-6).
        registers: The dictionary of register values.

    Returns:
        The value of the combo operand.
    """"""
    if 0 <= operand <= 3:
        return operand
    elif operand == 4:
        return registers['A']
    elif operand == 5:
        return registers['B']
    elif operand == 6:
        return registers['C']
    else:
        raise ValueError(f""Invalid combo operand: {operand}"")


def solve_part_one(registers: Dict[str, int], program: List[int]) -> str:
    """"""Solve part one of the puzzle.

    Args:
        registers: Initial register values.
        program: List of program instructions.

    Returns:
        A string containing the comma-separated output values.
    """"""
    instruction_pointer = 0
    output = []

    while instruction_pointer < len(program):
        opcode = program[instruction_pointer]
        operand = program[instruction_pointer + 1] if instruction_pointer + 1 < len(program) else None

        if opcode == 0:  # adv
            registers['A'] = registers['A'] // (2 ** get_combo_operand_value(operand, registers))
        elif opcode == 1:  # bxl
            registers['B'] = registers['B'] ^ operand
        elif opcode == 2:  # bst
            registers['B'] = get_combo_operand_value(operand, registers) % 8
        elif opcode == 3:  # jnz
            if registers['A'] != 0:
                instruction_pointer = operand
                continue  # Skip incrementing instruction_pointer
        elif opcode == 4:  # bxc
            registers['B'] = registers['B'] ^ registers['C']
        elif opcode == 5:  # out
            output.append(get_combo_operand_value(operand, registers) % 8)
        elif opcode == 6:  # bdv
            registers['B'] = registers['A'] // (2 ** get_combo_operand_value(operand, registers))
        elif opcode == 7:  # cdv
            registers['C'] = registers['A'] // (2 ** get_combo_operand_value(operand, registers))
        else:
            raise ValueError(f""Invalid opcode: {opcode}"")

        instruction_pointer += 2

    return "","".join(map(str, output))


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    registers, program = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(registers, program)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",1,[],2,,,98.56742405891418
True,18,disable_preprocessing,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set, Optional
import sys
from collections import deque

def parse_input(input_file: str) -> List[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of (x, y) tuples.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple contains the x and y coordinates of a falling byte.
    """"""
    bytes_list = []
    with open(input_file, 'r') as f:
        for line in f:
            x, y = map(int, line.strip().split(','))
            bytes_list.append((x, y))
    return bytes_list


def initialize_grid(size: int) -> List[List[bool]]:
    """"""Initialize a 2D grid with all cells set to False (not corrupted).

    Args:
        size: The size of the grid (size x size).

    Returns:
        A 2D list of booleans, initialized to False.
    """"""
    grid = [[False for _ in range(size + 1)] for _ in range(size + 1)]
    return grid


def simulate_falling_bytes(grid: List[List[bool]], bytes_list: List[Tuple[int, int]], num_bytes: int) -> None:
    """"""Simulate the falling bytes and mark the corresponding coordinates on the grid as corrupted.

    Args:
        grid: The 2D grid representing the memory space.
        bytes_list: A list of tuples, where each tuple contains the x and y coordinates of a falling byte.
        num_bytes: The number of bytes to simulate.
    """"""
    for i in range(min(num_bytes, len(bytes_list))):
        x, y = bytes_list[i]
        grid[y][x] = True


def breadth_first_search(grid: List[List[bool]], size: int) -> int:
    """"""Perform a BFS to find the shortest path from (0, 0) to (size, size) on the grid, avoiding corrupted cells.

    Args:
        grid: The 2D grid representing the memory space.
        size: The size of the grid.

    Returns:
        The minimum number of steps to reach the exit, or -1 if no path exists.
    """"""
    queue = deque([(0, 0, 0)])  # (x, y, steps)
    visited = {(0, 0)}

    while queue:
        x, y, steps = queue.popleft()

        if x == size and y == size:
            return steps

        # Possible moves: up, down, left, right
        moves = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        for dx, dy in moves:
            new_x = x + dx
            new_y = y + dy

            # Check if the new coordinates are within the grid bounds
            if 0 <= new_x <= size and 0 <= new_y <= size:
                # Check if the new coordinates are not corrupted and have not been visited
                if not grid[new_y][new_x] and (new_x, new_y) not in visited:
                    queue.append((new_x, new_y, steps + 1))
                    visited.add((new_x, new_y))

    return -1  # No path exists


def main():
    """"""Main function to solve the puzzle.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    bytes_list = parse_input(input_file)

    # Initialize grid
    grid_size = 70  # or 6 for the example
    grid = initialize_grid(grid_size)

    # Simulate falling bytes
    simulate_falling_bytes(grid, bytes_list, 1024)

    # Perform BFS
    shortest_path_length = breadth_first_search(grid, grid_size)

    # Generate output
    print(shortest_path_length)


if __name__ == ""__main__"":
    main()
",0,[],3,,,108.35409450531006
True,19,disable_preprocessing,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and desired designs.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of towel patterns and a list of desired designs.
    """"""
    with open(input_file, 'r') as f:
        data = f.read().strip()
        parts = data.split('\n\n')
        towel_patterns = [s.strip() for s in parts[0].split(',')] if len(parts) > 0 else []
        desired_designs = parts[1].splitlines() if len(parts) > 1 else []

    return towel_patterns, desired_designs


def is_design_possible(design: str, towel_patterns: List[str]) -> bool:
    """"""Determine if a specific design can be created using available towel patterns.

    Args:
        design: The design string to check.
        towel_patterns: List of available towel patterns.

    Returns:
        True if the design is possible, False otherwise.
    """"""
    n = len(design)
    dp = [False] * (n + 1)
    dp[0] = True

    for i in range(1, n + 1):
        for pattern in towel_patterns:
            if len(pattern) <= i and design[i - len(pattern):i] == pattern and dp[i - len(pattern)]:
                dp[i] = True
                break

    return dp[n]


def solve_part_one(towel_patterns: List[str], desired_designs: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        towel_patterns: List of available towel patterns.
        desired_designs: List of desired designs.

    Returns:
        The number of possible designs.
    """"""
    possible_count = 0
    for design in desired_designs:
        if is_design_possible(design, towel_patterns):
            possible_count += 1

    return possible_count


def main():
    """"""Main function to execute the solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    towel_patterns, desired_designs = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(towel_patterns, desired_designs)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],3,,,70.64774250984192
False,20,disable_preprocessing,,6,"[""The code implements a BFS to find the shortest path through a grid, with a special cheat ability to pass through walls for a limited number of steps. The main issue was with the activation and continuation of the cheat mode. The code was missing boundary checks when activating the cheat and also did not account for the scenario where the 'cheat' might continue beyond its limit (2 steps). I have added boundary conditions before activating the cheat to ensure it's a valid move within the grid. I made sure that the cheat is activated only if the current cell is a wall '#', the cheat has not already been used, and the next cell is also a wall. The cheat duration is correctly being decremented to 0 so that cheat duration does not exceed 2."", ""The issue was caused by the presence of '\\r' (carriage return) characters in the input string. These characters were preventing the grid dimensions from being parsed correctly, leading to an incorrect result. To address this, I added `.replace('\\r', '')` to the line `row = list(line.strip())` within the `parse_input` function. This ensures that any carriage return characters are removed before the line is converted into a list of characters, allowing the grid dimensions to be determined accurately and the pathfinding algorithm to function correctly.""]",3,,,298.8516945838928
False,21,disable_preprocessing,,6,"[""The code calculates the path from 'A' to the target, but it needs to find the path from the current position to the target for each digit in the code. You can refactor the code to call the `bfs` to compute the paths on the fly between the digits and sum the distance.\nAlso, the distances and paths don't need to be passed as argument to the calculate_complexity function."", ""The error is in the `calculate_complexity` function, specifically how `numeric_part` is calculated. The current implementation calculates `numeric_part` by stripping trailing 'A' characters and converts the resulting string to an integer, which is incorrect. `numeric_part` should have been 0 for codes that begin with a character other than a number. The correct way to fix this is to assign numeric_part to 0 if the string consists of only As. rstrip('A') is the correct approach, but the numeric_part calculation still incorrectly tries to turn codes that are not numbers to integers.""]",3,,,270.0234775543213
True,22,disable_preprocessing,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of initial secret numbers.

    Args:
        input_file: Path to the input file

    Returns:
        List[int]: A list of integers representing the initial secret numbers.
    """"""
    initial_secrets = []
    with open(input_file, 'r') as f:
        for line in f:
            initial_secrets.append(int(line.strip()))
    return initial_secrets


def simulate_secret_number_generation(initial_secret: int) -> int:
    """"""Simulate the secret number generation process to get the 2000th secret number.

    Args:
        initial_secret: The initial secret number.

    Returns:
        int: The 2000th generated secret number.
    """"""
    secret = initial_secret
    for _ in range(2000):
        secret = simulate_one_step(secret)
    return secret


def simulate_one_step(secret: int) -> int:
    """"""Simulate one step of the secret number generation process.

    Args:
        secret: The current secret number.

    Returns:
        int: The next secret number.
    """"""
    secret = mix_and_prune(secret, secret * 64)
    secret = mix_and_prune(secret, secret // 32)
    secret = mix_and_prune(secret, secret * 2048)
    return secret


def mix_and_prune(secret: int, value: int) -> int:
    """"""Mix and prune the secret number.

    Args:
        secret: The current secret number.
        value: The value to mix in.

    Returns:
        int: The updated secret number.
    """"""
    secret = secret ^ value
    secret = secret % 16777216
    return secret


def calculate_sum_of_2000th_secret_numbers(initial_secrets: List[int]) -> int:
    """"""Calculate the sum of the 2000th secret numbers for each buyer.

    Args:
        initial_secrets: A list of initial secret numbers.

    Returns:
        int: The sum of the 2000th secret numbers.
    """"""
    total_sum = 0
    for initial_secret in initial_secrets:
        secret_2000 = simulate_secret_number_generation(initial_secret)
        total_sum += secret_2000
    return total_sum


def main():
    """"""Main function to solve the puzzle.

    Reads input from file, calculates the sum of the 2000th secret numbers,
    and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    initial_secrets = parse_input(input_file)
    total_sum = calculate_sum_of_2000th_secret_numbers(initial_secrets)

    print(total_sum)


if __name__ == ""__main__"":
    main()
",0,[],3,,,56.66787815093994
True,23,disable_preprocessing,"""""""
Advent of Code 2023 Day 23: LAN Party
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, Set[str]], Set[str]]:
    """"""Parse the puzzle input from file into a graph and a set of computers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing the graph (dictionary) and the set of computers.
    """"""
    graph: Dict[str, Set[str]] = defaultdict(set)
    computers: Set[str] = set()

    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue # Skip blank lines
            computer1, computer2 = line.split('-')
            computers.add(computer1)
            computers.add(computer2)
            graph[computer1].add(computer2)
            graph[computer2].add(computer1)

    return graph, computers

def find_triangles(computers: Set[str], graph: Dict[str, Set[str]]) -> List[Tuple[str, str, str]]:
    """"""Find all sets of three interconnected computers.

    Args:
        computers: A set of all computer names.
        graph: A dictionary representing the network graph.

    Returns:
        A list of tuples, where each tuple represents a set of three
        interconnected computers.
    """"""
    triangles: List[Tuple[str, str, str]] = []

    computers_list = list(computers)
    n = len(computers_list)

    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                a, b, c = computers_list[i], computers_list[j], computers_list[k]
                if (b in graph[a] and c in graph[a] and
                    a in graph[b] and c in graph[b] and
                    a in graph[c] and b in graph[c]):
                    triangles.append(tuple(sorted((a, b, c))))

    return triangles

def filter_and_count_triangles(triangles: List[Tuple[str, str, str]]) -> int:
    """"""Filter the list of triangles to only include those that have at least
    one computer name starting with the letter \""t\"".

    Args:
        triangles: A list of tuples representing interconnected computers.

    Returns:
        The number of triangles that contain at least one computer name
        starting with \""t\"".
    """"""
    final_count: int = 0

    for triangle in triangles:
        for computer in triangle:
            if computer.startswith('t'):
                final_count += 1
                break

    return final_count

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    graph, computers = parse_input(input_file)

    # Find all possible Triangles
    triangles = find_triangles(computers, graph)

    # Filter and Count Triangles
    part_one_solution = filter_and_count_triangles(triangles)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",2,[],3,,,85.38198184967041
False,24,disable_preprocessing,,6,"[""The original code did not correctly evaluate the circuit. It was necessary to ensure that when a gate was processed, its output wasn't already in the `wires` dictionary before evaluation. Additionally, the loop needed to run until all z_wires had values or a maximum number of iterations was reached to prevent infinite loops. Make sure the gate evaluation loop continues until all dependent wires are known and values converge. Use `new_values_added` flag effectively.""]",3,,,129.42985892295837
True,25,disable_preprocessing,"""""""
Advent of Code 2023 Day 25: Code Chronicle
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[list[list[str]], list[list[str]]]:
    """"""Parse the puzzle input from file into lists of lock and key schematics.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of lock schematics and a list of key schematics.
        Each schematic is represented as a list of strings (lines).
    """"""
    with open(input_file, 'r') as f:
        raw_input = f.read().strip()

    schematics = raw_input.split('\n\n')
    locks = []
    keys = []
    for schematic in schematics:
        lines = schematic.splitlines()
        if lines[0][0] == '#':
            locks.append(lines)
        else:
            keys.append(lines)
    return locks, keys


def schematic_to_heights(schematic: list[str]) -> list[int]:
    """"""Convert a lock or key schematic to a list of pin heights.

    Args:
        schematic: A list of strings representing the schematic.

    Returns:
        A list of integers representing the pin heights.
    """"""
    num_rows = len(schematic)
    num_cols = len(schematic[0])
    heights = []
    for col in range(num_cols):
        height = 0
        if schematic[0][0] == '#':  # Lock
            for row in range(num_rows):
                if schematic[row][col] == '#':
                    height += 1
                else:
                    break
        else:  # Key
            for row in range(num_rows - 1, -1, -1):
                if schematic[row][col] == '#':
                    height += 1
                else:
                    break

        heights.append(height)
    return heights


def solve_part_one(locks: list[list[str]], keys: list[list[str]]) -> int:
    """"""Solve part one of the puzzle: count fitting lock/key pairs.

    Args:
        locks: A list of lock schematics.
        keys: A list of key schematics.

    Returns:
        The number of lock/key pairs that fit together.
    """"""
    lock_heights_list = [schematic_to_heights(lock) for lock in locks]
    key_heights_list = [schematic_to_heights(key) for key in keys]

    fitting_pairs_count = 0
    num_rows = len(locks[0]) if locks else len(keys[0]) if keys else 0

    for lock_heights in lock_heights_list:
        for key_heights in key_heights_list:
            overlap = False
            for i in range(len(lock_heights)):  # Iterate through columns
                if lock_heights[i] + key_heights[i] > num_rows:
                    overlap = True
                    break
            if not overlap:
                fitting_pairs_count += 1

    return fitting_pairs_count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    locks, keys = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(locks, keys)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],3,,,64.93380689620972
True,1,disable_retrieval,"""""""
Advent of Code Day 1: Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers: the left list and the right list.
    """"""
    left_list: List[int] = []
    right_list: List[int] = []
    with open(input_file, 'r') as f:
        for line in f:
            left_val, right_val = line.strip().split()
            left_list.append(int(left_val))
            right_list.append(int(right_val))
    return left_list, right_list

def solve_part_one(left_list: List[int], right_list: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        left_list: The list of integers on the left.
        right_list: The list of integers on the right.

    Returns:
        The total distance between the two lists.
    """"""
    # Sort the lists
    left_list.sort()
    right_list.sort()

    # Calculate pairwise distances
    distances: List[int] = []
    for i in range(len(left_list)):
        distances.append(abs(left_list[i] - right_list[i]))

    # Calculate total distance
    total_distance: int = sum(distances)

    return total_distance

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    left_list, right_list = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(left_list, right_list)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"list processing,distance calculation,sorting,absolute difference,summation","Sorting algorithm (to determine smallest to largest),Absolute value calculation,Summation of integers",25.493282794952393
True,2,disable_retrieval,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists, where each inner list contains the integer levels for a single report.
    """"""
    reports: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            try:
                levels: List[int] = [int(level) for level in line.strip().split()]
                reports.append(levels)
            except ValueError:
                print(f""Skipping invalid report: {line.strip()}"", file=sys.stderr)
    return reports


def check_increasing_decreasing(report: List[int]) -> bool:
    """"""Determine if a given report is strictly increasing or strictly decreasing.

    Args:
        report: A list of integers representing a report's levels.

    Returns:
        True if the report is strictly increasing or strictly decreasing, False otherwise.
    """"""
    if len(report) <= 1:
        return True

    increasing = report[1] > report[0]

    for i in range(1, len(report)):
        if increasing:
            if report[i] <= report[i - 1]:
                return False
        else:
            if report[i] >= report[i - 1]:
                return False

    return True


def check_adjacent_level_difference(report: List[int]) -> bool:
    """"""Check if the difference between any two adjacent levels is within the valid range (1 to 3, inclusive).

    Args:
        report: A list of integers representing a report's levels.

    Returns:
        True if the absolute difference between all adjacent levels is between 1 and 3, False otherwise.
    """"""
    for i in range(1, len(report)):
        diff = abs(report[i] - report[i - 1])
        if diff < 1 or diff > 3:
            return False
    return True


def is_report_safe(report: List[int]) -> bool:
    """"""Determine if a report is safe.

    Args:
        report: A list of integers representing a report's levels.

    Returns:
        True if the report is safe, False otherwise.
    """"""
    return check_increasing_decreasing(report) and check_adjacent_level_difference(report)


def solve_part_one(reports: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        reports: A list of lists of integers (the parsed reports).

    Returns:
        An integer representing the total number of safe reports.
    """"""
    safe_reports_count = 0
    for report in reports:
        if is_report_safe(report):
            safe_reports_count += 1
    return safe_reports_count


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    reports = parse_input(input_file)
    part_one_solution = solve_part_one(reports)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"data analysis,report processing,numerical sequence,monotonicity,range check","sequence analysis,conditional logic,iteration",35.90513896942139
True,3,disable_retrieval,"""""""
Advent of Code 2023 Day 3: Mull It Over
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
import re

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a string.

    Args:
        input_file: Path to the input file

    Returns:
        A string containing the corrupted memory.
    """"""
    try:
        with open(input_file, 'r') as f:
            return f.read().strip()
    except FileNotFoundError:
        print(f""Error: File not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading file: {e}"", file=sys.stderr)
        sys.exit(1)


def solve_part_one(corrupted_memory: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        corrupted_memory: The corrupted memory string.

    Returns:
        The sum of the products of all valid mul(X,Y) instructions.
    """"""
    sum_of_multiplications = 0
    pattern = r""mul\((\d{1,3}),(\d{1,3})\)""
    matches: List[Tuple[str, str]] = re.findall(pattern, corrupted_memory)

    for match in matches:
        try:
            x = int(match[0])
            y = int(match[1])
            sum_of_multiplications += x * y
        except ValueError as e:
            print(f""Error converting string to integer: {e}"", file=sys.stderr)
            continue  # Skip to the next match

    return sum_of_multiplications


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        sys.exit(1)

    input_file = sys.argv[1]

    # Parse input
    corrupted_memory = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(corrupted_memory)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],0,"string parsing,pattern matching,arithmetic,multiplication,summation","regular expressions,string manipulation",30.025959730148315
True,4,disable_retrieval,"'''
Advent of Code 2023 Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
'''
from typing import List
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D grid of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    grid: List[List[str]] = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid


def check_horizontal(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists horizontally starting from the given cell.
    """"""
    if col + len(word) > len(grid[0]):
        return False

    s = """".join(grid[row][col + i] for i in range(len(word)))
    return s == word


def check_horizontal_reverse(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists horizontally in reverse starting from the given cell.
    """"""
    if col - len(word) + 1 < 0:
        return False

    s = """".join(grid[row][col - i] for i in range(len(word)))
    return s == word


def check_vertical(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists vertically starting from the given cell.
    """"""
    if row + len(word) > len(grid):
        return False

    s = """".join(grid[row + i][col] for i in range(len(word)))
    return s == word


def check_vertical_reverse(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists vertically in reverse starting from the given cell.
    """"""
    if row - len(word) + 1 < 0:
        return False

    s = """".join(grid[row - i][col] for i in range(len(word)))
    return s == word


def check_diagonal_forward(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists diagonally (forward) starting from the given cell.
    """"""
    if row + len(word) > len(grid) or col + len(word) > len(grid[0]):
        return False

    s = """".join(grid[row + i][col + i] for i in range(len(word)))
    return s == word


def check_diagonal_forward_reverse(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists diagonally (forward) in reverse starting from the given cell.
    """"""
    if row - len(word) + 1 < 0 or col - len(word) + 1 < 0:
        return False

    s = """".join(grid[row - i][col - i] for i in range(len(word)))
    return s == word


def check_diagonal_backward(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists diagonally (backward) starting from the given cell.
    """"""
    if row + len(word) > len(grid) or col - len(word) + 1 < 0:
        return False

    s = """".join(grid[row + i][col - i] for i in range(len(word)))
    return s == word


def check_diagonal_backward_reverse(grid: List[List[str]], row: int, col: int, word: str) -> bool:
    """"""Check if the word ""XMAS"" exists diagonally (backward) in reverse starting from the given cell.
    """"""
    if row - len(word) + 1 < 0 or col + len(word) > len(grid[0]):
        return False

    s = """".join(grid[row - i][col + i] for i in range(len(word)))
    return s == word


def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: Processed input data

    Returns:
        Solution for part one
    """"""
    word = ""XMAS""
    count = 0
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if check_horizontal(grid, row, col, word):
                count += 1
            if check_horizontal_reverse(grid, row, col, word):
                count += 1
            if check_vertical(grid, row, col, word):
                count += 1
            if check_vertical_reverse(grid, row, col, word):
                count += 1
            if check_diagonal_forward(grid, row, col, word):
                count += 1
            if check_diagonal_forward_reverse(grid, row, col, word):
                count += 1
            if check_diagonal_backward(grid, row, col, word):
                count += 1
            if check_diagonal_backward_reverse(grid, row, col, word):
                count += 1
    return count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",1,[],0,"string search,pattern matching,grid traversal","brute force,string manipulation",56.5016725063324
False,5,disable_retrieval,,6,"['The code splits the rules and updates sections using `\\n\\n`. However, the input uses only `\\n`.  Therefore, the split is incorrect, and `rules_str` contains the entire input while `updates_str` is empty. Update the code to split the rules and updates section by a single `\\n\\n`.', 'The code was incorrectly summing the middle element of the original `update` list instead of the `sorted_update` list after sorting. The `total_sum += update[middle_index]` line should be `total_sum += sorted_update[middle_index]`. When debugging, pay attention to which list the modifications are happening to and if the correct list is used later.']",0,"ordering,precedence rules,page numbers,updates,middle number,list validation","graph traversal (implicit),topological sort (validation),list processing",101.65526843070984
False,6,disable_retrieval,,6,[],0,"grid simulation,path finding,guard patrol,distinct positions,character grid","simulation,state tracking,coordinate manipulation,conditional logic",113.3294095993042
True,7,disable_retrieval,"""""""
Advent of Code 2023 Day 7: Bridge Repair
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of tuples.

    Each tuple contains the target value (int) and the list of numbers (list of ints)
    for each equation.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples representing the equations.
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                target, numbers_str = line.split(': ')
                target = int(target)
                numbers = [int(num) for num in numbers_str.split()]
                equations.append((target, numbers))
            except ValueError as e:
                print(f""Error parsing line: {line}.  Error: {e}"", file=sys.stderr)
                continue # Skip malformed lines
    return equations

def recursive_evaluation(target: int, numbers: List[int], index: int, current_value: int) -> bool:
    """"""Recursively evaluate the expression to check if it can reach the target value.

    Args:
        target: The target value.
        numbers: The list of numbers.
        index: The current index in the numbers list.
        current_value: The current evaluated value.

    Returns:
        True if the equation can be made true, False otherwise.
    """"""
    if index == len(numbers):
        return current_value == target

    return (recursive_evaluation(target, numbers, index + 1, current_value + numbers[index]) or
            recursive_evaluation(target, numbers, index + 1, current_value * numbers[index]))

def solve_part_one(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        equations: A list of tuples, where each tuple contains the target value and the list of numbers.

    Returns:
        The sum of the target values of the equations that can be made true.
    """"""
    total_sum = 0
    for target, numbers in equations:
        if not numbers:
            continue # Skip equations with no numbers
        if len(numbers) == 1:
            if numbers[0] == target:
                total_sum += target
            continue
        if recursive_evaluation(target, numbers, 1, numbers[0]):
            total_sum += target

    return total_sum

def main():
    """"""Main function to solve the puzzle.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]
    equations = parse_input(input_file)
    part_one_solution = solve_part_one(equations)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"arithmetic,expression evaluation,backtracking,operators","recursion,tree search",34.87596368789673
True,8,disable_retrieval,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int, str]], int, int]:
    """"""Parse the puzzle input from file into antenna locations and grid dimensions.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A list of antenna tuples: [(row, col, frequency), ...]
        - The number of rows in the grid
        - The number of columns in the grid
    """"""
    antennas: List[Tuple[int, int, str]] = []
    with open(input_file, 'r') as f:
        grid = [line.strip() for line in f]

    grid_height = len(grid)
    grid_width = len(grid[0]) if grid_height > 0 else 0

    for row in range(grid_height):
        for col in range(grid_width):
            if grid[row][col] != '.':
                antennas.append((row, col, grid[row][col]))

    return antennas, grid_height, grid_width


def solve_part_one(antennas: List[Tuple[int, int, str]], grid_height: int, grid_width: int) -> int:
    """"""Solve part one of the puzzle.

    Args:
        antennas: List of antenna tuples.
        grid_height: The height of the grid.
        grid_width: The width of the grid.

    Returns:
        The number of unique antinode locations.
    """"""
    unique_antinodes: Set[Tuple[int, int]] = set()

    for i in range(len(antennas)):
        for j in range(i + 1, len(antennas)):
            if antennas[i][2] == antennas[j][2]:
                # Calculate antinode locations
                row1, col1, freq = antennas[i]
                row2, col2, _ = antennas[j]

                row_a1 = 2 * row1 - row2
                col_a1 = 2 * col1 - col2
                row_a2 = 2 * row2 - row1
                col_a2 = 2 * col2 - col1

                # Validate antinode locations and add to the set
                if 0 <= row_a1 < grid_height and 0 <= col_a1 < grid_width:
                    unique_antinodes.add((row_a1, col_a1))
                if 0 <= row_a2 < grid_height and 0 <= col_a2 < grid_width:
                    unique_antinodes.add((row_a2, col_a2))

    return len(unique_antinodes)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    antennas, grid_height, grid_width = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(antennas, grid_height, grid_width)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],0,"grid,geometry,collinearity,distance","coordinate geometry,distance calculation,line equation",99.22141909599304
False,9,disable_retrieval,,6,[],0,"string manipulation,disk defragmentation,checksum,array manipulation","parsing,simulation,arithmetic",142.69092893600464
True,10,disable_retrieval,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    grid: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            row = [int(c) for c in line.strip()]
            grid.append(row)
    return grid


def identify_trailheads(grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Identify the coordinates of all trailheads (height 0).

    Args:
        grid: The topographic map.

    Returns:
        A list of tuples, where each tuple is (row, col) of a trailhead.
    """"""
    trailheads: List[Tuple[int, int]] = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0:
                trailheads.append((r, c))
    return trailheads


def calculate_trailhead_score(grid: List[List[int]], trailhead: Tuple[int, int]) -> int:
    """"""Calculate the score for a single trailhead using Depth-First Search (DFS).

    Args:
        grid: The topographic map.
        trailhead: The coordinates (row, col) of the trailhead.

    Returns:
        The number of reachable '9's from the trailhead.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    visited: Set[Tuple[int, int]] = set()
    trailhead_score = 0

    def dfs(row: int, col: int, prev_height: int):
        nonlocal trailhead_score
        if row < 0 or row >= rows or col < 0 or col >= cols or (row, col) in visited:
            return

        current_height = grid[row][col]
        if current_height != prev_height + 1:
            return

        visited.add((row, col))

        if current_height == 9:
            trailhead_score += 1
            return # Stop after reaching 9, as score is only incremented per 9 reached.

        # Explore adjacent positions
        dfs(row + 1, col, current_height)  # Down
        dfs(row - 1, col, current_height)  # Up
        dfs(row, col + 1, current_height)  # Right
        dfs(row, col - 1, current_height)  # Left

    dfs(trailhead[0], trailhead[1], -1)  # Start DFS with a previous height of -1 (since trailhead is 0)
    return trailhead_score


def solve_part_one(grid: List[List[int]]) -> int:
    """"""Solve part one of the puzzle by calculating the sum of all trailhead scores.

    Args:
        grid: The topographic map.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    trailheads = identify_trailheads(grid)
    total_score = 0
    for trailhead in trailheads:
        total_score += calculate_trailhead_score(grid, trailhead)
    return total_score


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    part_one_solution = solve_part_one(grid)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"grid traversal,pathfinding,heightmap,reachability,trailhead","depth-first search,breadth-first search,graph traversal,recursion",45.84351968765259
True,11,disable_retrieval,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial stone arrangement.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        stones = [int(x) for x in line.split()]
        return stones

def transform_stone(stone: int) -> List[int]:
    """"""Transform a single stone based on the given rules.

    Args:
        stone: The integer representing the stone.

    Returns:
        A list of integers representing the transformed stone(s).
    """"""
    if stone == 0:
        return [1]
    else:
        stone_str = str(stone)
        if len(stone_str) % 2 == 0:
            mid = len(stone_str) // 2
            left_str = stone_str[:mid]
            right_str = stone_str[mid:]

            # Remove leading zeros
            left = int(left_str)
            right = int(right_str)

            return [left, right]
        else:
            return [stone * 2024]

def solve_part_one(stones: List[int]) -> int:
    """"""Solve part one of the puzzle by simulating the stone transformations for 25 blinks.

    Args:
        stones: A list of integers representing the initial stone arrangement.

    Returns:
        The total number of stones after 25 blinks.
    """"""
    for _ in range(25):
        new_stones = []
        for stone in stones:
            new_stones.extend(transform_stone(stone))
        stones = new_stones
    return len(stones)


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    stones = parse_input(input_file)
    part_one_solution = solve_part_one(stones)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"simulation,number manipulation,sequence transformation,string splitting","iteration,conditional logic,string conversion,list manipulation",37.33154892921448
True,12,disable_retrieval,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of characters representing the garden map.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid


def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: A 2D list of characters representing the garden map.

    Returns:
        The total price of fencing all regions in the garden map.
    """"""
    if not grid:
        return 0

    rows = len(grid)
    cols = len(grid[0])
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    regions = []

    def dfs(row: int, col: int, plant_type: str, region_cells: List[Tuple[int, int]]) -> None:
        """"""Depth-First Search to explore a connected region.

        Args:
            row: Current row index.
            col: Current column index.
            plant_type: The plant type of the region.
            region_cells: A list to store cells in the current region.

        Returns:
            None (modifies region_cells in place).
        """"""
        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or grid[row][col] != plant_type:
            return

        visited[row][col] = True
        region_cells.append((row, col))

        dfs(row + 1, col, plant_type, region_cells)  # Down
        dfs(row - 1, col, plant_type, region_cells)  # Up
        dfs(row, col + 1, plant_type, region_cells)  # Right
        dfs(row, col - 1, plant_type, region_cells)  # Left

    def calculate_area_and_perimeter(region_cells: List[Tuple[int, int]]) -> Tuple[int, int]:
        """"""Calculate the area and perimeter of a region.

        Args:
            region_cells: A list of tuples representing the coordinates of cells in the region.

        Returns:
            A tuple containing the area and perimeter of the region.
        """"""
        area = len(region_cells)
        perimeter = 0
        for row, col in region_cells:
            # Check neighbors
            neighbors = [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]
            for r, c in neighbors:
                if r < 0 or r >= rows or c < 0 or c >= cols or (r,c) not in region_cells:
                    perimeter += 1
        return area, perimeter

    total_cost = 0
    for row in range(rows):
        for col in range(cols):
            if not visited[row][col]:
                plant_type = grid[row][col]
                region_cells: List[Tuple[int, int]] = []
                dfs(row, col, plant_type, region_cells)
                area, perimeter = calculate_area_and_perimeter(region_cells)
                regions.append({'area': area, 'perimeter': perimeter})
                total_cost += area * perimeter

    return total_cost


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    part_one_solution = solve_part_one(grid)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],0,"grid processing,region detection,area calculation,perimeter calculation,connected components","depth-first search,breadth-first search,graph traversal,flood fill",46.03862905502319
True,13,disable_retrieval,"""""""
Advent of Code 2023 Day 13: Claw Contraption
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re


def parse_input(input_file: str) -> List[Dict[str, int]]:
    """"""Parse the puzzle input from file into a list of dictionaries.

    Args:
        input_file: Path to the input file

    Returns:
        A list of dictionaries, where each dictionary represents a claw machine
        with the following keys: `a_x`, `a_y`, `b_x`, `b_y`, `prize_x`, `prize_y`.
    """"""
    machines = []
    with open(input_file, 'r') as f:
        machine_descriptions = f.read().strip().split('\n\n')
        for description in machine_descriptions:
            lines = description.split('\n')
            a_x, a_y = map(int, re.findall(r'X\+([-\d]+), Y\+([-\d]+)', lines[0])[0])
            b_x, b_y = map(int, re.findall(r'X\+([-\d]+), Y\+([-\d]+)', lines[1])[0])
            prize_x, prize_y = map(int, re.findall(r'X=([-\d]+), Y=([-\d]+)', lines[2])[0])

            machines.append({
                'a_x': a_x,
                'a_y': a_y,
                'b_x': b_x,
                'b_y': b_y,
                'prize_x': prize_x,
                'prize_y': prize_y
            })
    return machines


def solve_linear_equations(machines: List[Dict[str, int]]) -> List[Dict[str, int]]:
    """"""Solve the system of two linear equations for each machine.

    Args:
        machines: A list of machine dictionaries.

    Returns:
        A list of dictionaries, updated to include keys `a_presses`, `b_presses`,
        and `token_cost`. If no solution is found, set `a_presses` and `b_presses` to `None`.
    """"""
    for machine in machines:
        a_x = machine['a_x']
        a_y = machine['a_y']
        b_x = machine['b_x']
        b_y = machine['b_y']
        prize_x = machine['prize_x']
        prize_y = machine['prize_y']

        # Solve for a_presses and b_presses using Cramer's rule
        det = a_x * b_y - b_x * a_y

        if det == 0:
            machine['a_presses'] = None
            machine['b_presses'] = None
            continue

        a_presses_num = prize_x * b_y - b_x * prize_y
        b_presses_num = a_x * prize_y - prize_x * a_y

        a_presses = a_presses_num / det
        b_presses = b_presses_num / det

        if (a_presses >= 0 and a_presses <= 100 and b_presses >= 0 and b_presses <= 100 and
            abs(a_presses - round(a_presses)) < 1e-6 and abs(b_presses - round(b_presses)) < 1e-6):
            a_presses = int(round(a_presses))
            b_presses = int(round(b_presses))
            machine['a_presses'] = a_presses
            machine['b_presses'] = b_presses
            machine['token_cost'] = a_presses * 3 + b_presses * 1
        else:
            machine['a_presses'] = None
            machine['b_presses'] = None

    return machines


def determine_max_prizes_and_min_tokens(machines: List[Dict[str, int]]) -> Tuple[int, int]:
    """"""Determine the maximum number of prizes that can be won and the minimum number of tokens required.

    Args:
        machines: The updated list of machine dictionaries.

    Returns:
        A tuple containing the maximum number of prizes won and the minimum number of tokens required.
    """"""
    prizes_won = 0
    total_tokens = 0
    for machine in machines:
        if machine.get('a_presses') is not None:
            prizes_won += 1
            total_tokens += machine['token_cost']
    return prizes_won, total_tokens


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve linear equations
    solved_data = solve_linear_equations(parsed_data)

    # Determine maximum prizes and minimum tokens
    prizes_won, total_tokens = determine_max_prizes_and_min_tokens(solved_data)

    # Generate output
    print(total_tokens)

if __name__ == ""__main__"":
    main()
",1,[],0,"linear equations,integer solutions,optimization,claw machine,token cost","Diophantine equations,System of linear equations,Optimization",57.09727501869202
False,14,disable_retrieval,,6,[],0,"grid simulation,robot movement,wraparound,quadrant counting,coordinate system","modular arithmetic,simulation",129.04975652694702
False,15,disable_retrieval,,6,"[""The split by '\\n\\n' is not correct, leading to wrong warehouse creation. Consider splitting by two newlines `\\n\\n`. Also, double check how the input file is read, newline characters might be causing issues. Ensure that the warehouse data is correctly parsed into the 2D list and that robot position is found correctly."", ""The error in the original code was due to incorrectly parsing the moves string from the input file. The newline characters were not completely removed, leading to incorrect robot movement simulation. The `moves.replace('\\n', '')` replacement was not effective as it targeted literal '\\n' instead of actual newline characters. To correct this, I added another replacement for actual newline characters `moves = moves.replace('\\n', '')`. When parsing strings from files, it is crucial to ensure that all unwanted characters, including newline characters, are removed to prevent unexpected behavior. In the future, consider using `moves = moves.replace('\\n', '').strip()` to remove both newline characters and any leading/trailing whitespace characters.""]",0,"robot simulation,box pushing,grid traversal,GPS coordinates","simulation,state update,coordinate calculation",155.75539660453796
False,16,disable_retrieval,,6,"[""The original code implements a simple BFS, which is not efficient for this problem. To improve performance, I added a heuristic function (Manhattan distance) to guide the search. The heuristic helps the algorithm prioritize nodes closer to the destination. The queue is now treated as a priority queue, where nodes are selected based on their cost plus the heuristic value.  I replaced the deque's popleft() to popping the element from the queue that has the smallest cost + heuristic. This transformed the BFS into an A* search algorithm, leading to a significant reduction in the number of visited states and a faster solution."", ""The code's pathfinding logic is flawed. The `visited` set is being populated prematurely, potentially blocking the exploration of optimal paths. Change the visited to store tuples of `(row, col, direction, cost)`. Then, when exploring next states, only add to the queue if the current cost is less than the cost to reach the same state as stored in visited.""]",0,"grid traversal,pathfinding,minimum cost,maze,reindeer,navigation","shortest path,graph search,breadth-first search,A*,state space search",150.956307888031
True,17,disable_retrieval,"""""""
Advent of Code 2023 Day 17: Chronospatial Computer
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from file into register values and program instructions.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a dictionary of register values and a list of program instructions.
    """"""
    registers = {}
    program = []

    with open(input_file, 'r') as f:
        lines = f.readlines()
        for line in lines:
            line = line.strip()
            if line.startswith('Register'):
                match = re.match(r'Register (A|B|C): (-?\d+)', line)
                if match:
                    register_name = match.group(1)
                    register_value = int(match.group(2))
                    registers[register_name] = register_value
            elif line.startswith('Program'):
                program_str = line.split(': ')[1]
                program = [int(x) for x in program_str.split(',')]

    return registers, program

def combo_operand_value(operand: int, registers: Dict[str, int]) -> int:
    """"""Resolve the value of a combo operand.

    Args:
        operand: The operand value.
        registers: A dictionary containing the current register values.

    Returns:
        The resolved value of the combo operand.
    """"""
    if 0 <= operand <= 3:
        return operand
    elif operand == 4:
        return registers['A']
    elif operand == 5:
        return registers['B']
    elif operand == 6:
        return registers['C']
    else:
        raise ValueError(f""Invalid operand: {operand}"")

def execute_adv(registers: Dict[str, int], operand: int) -> None:
    """"""Execute the 'adv' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
    """"""
    divisor = 2 ** combo_operand_value(operand, registers)
    registers['A'] = registers['A'] // divisor

def execute_bxl(registers: Dict[str, int], operand: int) -> None:
    """"""Execute the 'bxl' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
    """"""
    registers['B'] = registers['B'] ^ operand

def execute_bst(registers: Dict[str, int], operand: int) -> None:
    """"""Execute the 'bst' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
    """"""
    registers['B'] = combo_operand_value(operand, registers) % 8


def execute_jnz(registers: Dict[str, int], operand: int, instruction_pointer: int) -> int:
    """"""Execute the 'jnz' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
        instruction_pointer: The current instruction pointer.

    Returns:
        The updated instruction pointer.
    """"""
    if registers['A'] != 0:
        return operand
    else:
        return instruction_pointer + 2


def execute_bxc(registers: Dict[str, int]) -> None:
    """"""Execute the 'bxc' instruction.

    Args:
        registers: A dictionary containing the current register values.
    """"""
    registers['B'] = registers['B'] ^ registers['C']


def execute_out(registers: Dict[str, int], operand: int, output: List[int]) -> None:
    """"""Execute the 'out' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
        output: The list of output values.
    """"""
    output_value = combo_operand_value(operand, registers) % 8
    output.append(output_value)


def execute_bdv(registers: Dict[str, int], operand: int) -> None:
    """"""Execute the 'bdv' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
    """"""
    divisor = 2 ** combo_operand_value(operand, registers)
    registers['B'] = registers['A'] // divisor


def execute_cdv(registers: Dict[str, int], operand: int) -> None:
    """"""Execute the 'cdv' instruction.

    Args:
        registers: A dictionary containing the current register values.
        operand: The operand value.
    """"""
    divisor = 2 ** combo_operand_value(operand, registers)
    registers['C'] = registers['A'] // divisor


def simulate_program(registers: Dict[str, int], program: List[int]) -> str:
    """"""Simulate the 3-bit computer program.

    Args:
        registers: A dictionary containing the initial register values.
        program: A list of integers representing the program instructions.

    Returns:
        A comma-separated string of values output by the 'out' instruction.
    """"""
    instruction_pointer = 0
    output = []

    while instruction_pointer < len(program):
        opcode = program[instruction_pointer]
        if instruction_pointer + 1 >= len(program):
            break
        operand = program[instruction_pointer + 1]

        if opcode == 0:
            execute_adv(registers, operand)
            instruction_pointer += 2
        elif opcode == 1:
            execute_bxl(registers, operand)
            instruction_pointer += 2
        elif opcode == 2:
            execute_bst(registers, operand)
            instruction_pointer += 2
        elif opcode == 3:
            instruction_pointer = execute_jnz(registers, operand, instruction_pointer)
        elif opcode == 4:
            execute_bxc(registers)
            instruction_pointer += 2
        elif opcode == 5:
            execute_out(registers, operand, output)
            instruction_pointer += 2
        elif opcode == 6:
            execute_bdv(registers, operand)
            instruction_pointer += 2
        elif opcode == 7:
            execute_cdv(registers, operand)
            instruction_pointer += 2
        else:
            raise ValueError(f""Invalid opcode: {opcode}"")

    return ','.join(map(str, output))


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    registers, program = parse_input(input_file)
    output = simulate_program(registers, program)
    print(output)

if __name__ == ""__main__"":
    main()
",0,[],0,"computer simulation,instruction set architecture,register machine,bitwise operations,modulo arithmetic","interpreters,finite state machines,assembly language",53.58758044242859
True,18,disable_retrieval,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
from collections import deque

def parse_input(input_file: str) -> List[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of coordinate tuples.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples [(x1, y1), (x2, y2), ...] representing the coordinates of corrupted cells.
    """"""
    corrupted_cells = []
    with open(input_file, 'r') as f:
        for i, line in enumerate(f):
            if i >= 1024:
                break
            line = line.strip()
            if not line:
                continue
            x, y = map(int, line.split(','))
            corrupted_cells.append((x, y))
    return corrupted_cells


def initialize_grid(size: int) -> List[List[bool]]:
    """"""Initialize the grid with all cells marked as safe (True).

    Args:
        size: The size of the grid (size x size).

    Returns:
        A 2D list representing the grid.
    """"""
    grid = [[True for _ in range(size)] for _ in range(size)]
    return grid


def mark_corrupted_cells(grid: List[List[bool]], corrupted_cells_list: List[Tuple[int, int]]) -> Set[Tuple[int, int]]:
    """"""Mark the corrupted cells in the grid as False and return a set of corrupted cells.

    Args:
        grid: The grid to update.
        corrupted_cells_list: A list of tuples representing the coordinates of corrupted cells.

    Returns:
        A set containing the coordinates of all corrupted cells.
    """"""
    corrupted_cells_set = set()
    for x, y in corrupted_cells_list:
        if 0 <= x < len(grid) and 0 <= y < len(grid[0]):
            grid[x][y] = False
            corrupted_cells_set.add((x, y))
    return corrupted_cells_set


def bfs(grid: List[List[bool]], start: Tuple[int, int], end: Tuple[int, int], corrupted_cells: Set[Tuple[int, int]]) -> int:
    """"""Find the shortest path from start to end using BFS.

    Args:
        grid: The grid to traverse.
        start: The starting coordinates (x, y).
        end: The destination coordinates (x, y).
        corrupted_cells: A set of tuples representing the coordinates of corrupted cells.

    Returns:
        The minimum number of steps to reach the destination, or -1 if no path exists.
    """"""
    if not grid[start[0]][start[1]]:
        return -1

    queue = deque([(start[0], start[1], 0)])
    visited = {start}

    while queue:
        x, y, distance = queue.popleft()

        if (x, y) == end:
            return distance

        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Up, Down, Right, Left

        for dx, dy in moves:
            new_x = x + dx
            new_y = y + dy

            if (0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and
                    (new_x, new_y) not in corrupted_cells and (new_x, new_y) not in visited):
                queue.append((new_x, new_y, distance + 1))
                visited.add((new_x, new_y))

    return -1


def main():
    """"""Main function to execute the solution.

    Parses the input, initializes the grid, marks corrupted cells, and runs BFS to find the shortest path.
    Prints the shortest path length to standard output.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    grid_size = 71

    corrupted_cells_list = parse_input(input_file)
    grid = initialize_grid(grid_size)
    corrupted_cells = mark_corrupted_cells(grid, corrupted_cells_list)

    start = (0, 0)
    end = (70, 70)

    shortest_path_length = bfs(grid, start, end, corrupted_cells)

    print(shortest_path_length)


if __name__ == ""__main__"":
    main()
",0,[],0,"shortest path,grid traversal,pathfinding,memory corruption,coordinate grid","Breadth-First Search (BFS),A* Search,Graph Traversal,Grid Simulation",50.10290193557739
True,19,disable_retrieval,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and designs.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of towel patterns and a list of desired designs.
    """"""
    with open(input_file, 'r') as f:
        data = f.read().strip().split('\n\n')
        patterns = [p.strip() for p in data[0].split(',')] if data else []
        designs = [d.strip() for d in data[1].split('\n')] if len(data) > 1 else []

    return patterns, designs


def is_design_possible(design: str, patterns: List[str]) -> bool:
    """"""Check if a design can be constructed from the given towel patterns.

    Args:
        design: The design to check.
        patterns: The list of available towel patterns.

    Returns:
        True if the design is possible, False otherwise.
    """"""
    dp = [False] * (len(design) + 1)
    dp[0] = True

    for i in range(1, len(design) + 1):
        for pattern in patterns:
            if len(pattern) <= i and design[i - len(pattern):i] == pattern:
                if dp[i - len(pattern)]:
                    dp[i] = True
                    break

    return dp[-1]


def solve_part_one(patterns: List[str], designs: List[str]) -> int:
    """"""Solve part one of the puzzle: count the number of possible designs.

    Args:
        patterns: The list of towel patterns.
        designs: The list of desired designs.

    Returns:
        The number of possible designs.
    """"""
    count = 0
    for design in designs:
        if is_design_possible(design, patterns):
            count += 1

    return count


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    patterns, designs = parse_input(input_file)
    part_one_solution = solve_part_one(patterns, designs)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"string manipulation,string concatenation,pattern matching","string search,dynamic programming,recursion,backtracking",40.35762691497803
False,20,disable_retrieval,,6,[],0,"grid traversal,pathfinding,optimization,shortest path,cheating,wall traversal","breadth-first search,A*,dynamic programming",208.3127646446228
False,21,disable_retrieval,,6,[],0,"shortest path,keypad,string manipulation,optimization,robotics","graph traversal,breadth-first search,dynamic programming",152.7002785205841
False,22,disable_retrieval,,6,"['The code was not following the correct order of operations in the `simulate_secret_number_generation` function. Specifically, the modulo operation `% 16777216` needs to be performed *after* steps 1, 2, 3, 4 and 6. I have added these missing modulo operations in the corrected code to ensure that the calculations are done in the right order as the problem requires. Please ensure to check for such order of operation errors in the future.']",0,"pseudorandom number generation,simulation,bitwise XOR,modulo arithmetic","Iteration,Mathematical operations,Bitwise operations",103.98546648025513
True,23,disable_retrieval,"""""""
Advent of Code 2023 Day 23: LAN Party
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set
import sys
from itertools import combinations

def parse_input(input_file: str) -> Tuple[Dict[str, Set[str]], Set[str]]:
    """"""Parse the puzzle input from file into a graph (adjacency list) and a set of computer names.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - graph: A dictionary where keys are computer names (strings) and values are sets of connected computer names (strings).
        - computers: A set of computer names.
    """"""
    graph: Dict[str, Set[str]] = {}
    computers: Set[str] = set()

    with open(input_file, 'r') as f:
        for line in f:
            computer1, computer2 = line.strip().split('-')
            computers.add(computer1)
            computers.add(computer2)

            if computer1 not in graph:
                graph[computer1] = set()
            if computer2 not in graph:
                graph[computer2] = set()

            graph[computer1].add(computer2)
            graph[computer2].add(computer1)

    return graph, computers

def is_fully_connected(graph: Dict[str, Set[str]], combination: Tuple[str, str, str]) -> bool:
    """"""Check if the three computers in a combination are fully connected (form a triangle) in the graph.

    Args:
        graph: A dictionary representing the network connections.
        combination: A tuple of three computer names.

    Returns:
        True if the computers are fully connected, False otherwise.
    """"""
    a, b, c = combination
    return b in graph[a] and c in graph[a] and c in graph[b]

def has_t_name(combination: Tuple[str, str, str]) -> bool:
    """"""Check if at least one of the computer names in the combination starts with the letter 't'.

    Args:
        combination: A tuple of three computer names.

    Returns:
        True if at least one computer name starts with 't', False otherwise.
    """"""
    for computer in combination:
        if computer.startswith('t'):
            return True
    return False

def solve_part_one(graph: Dict[str, Set[str]], computers: Set[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        graph: A dictionary representing the network connections.
        computers: A set of computer names.

    Returns:
        The number of sets of three inter-connected computers, where at least one computer's name starts with 't'.
    """"""
    triangle_count = 0
    for combination in combinations(computers, 3):
        if is_fully_connected(graph, combination) and has_t_name(combination):
            triangle_count += 1
    return triangle_count

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    graph, computers = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(graph, computers)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",1,[],0,"graph,network,set,connectivity,string manipulation","graph traversal,set theory,combination",48.17278456687927
True,24,disable_retrieval,"""""""
Advent of Code 2023 Day 24: Crossed Wires
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, Optional[int]], List[Tuple[str, str, Optional[str], str]]]:
    """"""Parse the puzzle input from file into appropriate data structures.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - wires: A dictionary to store the value of each wire (string -> integer).
        - gates: A list of tuples, where each tuple represents a gate.
                 Each tuple contains: (input_wire_1, operation, input_wire_2, output_wire).
    """"""
    wires: Dict[str, Optional[int]] = {}
    gates: List[Tuple[str, str, Optional[str], str]] = []

    with open(input_file, 'r') as f:
        lines = f.read().splitlines()

    # Parse initial wire values
    i = 0
    while i < len(lines) and lines[i] != '':
        wire_name, value = lines[i].split(': ')
        wires[wire_name] = int(value)
        i += 1

    # Parse gate definitions
    i += 1  # Skip the empty line
    while i < len(lines):
        parts = lines[i].split(' -> ')
        inputs = parts[0].split(' ')
        output_wire = parts[1]

        if len(inputs) == 3:
            input_wire_1 = inputs[0]
            operation = inputs[1]
            input_wire_2 = inputs[2]
            gates.append((input_wire_1, operation, input_wire_2, output_wire))
        elif len(inputs) == 2: # ASSIGN operation
           input_wire_1 = inputs[0]
           operation = 'ASSIGN'
           gates.append((input_wire_1, operation, None, output_wire))
        else:
          raise ValueError(f""Unexpected gate definition: {lines[i]}"")


        i += 1

    return wires, gates

def solve_part_one(wires: Dict[str, Optional[int]], gates: List[Tuple[str, str, Optional[str], str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        wires: A dictionary to store the value of each wire (string -> integer).
        gates: A list of tuples, where each tuple represents a gate.
                 Each tuple contains: (input_wire_1, operation, input_wire_2, output_wire).

    Returns:
        Solution for part one (the decimal representation of the binary number).
    """"""
    # Circuit Simulation
    changed = True
    while changed:
        changed = False
        for input_wire_1, operation, input_wire_2, output_wire in gates:
            if wires.get(output_wire) is not None:  # Skip already determined wires
                continue

            val1: Optional[int] = wires.get(input_wire_1)
            val2: Optional[int] = None
            if input_wire_2 is not None:
                val2 = wires.get(input_wire_2)

            if val1 is not None and (input_wire_2 is None or val2 is not None):
                if operation == 'AND':
                    wires[output_wire] = val1 & (val2 or 0) # Treat None as 0 if val2 is None (should never happen here)
                elif operation == 'OR':
                    wires[output_wire] = val1 | (val2 or 0)
                elif operation == 'XOR':
                    wires[output_wire] = val1 ^ (val2 or 0)
                elif operation == 'ASSIGN':
                    wires[output_wire] = val1
                else:
                    raise ValueError(f""Unknown operation: {operation}"")
                changed = True

    # Extract Z-Wire Values
    z_wires: List[int] = []
    for wire_name, value in wires.items():
        if wire_name.startswith('z'):
           z_wires.append(value if value is not None else 0) # Treat None as 0

    # Binary to Decimal Conversion
    decimal_value = 0
    z_wires.sort(key=lambda x: int(re.search(r'(\d+)$', str(x)).group(1))) # Sort z wires numerically (z0, z1, z2...)

    z_wires_values = []
    for wire_name in sorted(wires.keys()):
      if wire_name.startswith('z'):
        z_wires_values.append(wires[wire_name])

    z_wires_values = [x for x in z_wires_values if x is not None]


    if not z_wires_values:
        return 0

    for i, value in enumerate(z_wires_values):
        decimal_value += (2 ** i) * value

    return decimal_value

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    wires, gates = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(wires, gates)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"boolean logic,circuit simulation,bit manipulation,binary to decimal conversion","graph traversal,parsing,data structures (dictionaries/maps)",51.63923978805542
False,25,disable_retrieval,,6,"[""The error was in the `calculate_column_heights` function when calculating column heights for keys. The original code stopped counting '#' characters as soon as it encountered a '.' character, even if there were more '#' characters further up in the column. The fix involved removing the `break` statement within the key height calculation, ensuring that the code counts all '#' characters from the bottom up to determine the correct height. Also, I renamed the variable `type` to `schematic_type` to avoid shadowing the built-in function `type`.""]",0,"grid processing,pattern matching,lock,key,schematic","string manipulation,column-wise processing",129.3480257987976
True,1,disable_planning,"""""""
Advent of Code 2023 Day ?: Historian Hysteria
Solution implementation based on the problem statement.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers.
    """"""
    with open(input_file, 'r') as f:
        lines = f.readlines()

    list1 = []
    list2 = []

    for line in lines:
        parts = line.split()
        if len(parts) == 2:
            list1.append(int(parts[0]))
            list2.append(int(parts[1]))

    return list1, list2


def solve_part_one(list1: List[int], list2: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        list1: The first list of integers.
        list2: The second list of integers.

    Returns:
        The total distance between the two lists.
    """"""
    sorted_list1 = sorted(list1)
    sorted_list2 = sorted(list2)

    total_distance = 0
    for i in range(len(sorted_list1)):
        distance = abs(sorted_list1[i] - sorted_list2[i])
        total_distance += distance

    return total_distance


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    list1, list2 = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(list1, list2)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

    # Example usage with test cases
    # This functionality remains in place in case the prompt includes example test cases


if __name__ == ""__main__"":
    main()
",5,[],3,"list processing,sorting,absolute difference,summation","sorting,absolute value,iteration",54.81757926940918
True,2,disable_planning,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation.

Usage: python3 solution.py [input_file]
""""""

from typing import List
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a list of integer lists.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists, where each inner list represents a report
        containing integer levels.
    """"""
    reports = []
    with open(input_file, 'r') as f:
        for line in f:
            levels = [int(x) for x in line.strip().split()]
            reports.append(levels)
    return reports

def is_safe(report: List[int]) -> bool:
    """"""Check if a report is safe according to the problem rules.

    Args:
        report: A list of integers representing the levels in the report

    Returns:
        True if the report is safe, False otherwise.
    """"""
    if len(report) < 2:
        return True  # A report with 0 or 1 level is considered safe

    increasing = report[1] > report[0]

    for i in range(1, len(report)):
        diff = report[i] - report[i - 1]

        if increasing:
            if diff <= 0 or diff > 3:
                return False
        else:
            if diff >= 0 or diff < -3:
                return False

    return True


def solve_part_one(reports: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        reports: A list of reports, where each report is a list of levels.

    Returns:
        The number of safe reports.
    """"""
    safe_count = 0
    for report in reports:
        if is_safe(report):
            safe_count += 1
    return safe_count


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    reports = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(reports)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"data analysis,report analysis,sequence analysis,increasing/decreasing sequence","conditional logic,sequence comparison,numerical difference",55.24774479866028
True,3,disable_planning,"import re
import sys

def solve(s):
    """"""Scans a string for valid multiplication instructions and sums their results.

    Args:
        s: The input string containing corrupted memory.

    Returns:
        The sum of the results of all valid multiplication instructions found.
    """"""
    pattern = r'mul\((\d{1,3}),(\d{1,3})\)'
    matches = re.findall(pattern, s)
    total = 0
    for match in matches:
        try:
            x = int(match[0])
            y = int(match[1])
            if 1 <= x <= 999 and 1 <= y <= 999:
                total += x * y
        except ValueError:
            # Ignore invalid numbers
            pass
    return total


def main():
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py <input_file>"")
        return

    input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        corrupted_memory = f.read().strip()

    result = solve(corrupted_memory)
    print(result)


if __name__ == ""__main__"":
    main()
",0,[],1,"string parsing,pattern matching,arithmetic","regular expressions,string manipulation",19.822255611419678
True,4,disable_planning,"'''Advent of Code 2023 Day 4: Ceres Search
Solution implementation for finding occurrences of 'XMAS' in a 2D grid.

Usage: python3 solution.py [input_file]
'''

from typing import List
import sys

def solve(grid: List[str]) -> int:
    '''Counts the number of occurrences of 'XMAS' in the grid.

    Args:
        grid: A list of strings representing the 2D grid.

    Returns:
        The number of times 'XMAS' appears in the grid.
    '''

    count = 0
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0
    word = 'XMAS'
    word_len = len(word)

    def search(row: int, col: int, row_delta: int, col_delta: int) -> None:
        nonlocal count
        s = ''
        r, c = row, col
        for _ in range(word_len):
            if 0 <= r < rows and 0 <= c < cols:
                s += grid[r][c]
                r += row_delta
                c += col_delta
            else:
                return
        if s == word:
            count += 1
        if s == word[::-1]:
            count += 1

    for r in range(rows):
        for c in range(cols):
            search(r, c, 0, 1)  # horizontal
            search(r, c, 1, 0)  # vertical
            search(r, c, 1, 1)  # diagonal
            search(r, c, 1, -1)  # anti-diagonal

    return count


def parse_input(filename: str) -> List[str]:
    '''Parses the input file into a list of strings representing the grid.

    Args:
        filename: The path to the input file.

    Returns:
        A list of strings, where each string is a row in the grid.
    '''
    with open(filename, 'r') as f:
        return [line.strip() for line in f.readlines()]


def main():
    if len(sys.argv) < 2:
        print('Usage: python3 solution.py <input_file>')
        sys.exit(1)

    input_file = sys.argv[1]
    grid = parse_input(input_file)
    result = solve(grid)
    print(result)


if __name__ == '__main__':
    main()",0,[],3,"string search,grid traversal,pattern matching,2D array","string manipulation,brute force search",43.64240789413452
True,5,disable_planning,"""""""
Advent of Code 2023 Day 5: Print Queue
Solution implementation.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys

def parse_input(input_file: str) -> Tuple[List[Tuple[int, int]], List[List[int]]]:
    """"""Parse the puzzle input from file. Returns a tuple containing the rules and updates.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing a list of rules (tuples of ints) and a list of updates (lists of ints).
    """"""
    with open(input_file, 'r') as f:
        data = f.read().strip().split('\n\n')

    rules = []
    for line in data[0].splitlines():
        x, y = map(int, line.split('|'))
        rules.append((x, y))

    updates = []
    for line in data[1].splitlines():
        update = list(map(int, line.split(',')))
        updates.append(update)

    return rules, updates


def is_correct_order(update: List[int], rules: List[Tuple[int, int]]) -> bool:
    """"""Checks if an update is in the correct order according to the rules.

    Args:
        update: A list of integers representing the page numbers in the update.
        rules: A list of tuples representing the ordering rules.

    Returns:
        True if the update is in the correct order, False otherwise.
    """"""
    for rule in rules:
        x, y = rule
        if x in update and y in update:
            if update.index(x) > update.index(y):
                return False
    return True


def solve(rules: List[Tuple[int, int]], updates: List[List[int]]) -> int:
    """"""Solves the puzzle by summing the middle page numbers of correctly-ordered updates.

    Args:
        rules: A list of tuples representing the ordering rules.
        updates: A list of lists representing the updates.

    Returns:
        The sum of the middle page numbers of the correctly-ordered updates.
    """"""
    total_middle_pages = 0
    for update in updates:
        if is_correct_order(update, rules):
            middle_index = (len(update) - 1) // 2  # Integer division to handle both even and odd lengths
            total_middle_pages += update[middle_index]

    return total_middle_pages


def main():
    """"""Main function to parse input, solve the puzzle, and print the result.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    rules, updates = parse_input(input_file)
    result = solve(rules, updates)

    print(result)

if __name__ == ""__main__"":
    main()
",0,[],3,"ordering,precedence,sequencing,printing,validation","graph traversal,topological sort,rule validation",45.95738863945007
False,6,disable_planning,,6,[],3,"grid simulation,pathfinding,guard patrol,state machine","simulation,coordinate manipulation,conditional logic",75.0740315914154
True,7,disable_planning,"'''Advent of Code 2023 Day 7: Bridge Repair
Solution implementation.

Usage: python3 solution.py [input_file]
'''

import sys
from typing import List


def solve_equation(target: int, numbers: List[int]) -> bool:
    '''Determines if the equation can be made true by inserting '+' or '*'.

    Args:
        target: The target value of the equation.
        numbers: The list of numbers in the equation.

    Returns:
        True if the equation can be made true, False otherwise.
    '''

    def evaluate(index: int, current_value: int) -> bool:
        '''Recursively evaluates the equation with different operator combinations.

        Args:
            index: The current index of the number being processed.
            current_value: The current value of the equation.

        Returns:
            True if the equation can be made true, False otherwise.
        '''
        if index == len(numbers):
            return current_value == target

        # Try addition
        if evaluate(index + 1, current_value + numbers[index]):
            return True

        # Try multiplication
        if evaluate(index + 1, current_value * numbers[index]):
            return True

        return False

    return evaluate(1, numbers[0])


def parse_input(filename: str) -> List[tuple[int, List[int]]]:
    '''Parses the input file into a list of (target, numbers) tuples.

    Args:
        filename: The path to the input file.

    Returns:
        A list of tuples, where each tuple contains the target value and the list of numbers.
    '''
    equations = []
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            target, numbers_str = line.split(':')
            target = int(target)
            numbers = [int(num) for num in numbers_str.split()]
            equations.append((target, numbers))
    return equations


def main():
    '''Main function to solve the puzzle.'''
    if len(sys.argv) < 2:
        print('Usage: python3 solution.py [input_file]')
        return

    input_file = sys.argv[1]
    equations = parse_input(input_file)

    total_calibration_result = 0
    for target, numbers in equations:
        if solve_equation(target, numbers):
            total_calibration_result += target

    print(total_calibration_result)


if __name__ == '__main__':
    main()",0,[],3,"arithmetic,expression evaluation,combinatorics,backtracking","recursion,depth-first search,operator precedence (absence of)",41.89740347862244
True,8,disable_planning,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation from scratch.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
import math

def parse_input(input_file: str) -> List[str]:
    """"""Parse the puzzle input from file into a list of strings (rows).

    Args:
        input_file: Path to the input file

    Returns:
        List of strings representing the rows of the map.
    """"""
    with open(input_file, 'r') as f:
        return [line.strip() for line in f]

def find_antennas(grid: List[str]) -> List[Tuple[int, int, str]]:
    """"""Find the coordinates and frequencies of all antennas in the grid.

    Args:
        grid: List of strings representing the antenna map.

    Returns:
        A list of tuples, where each tuple contains the row index, column index,
        and frequency of an antenna.
    """"""
    antennas = []
    for r, row in enumerate(grid):
        for c, char in enumerate(row):
            if char != '.':
                antennas.append((r, c, char))
    return antennas

def calculate_antinodes(grid: List[str], antennas: List[Tuple[int, int, str]]) -> Set[Tuple[int, int]]:
    """"""Calculate the locations of antinodes based on the antenna positions and frequencies.

    Args:
        grid: List of strings representing the antenna map.
        antennas: List of antenna tuples (row, col, frequency).

    Returns:
        A set of tuples representing the unique coordinates of antinodes.
    """"""
    antinodes: Set[Tuple[int, int]] = set()
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    for i in range(len(antennas)):
        for j in range(i + 1, len(antennas)):
            r1, c1, freq1 = antennas[i]
            r2, c2, freq2 = antennas[j]

            if freq1 == freq2:
                # Calculate possible antinode locations
                # Antinode 1:  a -- x -- b (x is 1/2 dist from a)
                # Antinode 2:  a -- b -- x (b is 1/2 dist from x)

                # Antinode 1
                dr = r2 - r1
                dc = c2 - c1
                r_anti1 = r1 - dr
                c_anti1 = c1 - dc

                # Antinode 2
                r_anti2 = r2 + dr
                c_anti2 = c2 + dc


                if 0 <= r_anti1 < rows and 0 <= c_anti1 < cols:
                    antinodes.add((r_anti1, c_anti1))
                if 0 <= r_anti2 < rows and 0 <= c_anti2 < cols:
                    antinodes.add((r_anti2, c_anti2))

    return antinodes


def solve_part_one(grid: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: List of strings representing the antenna map.

    Returns:
        The number of unique locations containing an antinode.
    """"""
    antennas = find_antennas(grid)
    antinodes = calculate_antinodes(grid, antennas)
    return len(antinodes)


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(grid)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"grid,geometry,collinearity,distance calculation,spatial reasoning","Euclidean distance,Line equation,Point-line relationship,Coordinate Geometry",65.56308197975159
False,9,disable_planning,,6,[],1,"string manipulation,disk compaction,checksum,simulation","parsing,simulation,arithmetic",70.90919899940491
True,10,disable_planning,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a 2D list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list representing the topographic map.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append([int(x) for x in line.strip()])
    return grid

def find_trailheads(grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Find all trailhead coordinates (positions with height 0).

    Args:
        grid: The topographic map.

    Returns:
        A list of (row, col) tuples representing the trailhead coordinates.
    """"""
    trailheads = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0:
                trailheads.append((r, c))
    return trailheads


def get_neighbors(row: int, col: int, grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Get valid neighbors (up, down, left, right) of a given cell.

    Args:
        row: The row index of the cell.
        col: The column index of the cell.
        grid: The topographic map.

    Returns:
        A list of (row, col) tuples representing the valid neighbors.
    """"""
    neighbors = []
    rows = len(grid)
    cols = len(grid[0])
    current_height = grid[row][col]

    # Up
    if row > 0 and grid[row - 1][col] == current_height + 1:
        neighbors.append((row - 1, col))
    # Down
    if row < rows - 1 and grid[row + 1][col] == current_height + 1:
        neighbors.append((row + 1, col))
    # Left
    if col > 0 and grid[row][col - 1] == current_height + 1:
        neighbors.append((row, col - 1))
    # Right
    if col < cols - 1 and grid[row][col + 1] == current_height + 1:
        neighbors.append((row, col + 1))

    return neighbors


def count_reachable_nines(grid: List[List[int]], start_row: int, start_col: int) -> int:
    """"""Count the number of reachable '9's from a given trailhead.

    Args:
        grid: The topographic map.
        start_row: The row index of the trailhead.
        start_col: The column index of the trailhead.

    Returns:
        The number of reachable '9's.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    visited = set()
    reachable_nines = 0
    queue = [(start_row, start_col)]
    visited.add((start_row, start_col))

    while queue:
        row, col = queue.pop(0)

        if grid[row][col] == 9:
            reachable_nines += 1

        neighbors = get_neighbors(row, col, grid)
        for neighbor_row, neighbor_col in neighbors:
            if (neighbor_row, neighbor_col) not in visited:
                visited.add((neighbor_row, neighbor_col))
                queue.append((neighbor_row, neighbor_col))

    return reachable_nines


def solve(grid: List[List[int]]) -> int:
    """"""Solve the puzzle: Calculate the sum of the scores of all trailheads.

    Args:
        grid: The topographic map.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    trailheads = find_trailheads(grid)
    total_score = 0
    for row, col in trailheads:
        total_score += count_reachable_nines(grid, row, col)
    return total_score


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid = parse_input(input_file)

    # Solve the puzzle
    solution = solve(grid)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"grid traversal,pathfinding,topographic map,reachability,depth-first search,breadth-first search","graph traversal,connectivity,recursion,matrix manipulation",33.27704358100891
True,11,disable_planning,"'''Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the problem description.

Usage: python3 solution.py [input_file]
'''

from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        List of integers representing the initial state of the stones.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        return [int(x) for x in line.split()]


def evolve_stones(stones: List[int], iterations: int) -> List[int]:
    """"""Simulates the evolution of the stones over the specified number of iterations.

    Args:
        stones: Initial list of stones.
        iterations: Number of iterations to simulate.

    Returns:
        The final list of stones after the iterations.
    """"""
    for _ in range(iterations):
        new_stones: List[int] = []
        for stone in stones:
            if stone == 0:
                new_stones.append(1)
            elif len(str(stone)) % 2 == 0:
                s_stone = str(stone)
                mid = len(s_stone) // 2
                left = int(s_stone[:mid])
                right = int(s_stone[mid:])
                new_stones.append(left)
                new_stones.append(right)
            else:
                new_stones.append(stone * 2024)
        stones = new_stones
    return stones


def solve_part_one(initial_stones: List[int], iterations: int) -> int:
    """"""Solves part one of the puzzle by simulating the stone evolution and returning the final count.

    Args:
        initial_stones: The initial state of the stones.
        iterations: The number of iterations to simulate.

    Returns:
        The total number of stones after the specified number of iterations.
    """"""
    final_stones = evolve_stones(initial_stones, iterations)
    return len(final_stones)


def main():
    """"""Main function to execute the solution.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    initial_stones = parse_input(input_file)

    part_one_solution = solve_part_one(initial_stones, 25)
    print(part_one_solution)

if __name__ == ""__main__"":
    main()",0,[],3,"simulation,number manipulation,string manipulation,iteration","string conversion,integer arithmetic,list manipulation",39.72090744972229
True,12,disable_planning,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> List[str]:
    """"""Parse the puzzle input from file into a list of strings, where each string is a row in the grid.

    Args:
        input_file: Path to the input file

    Returns:
        A list of strings representing the grid.
    """"""
    with open(input_file, 'r') as f:
        return [line.strip() for line in f]


def calculate_region_data(grid: List[str], visited: Set[Tuple[int, int]], row: int, col: int) -> Tuple[int, int]:
    """"""Calculate the area and perimeter of a region using depth-first search.

    Args:
        grid: The grid of characters.
        visited: A set to keep track of visited cells.
        row: The starting row of the region.
        col: The starting column of the region.

    Returns:
        A tuple containing the area and perimeter of the region.
    """"""
    area = 0
    perimeter = 0
    stack = [(row, col)]
    plant_type = grid[row][col]
    rows = len(grid)
    cols = len(grid[0])

    while stack:
        r, c = stack.pop()
        if (r, c) in visited:
            continue
        visited.add((r, c))
        area += 1

        # Check neighbors
        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]
        for nr, nc in neighbors:
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr][nc] == plant_type:
                    stack.append((nr, nc))
                else:
                    perimeter += 1
            else:
                perimeter += 1  # Edge of the grid

    return area, perimeter


def solve_part_one(grid: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: A list of strings representing the garden plot.

    Returns:
        The total price of fencing all regions.
    """"""
    total_price = 0
    visited = set()
    rows = len(grid)
    if rows == 0: # handle edge case of empty grid
        return 0
    cols = len(grid[0])

    for r in range(rows):
        for c in range(cols):
            if (r, c) not in visited:
                area, perimeter = calculate_region_data(grid, visited, r, c)
                total_price += area * perimeter

    return total_price


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"grid,region identification,area calculation,perimeter calculation,connected components,simulation","depth-first search,breadth-first search,graph traversal,flood fill",34.308820962905884
True,13,disable_planning,"""""""
Advent of Code 2023 Day 13: Claw Contraption
Solution implementation.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple
import sys
import re
from math import inf


def parse_input(input_file: str) -> List[Dict[str, Tuple[int, int]]]:
    """"""Parse the puzzle input from file into a list of claw machine descriptions.

    Args:
        input_file: Path to the input file

    Returns:
        A list where each element is a dictionary containing the button A, button B,
        and prize coordinates as tuples of integers.
    """"""
    machines = []
    with open(input_file, 'r') as f:
        machine_data = f.read().strip().split('\n\n')
        for machine_str in machine_data:
            lines = machine_str.splitlines()
            machine = {}
            machine['A'] = tuple(map(int, re.findall(r'[+-]?\d+', lines[0])))
            machine['B'] = tuple(map(int, re.findall(r'[+-]?\d+', lines[1])))
            machine['Prize'] = tuple(map(int, re.findall(r'[+-]?\d+', lines[2])))
            machines.append(machine)
    return machines


def solve_machine(machine: Dict[str, Tuple[int, int]]) -> int:
    """"""Solve for a single claw machine.

    Args:
        machine: A dictionary describing the machine.

    Returns:
        The minimum cost to win the prize, or infinity if impossible.
    """"""
    a_x, a_y = machine['A']
    b_x, b_y = machine['B']
    target_x, target_y = machine['Prize']

    min_cost = inf

    for num_a in range(101):
        for num_b in range(101):
            if (a_x * num_a + b_x * num_b == target_x) and (a_y * num_a + b_y * num_b == target_y):
                cost = num_a * 3 + num_b * 1
                min_cost = min(min_cost, cost)

    return min_cost


def solve_part_one(machines: List[Dict[str, Tuple[int, int]]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        machines: A list of machine descriptions.

    Returns:
        The minimum cost to win the maximum number of prizes.
    """"""
    wins = 0
    total_cost = 0
    costs = []
    for machine in machines:
        cost = solve_machine(machine)
        costs.append(cost)

    winning_costs = [cost for cost in costs if cost != inf]

    wins = len(winning_costs)
    total_cost = sum(winning_costs)
    return total_cost


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    machines = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(machines)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()",2,[],2,"linear equations,optimization,integer solutions","Diophantine equations,linear programming,brute force,system of equations",40.57732677459717
True,14,disable_planning,"'''Advent of Code 2023 Day 14: Restroom Redoubt
Solution implementation.

Usage: python3 solution.py [input_file]
'''

import sys
from typing import List, Tuple


def parse_input(filename: str) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
    """"""Parses the input file into a list of robots with their positions and velocities.

    Args:
        filename (str): The path to the input file.

    Returns:
        List[Tuple[Tuple[int, int], Tuple[int, int]]]: A list where each element is a tuple representing a robot.
                                                    The first element of the tuple is the robot's initial position (x, y),
                                                    and the second element is the robot's velocity (x, y).
    """"""
    robots = []
    with open(filename, 'r') as f:
        for line in f:
            parts = line.strip().split()
            pos_str = parts[0].split('=')[1]
            vel_str = parts[1].split('=')[1]
            pos_x, pos_y = map(int, pos_str.split(','))
            vel_x, vel_y = map(int, vel_str.split(','))
            robots.append(((pos_x, pos_y), (vel_x, vel_y)))
    return robots


def simulate_robots(robots: List[Tuple[Tuple[int, int], Tuple[int, int]]], time: int, width: int, height: int) -> List[Tuple[int, int]]:
    """"""Simulates the movement of robots for a given time.

    Args:
        robots (List[Tuple[Tuple[int, int], Tuple[int, int]]]): A list of robots with their initial positions and velocities.
        time (int): The duration of the simulation in seconds.
        width (int): The width of the grid.
        height (int): The height of the grid.

    Returns:
        List[Tuple[int, int]]: A list of the final positions (x, y) of the robots after the simulation.
    """"""
    final_positions = []
    for robot in robots:
        pos_x, pos_y = robot[0]
        vel_x, vel_y = robot[1]
        final_x = (pos_x + vel_x * time) % width
        final_y = (pos_y + vel_y * time) % height
        final_positions.append((final_x, final_y))
    return final_positions


def count_robots_in_quadrants(positions: List[Tuple[int, int]], width: int, height: int) -> Tuple[int, int, int, int]:
    """"""Counts the number of robots in each quadrant.

    Args:
        positions (List[Tuple[int, int]]): A list of robot positions (x, y).
        width (int): The width of the grid.
        height (int): The height of the grid.

    Returns:
        Tuple[int, int, int, int]: A tuple containing the number of robots in each quadrant (Q1, Q2, Q3, Q4).
                                  Quadrants are numbered as follows:
                                  Q1: Top-right
                                  Q2: Top-left
                                  Q3: Bottom-left
                                  Q4: Bottom-right
    """"""
    mid_x = width // 2
    mid_y = height // 2
    q1, q2, q3, q4 = 0, 0, 0, 0
    for x, y in positions:
        if x > mid_x and y < mid_y:
            q1 += 1
        elif x < mid_x and y < mid_y:
            q2 += 1
        elif x < mid_x and y > mid_y:
            q3 += 1
        elif x > mid_x and y > mid_y:
            q4 += 1
    return q1, q2, q3, q4


def main():
    """"""Main function to solve the problem.

    Parses the input, simulates the robots' movements, counts the robots in each quadrant,
    and prints the product of the counts.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    robots = parse_input(input_file)

    # Determine grid size based on the input (example or full)
    if len(robots) <= 12:  # Example case
        width = 11
        height = 7
    else:  # Full input case
        width = 101
        height = 103

    time = 100
    final_positions = simulate_robots(robots, time, width, height)
    q1, q2, q3, q4 = count_robots_in_quadrants(final_positions, width, height)

    safety_factor = q1 * q2 * q3 * q4
    print(safety_factor)


if __name__ == ""__main__"":
    main()
",1,[],2,"grid simulation,robot movement,quadrant counting,wraparound,coordinate manipulation","modular arithmetic,simulation,counting",43.90731382369995
False,15,disable_planning,,6,"[""The robot is only moving boxes into empty spaces ('.'). However, if the robot pushes the box to a location where another box is placed ('O'), then it needs to ignore the move. You need to modify the `simulate_moves` function to check if the target location has another box before clearing out the original location. Add a condition to check for this scenario within the box pushing logic of the `simulate_moves` function. If the box cannot be pushed, then the robot should not move to the new location and neither of the original robot and box location should be replaced by a '.'.""]",2,"robot simulation,warehouse,box pushing,grid,GPS coordinates","simulation,coordinate geometry,state update",97.07061100006104
False,16,disable_planning,,6,"[""The code returns -1 because it doesn't find the end. The problem is that the `end` variable only stores the row and column, while the `start` variable and the `visited` set store a tuple of (row, col, direction). Thus, the check `if (row, col) == end:` is insufficient, because it does not consider the direction.  To fix this, initialize `end` to be a tuple `(row, col, 0)` when reading it from the maze. Then, change the end condition to `if (row, col, direction) == end:`. This ensures that the direction is also checked when determining if the end has been reached."", 'The issue was that the direction of the end tile was being considered when calculating the minimum cost path. The end tile should not consider direction. Therefore, I removed direction from the end tile to solve the problem.']",3,"maze,pathfinding,grid,minimum cost,search","graph traversal,breadth-first search,A*,state space search",103.1039731502533
True,17,disable_planning,"""""""
Advent of Code 2023 Day 17: Chronospatial Computer
Solution implementation based on the problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[int]]:
    """"""Parse the puzzle input from file into initial register values and program.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A dictionary mapping register names ('A', 'B', 'C') to their initial values.
        - A list of integers representing the program.
    """"""
    registers = {}
    program_str = """"

    with open(input_file, 'r') as f:
        for line in f:
            if line.startswith(""Register A:""):
                registers['A'] = int(line.split("":"")[1].strip())
            elif line.startswith(""Register B:""):
                registers['B'] = int(line.split("":"")[1].strip())
            elif line.startswith(""Register C:""):
                registers['C'] = int(line.split("":"")[1].strip())
            elif line.startswith(""Program:""):
                program_str = line.split("":"")[1].strip()

    program = [int(x) for x in program_str.split(',')] if program_str else []

    return registers, program

def solve_part_one(registers: Dict[str, int], program: List[int]) -> str:
    """"""Solve part one of the puzzle.

    Args:
        registers: A dictionary of initial register values.
        program: A list of integers representing the program.

    Returns:
        A comma-separated string of output values.
    """"""
    instruction_pointer = 0
    output = []

    while instruction_pointer < len(program):
        opcode = program[instruction_pointer]
        if instruction_pointer + 1 >= len(program):
            break # Halt if no operand
        operand = program[instruction_pointer + 1]

        if opcode == 0:  # adv
            denominator = 2 ** get_combo_operand_value(operand, registers)
            registers['A'] = registers['A'] // denominator
            instruction_pointer += 2
        elif opcode == 1:  # bxl
            registers['B'] = registers['B'] ^ operand
            instruction_pointer += 2
        elif opcode == 2:  # bst
            registers['B'] = get_combo_operand_value(operand, registers) % 8
            instruction_pointer += 2
        elif opcode == 3:  # jnz
            if registers['A'] != 0:
                instruction_pointer = operand
            else:
                instruction_pointer += 2
        elif opcode == 4:  # bxc
            registers['B'] = registers['B'] ^ registers['C']
            instruction_pointer += 2
        elif opcode == 5:  # out
            output_value = get_combo_operand_value(operand, registers) % 8
            output.append(str(output_value))
            instruction_pointer += 2
        elif opcode == 6:  # bdv
            denominator = 2 ** get_combo_operand_value(operand, registers)
            registers['B'] = registers['A'] // denominator
            instruction_pointer += 2
        elif opcode == 7:  # cdv
            denominator = 2 ** get_combo_operand_value(operand, registers)
            registers['C'] = registers['A'] // denominator
            instruction_pointer += 2
        else:
            break  # Invalid opcode

    return ','.join(output)


def get_combo_operand_value(operand: int, registers: Dict[str, int]) -> int:
    """"""Get the value of a combo operand.

    Args:
        operand: The operand value.
        registers: A dictionary of register values.

    Returns:
        The value of the combo operand.
    """"""
    if 0 <= operand <= 3:
        return operand
    elif operand == 4:
        return registers['A']
    elif operand == 5:
        return registers['B']
    elif operand == 6:
        return registers['C']
    else:
        return 0  # Should not happen, according to the problem description


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    registers, program = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(registers, program)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],1,"computer simulation,instruction set,registers,program execution,assembly-like language,bitwise operations","finite state machine,interpreter,modular arithmetic,bitwise XOR,integer division,conditional jump",26.679601907730103
True,18,disable_planning,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation using BFS to find the shortest path.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Deque
import sys
from collections import deque

def parse_input(input_file: str) -> List[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a list of coordinates.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple represents a corrupted coordinate (x, y).
    """"""
    corrupted_coords = []
    with open(input_file, 'r') as f:
        for line in f:
            x, y = map(int, line.strip().split(','))
            corrupted_coords.append((x, y))
    return corrupted_coords


def solve_part_one(corrupted_coords: List[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle using Breadth-First Search (BFS).

    Args:
        corrupted_coords: A list of tuples representing corrupted coordinates.

    Returns:
        The minimum number of steps to reach (70, 70) from (0, 0), or -1 if no path exists.
    """"""
    grid_size = 71  # Grid is 71x71 (0-70 inclusive)
    start = (0, 0)
    end = (70, 70)

    # Create a set of corrupted coordinates for efficient lookup
    corrupted_set = set(corrupted_coords[:1024]) #consider only first 1024

    # Initialize BFS
    queue: Deque[Tuple[int, int, int]] = deque([(0, 0, 0)])  # (x, y, steps)
    visited = set()
    visited.add((0,0))

    # Possible movements (up, down, left, right)
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        x, y, steps = queue.popleft()

        if (x, y) == end:
            return steps

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            # Check boundaries and if the new coordinate is corrupted
            if (0 <= nx < grid_size and 0 <= ny < grid_size and
                (nx, ny) not in corrupted_set and (nx,ny) not in visited):
                queue.append((nx, ny, steps + 1))
                visited.add((nx,ny))

    return -1  # No path found


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"shortest path,grid traversal,simulation,coordinate system,pathfinding,breadth-first search","Breadth-First Search (BFS),Graph Traversal,2D Grid,Coordinate Manipulation",24.80879545211792
False,19,disable_planning,,6,[],3,"string manipulation,string matching,concatenation","string decomposition,pattern matching",61.590505599975586
False,20,disable_planning,,6,[],1,"grid traversal,shortest path,pathfinding,cheat detection,optimization","breadth-first search,A* search,dynamic programming,graph algorithms",61.64703679084778
False,21,disable_planning,,6,[],2,"keypad navigation,shortest path,string manipulation,robot control,code complexity","graph traversal,breadth-first search,dynamic programming",52.15789556503296
True,22,disable_planning,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the problem description.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def generate_secret_number(secret: int) -> int:
    """"""Generates the next secret number in the sequence.

    Args:
        secret: The current secret number.

    Returns:
        The next secret number in the sequence.
    """"""
    # Step 1
    val = secret * 64
    secret ^= val
    secret %= 16777216

    # Step 2
    val = secret // 32
    secret ^= val
    secret %= 16777216

    # Step 3
    val = secret * 2048
    secret ^= val
    secret %= 16777216

    return secret


def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial secret numbers for each buyer.
    """"""
    secrets = []
    with open(input_file, 'r') as f:
        for line in f:
            secrets.append(int(line.strip()))
    return secrets


def solve(secrets: List[int]) -> int:
    """"""Solves the puzzle by simulating the secret number generation and summing the 2000th numbers.

    Args:
        secrets: A list of initial secret numbers for each buyer.

    Returns:
        The sum of the 2000th secret number generated by each buyer.
    """"""
    total_sum = 0
    for initial_secret in secrets:
        secret = initial_secret
        for _ in range(2000):
            secret = generate_secret_number(secret)
        total_sum += secret
    return total_sum


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    secrets = parse_input(input_file)
    result = solve(secrets)
    print(result)


if __name__ == ""__main__"":
    main()
",0,[],2,"pseudorandom number generator,simulation,bitwise XOR,modulo,sequence generation","iteration,arithmetic operations,bitwise operations",21.997686624526978
True,23,disable_planning,"'''Advent of Code 2023 Day 23: LAN Party
Solution implementation from scratch.

Usage: python3 solution.py [input_file]'''

import sys
from typing import List, Set, Tuple
from collections import defaultdict

def parse_input(filename: str) -> defaultdict[str, Set[str]]:
    '''Parses the input file into an adjacency list.

    Args:
        filename (str): The path to the input file.

    Returns:
        defaultdict[str, Set[str]]: An adjacency list representing the graph.
    '''
    graph = defaultdict(set)
    with open(filename, 'r') as f:
        for line in f:
            computer1, computer2 = line.strip().split('-')
            graph[computer1].add(computer2)
            graph[computer2].add(computer1)
    return graph


def find_triangles_with_t(graph: defaultdict[str, Set[str]]) -> int:
    '''Finds the number of triangles in the graph that contain at least one node starting with 't'.

    Args:
        graph (defaultdict[str, Set[str]]): An adjacency list representing the graph.

    Returns:
        int: The number of triangles with at least one 't'.
    '''
    count = 0
    nodes = list(graph.keys())
    n = len(nodes)

    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                node1, node2, node3 = nodes[i], nodes[j], nodes[k]
                if node2 in graph[node1] and node3 in graph[node1] and node3 in graph[node2]:
                    if node1.startswith('t') or node2.startswith('t') or node3.startswith('t'):
                        count += 1
    return count


def main():
    '''Main function to solve the problem.'''
    if len(sys.argv) < 2:
        print('Usage: python3 solution.py <input_file>')
        return

    input_file = sys.argv[1]
    graph = parse_input(input_file)
    result = find_triangles_with_t(graph)
    print(result)


if __name__ == '__main__':
    main()",0,[],2,"graph theory,network analysis,triangle counting,string processing","graph representation,adjacency matrix/list,set theory,string prefix matching",22.91480803489685
True,24,disable_planning,"""""""
Advent of Code 2023 Day 24: Crossed Wires
Solution implementation based on the problem statement.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> Tuple[Dict[str, int], List[Tuple[str, str, str, str]]]:
    """"""Parse the puzzle input from file into initial wire values and gate connections.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
        - A dictionary of wire names and their initial values (0 or 1).
        - A list of gate connections represented as tuples: (input_wire1, gate_type, input_wire2, output_wire).
    """"""
    initial_values = {}
    gate_connections = []

    with open(input_file, 'r') as f:
        lines = f.read().splitlines()

    # Parse initial values
    i = 0
    while ':' in lines[i]:
        line = lines[i]
        wire, value = line.split(': ') #Splitting on the colon and space
        initial_values[wire] = int(value)
        i += 1

    i += 1  # Skip the empty line

    # Parse gate connections
    while i < len(lines):
        line = lines[i]
        parts = line.split()
        input_wire1 = parts[0]
        gate_type = parts[1]
        input_wire2 = parts[2]
        output_wire = parts[4]
        gate_connections.append((input_wire1, gate_type, input_wire2, output_wire))
        i += 1

    return initial_values, gate_connections

def simulate_circuit(initial_values: Dict[str, int], gate_connections: List[Tuple[str, str, str, str]]) -> Dict[str, int]:
    """"""Simulate the boolean logic circuit.

    Args:
        initial_values: A dictionary of wire names and their initial values.
        gate_connections: A list of gate connections represented as tuples.

    Returns:
        A dictionary of wire names and their final values after simulation.
    """"""
    wire_values = initial_values.copy()

    # Simulate the circuit until no more changes occur
    changed = True
    while changed:
        changed = False
        for input_wire1, gate_type, input_wire2, output_wire in gate_connections:
            if input_wire1 in wire_values and input_wire2 in wire_values and output_wire not in wire_values:
                val1 = wire_values[input_wire1]
                val2 = wire_values[input_wire2]
                if gate_type == 'AND':
                    output_value = val1 & val2
                elif gate_type == 'OR':
                    output_value = val1 | val2
                elif gate_type == 'XOR':
                    output_value = val1 ^ val2
                else:
                    raise ValueError(f""Unknown gate type: {gate_type}"")

                wire_values[output_wire] = output_value
                changed = True

    return wire_values

def calculate_decimal_value(wire_values: Dict[str, int]) -> int:
    """"""Calculate the decimal representation of the binary number formed by 'z' wires.

    Args:
        wire_values: A dictionary of wire names and their final values.

    Returns:
        The decimal representation of the binary number.
    """"""
    binary_string = """"
    i = 0
    while f'z{i:02d}' in wire_values:
        binary_string = str(wire_values[f'z{i:02d}']) + binary_string
        i += 1

    if not binary_string:
        return 0

    return int(binary_string, 2)

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_values, gate_connections = parse_input(input_file)

    # Simulate the circuit
    final_wire_values = simulate_circuit(initial_values, gate_connections)

    # Calculate the decimal value
    decimal_value = calculate_decimal_value(final_wire_values)

    # Print the result
    print(decimal_value)


if __name__ == ""__main__"":
    main()
",0,[],2,"boolean logic,circuit simulation,binary conversion,gate simulation","graph traversal,topological sort,parsing",34.27280879020691
False,25,disable_planning,,6,"['The code was incorrectly calculating the number of matching pairs due to not removing duplicates. The lock and keys are converted to a set to ensure no duplicates exist when creating the lock_heights and key_heights.\nAdditionally, the key_heights were calculated in an incorrect way by using a dictionary. The `key_heights` were precalculated and placed in a dictionary. This is unnecessary and resulted in the keys being incorrectly matched.\n', 'The code iterates through all locks and keys and checks if they fit. The logic itself is correct; however, the performance is terrible. A better implementation would reduce the number of checks and comparisons. Currently, it calculates all possible lock-key pairs and then iterates through the result. This results in a time complexity of O(number of locks * number of keys). This can be optimized, but since this is the original code that the problem produced I will leave this alone for now.']",1,"string manipulation,pattern recognition,pairwise comparison,text processing","parsing,conditional logic,iteration",89.1942081451416
True,1,disable_debugging,"""""""
Advent of Code 2023 Day 1?: Historian Hysteria
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> tuple[List[int], List[int]]:
    """"""Parse the puzzle input from file into two lists of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing two lists of integers, list1 and list2.
    """"""
    list1: List[int] = []
    list2: List[int] = []
    with open(input_file, 'r') as f:
        for line in f:
            nums = line.split()
            list1.append(int(nums[0]))
            list2.append(int(nums[1]))
    return list1, list2

def solve_part_one(list1: List[int], list2: List[int]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        list1: The first list of integers.
        list2: The second list of integers.

    Returns:
        The total sum of the absolute differences between paired numbers.
    """"""
    sorted_list1 = sorted(list1)
    sorted_list2 = sorted(list2)
    total_distance = 0
    for num1, num2 in zip(sorted_list1, sorted_list2):
        total_distance += abs(num1 - num2)
    return total_distance

def main():
    """"""Main function to execute the solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    list1, list2 = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(list1, list2)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"list manipulation,sorting,absolute difference,summation","sorting algorithms,absolute value,iterative summation",50.871607065200806
True,2,disable_debugging,"""""""
Advent of Code 2023 Day 2: Red-Nosed Reports
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> List[str]:
    """"""Parse the puzzle input from file into a list of strings, where each string is a report.

    Args:
        input_file: Path to the input file

    Returns:
        List of strings, where each string is a report.
    """"""
    try:
        with open(input_file, 'r') as f:
            return [line.strip() for line in f]
    except FileNotFoundError:
        print(f""Error: File not found: {input_file}"", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f""Error reading file: {e}"", file=sys.stderr)
        sys.exit(1)


def parse_levels(report: str) -> List[int]:
    """"""Parse the levels (numbers) within a single report string.

    Args:
        report: A report string (e.g., \""1 2 3 4 5\"").

    Returns:
        A list of integers representing the levels.
    """"""
    try:
        return [int(level) for level in report.split()]
    except ValueError:
        print(f""Error: Invalid level in report: {report}"", file=sys.stderr)
        return []  # Or raise an exception, depending on desired behavior


def check_increasing(levels: List[int]) -> bool:
    """"""Check if the levels are strictly increasing and the difference between adjacent levels is between 1 and 3.

    Args:
        levels: List of integers (levels).

    Returns:
        True if increasing and differences are valid, False otherwise.
    """"""
    if len(levels) < 2:
        return False
    for i in range(len(levels) - 1):
        if not (levels[i] < levels[i + 1] and 1 <= abs(levels[i + 1] - levels[i]) <= 3):
            return False
    return True


def check_decreasing(levels: List[int]) -> bool:
    """"""Check if the levels are strictly decreasing and the difference between adjacent levels is between 1 and 3.

    Args:
        levels: List of integers (levels).

    Returns:
        True if decreasing and differences are valid, False otherwise.
    """"""
    if len(levels) < 2:
        return False
    for i in range(len(levels) - 1):
        if not (levels[i] > levels[i + 1] and 1 <= abs(levels[i + 1] - levels[i]) <= 3):
            return False
    return True


def is_safe_report(levels: List[int]) -> bool:
    """"""Determine if the report is safe (either strictly increasing or strictly decreasing with valid differences).

    Args:
        levels: List of integers (levels).

    Returns:
        True if safe, False otherwise.
    """"""
    return check_increasing(levels) or check_decreasing(levels)


def solve_part_one(reports: List[str]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        reports: List of report strings.

    Returns:
        Solution for part one (number of safe reports)
    """"""
    safe_report_count = 0
    for report in reports:
        levels = parse_levels(report)
        if levels and is_safe_report(levels):
            safe_report_count += 1
    return safe_report_count


def main():
    """"""Main function to solve the puzzle.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    reports = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(reports)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"data analysis,sequence analysis,report validation,increasing sequence,decreasing sequence","conditional logic,array traversal,sequence comparison",69.87812805175781
True,3,disable_debugging,"""""""
Advent of Code 2023 Day 3: Mull It Over
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
import re

def parse_input(input_file: str) -> str:
    """"""Parse the puzzle input from file into a string.

    Args:
        input_file: Path to the input file

    Returns:
        The input string.
    """"""
    with open(input_file, 'r') as f:
        return f.read().strip()

def solve_part_one(input_string: str) -> int:
    """"""Solve part one of the puzzle.

    Args:
        input_string: The input string.

    Returns:
        Solution for part one
    """"""
    # Step 3.2: Pattern Matching
    pattern = r""mul\((\d+),(\d+)\)""
    matches = re.findall(pattern, input_string)

    # Step 3.3: Data Validation and Conversion
    valid_tuples: List[Tuple[int, int]] = []
    for match in matches:
        try:
            x = int(match[0])
            y = int(match[1])
            if 1 <= x <= 999 and 1 <= y <= 999:
                valid_tuples.append((x, y))
        except ValueError:
            # Skip if conversion to integer fails
            continue

    # Step 3.4: Multiplication and Summation
    total_sum = 0
    for x, y in valid_tuples:
        total_sum += x * y

    # Step 3.5: Generate Output
    return total_sum

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    input_string = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(input_string)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],2,"string parsing,pattern matching,arithmetic,multiplication,data extraction","regular expressions,string manipulation",44.48735570907593
True,4,disable_debugging,"""""""Advent of Code Day 4: Ceres Search
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a list of lists of characters.

    Args:
        input_file: Path to the input file

    Returns:
        A list of lists representing the grid.
    """"""
    grid: List[List[str]] = []
    with open(input_file, 'r') as f:
        for line in f:
            grid.append(list(line.strip()))
    return grid

def check_horizontal_forward(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word horizontally forward from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if col + len(word) > len(grid[0]):
        return 0
    s = """".join(grid[row][col + i] for i in range(len(word)))
    return 1 if s == word else 0

def check_horizontal_backward(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word horizontally backward from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if col - len(word) + 1 < 0:
        return 0
    s = """".join(grid[row][col - i] for i in range(len(word)))
    return 1 if s == word else 0

def check_vertical_up(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word vertically upwards from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row - len(word) + 1 < 0:
        return 0
    s = """".join(grid[row - i][col] for i in range(len(word)))
    return 1 if s == word else 0

def check_vertical_down(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word vertically downwards from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row + len(word) > len(grid):
        return 0
    s = """".join(grid[row + i][col] for i in range(len(word)))
    return 1 if s == word else 0

def check_diagonal_up_right(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word diagonally up and to the right from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row - len(word) + 1 < 0 or col + len(word) > len(grid[0]):
        return 0
    s = """".join(grid[row - i][col + i] for i in range(len(word)))
    return 1 if s == word else 0

def check_diagonal_up_left(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word diagonally up and to the left from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row - len(word) + 1 < 0 or col - len(word) + 1 < 0:
        return 0
    s = """".join(grid[row - i][col - i] for i in range(len(word)))
    return 1 if s == word else 0

def check_diagonal_down_right(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word diagonally down and to the right from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row + len(word) > len(grid) or col + len(word) > len(grid[0]):
        return 0
    s = """".join(grid[row + i][col + i] for i in range(len(word)))
    return 1 if s == word else 0

def check_diagonal_down_left(grid: List[List[str]], row: int, col: int, word: str) -> int:
    """"""Check for the word diagonally down and to the left from the given cell.

    Args:
        grid: The input grid.
        row: The row index of the starting cell.
        col: The column index of the starting cell.
        word: The word to search for.

    Returns:
        1 if the word is found, 0 otherwise.
    """"""
    if row + len(word) > len(grid) or col - len(word) + 1 < 0:
        return 0
    s = """".join(grid[row + i][col - i] for i in range(len(word)))
    return 1 if s == word else 0

def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: Processed input data

    Returns:
        Solution for part one
    """"""
    xmas = ""XMAS""
    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            count += check_horizontal_forward(grid, r, c, xmas)
            count += check_horizontal_backward(grid, r, c, xmas)
            count += check_vertical_up(grid, r, c, xmas)
            count += check_vertical_down(grid, r, c, xmas)
            count += check_diagonal_up_right(grid, r, c, xmas)
            count += check_diagonal_up_left(grid, r, c, xmas)
            count += check_diagonal_down_right(grid, r, c, xmas)
            count += check_diagonal_down_left(grid, r, c, xmas)
    return count

def main():
    """"""Main function to execute the solution.""""""
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"string search,grid traversal,pattern matching","string matching,grid search,brute force",78.57937121391296
False,5,disable_debugging,,0,[],2,"graph,dependency,topological sort,sorting,parsing,order checking,median","Graph representation of dependencies,Cycle detection,Topological sorting (implicit),List manipulation,String parsing",86.87708616256714
False,6,disable_debugging,,0,[],2,"grid simulation,path finding,agent simulation","state machine,conditional logic,coordinate manipulation",62.38274264335632
True,7,disable_debugging,"""""""
Advent of Code 2023 Day 7: Bridge Repair
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple
import sys
from itertools import product

def parse_input(input_file: str) -> List[Tuple[int, List[int]]]:
    """"""Parse the puzzle input from file into a list of tuples.

    Each tuple contains the target value and a list of numbers for that equation.

    Args:
        input_file: Path to the input file

    Returns:
        A list of tuples, where each tuple contains the target value (integer)
        and a list of numbers (integers) for that equation.
    """"""
    equations = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue  # Skip empty lines
            try:
                target, numbers_str = line.split(':')
                target = int(target.strip())
                numbers = [int(num.strip()) for num in numbers_str.split()]
                equations.append((target, numbers))
            except ValueError:
                print(f""Skipping malformed line: {line}"", file=sys.stderr)
                continue
    return equations


def evaluate_expression(numbers: List[int], operators: List[str]) -> int:
    """"""Evaluate the expression given a list of numbers and operators.

    Evaluates the expression from left to right.

    Args:
        numbers: A list of integers.
        operators: A list of operators ('+' or '*').

    Returns:
        The result of evaluating the expression.
    """"""
    result = numbers[0]
    for i in range(len(operators)):
        if operators[i] == '+':
            result += numbers[i + 1]
        elif operators[i] == '*':
            result *= numbers[i + 1]
    return result


def solve_part_one(equations: List[Tuple[int, List[int]]]) -> int:
    """"""Solve part one of the puzzle.

    Iterates through each equation, generates all possible combinations of operators,
    and evaluates each combination to check if it matches the target value.

    Args:
        equations: A list of tuples, where each tuple contains the target value
            and a list of numbers for that equation.

    Returns:
        The sum of the target values of the equations that can be made true.
    """"""
    total_sum = 0
    for target, numbers in equations:
        num_operators = len(numbers) - 1
        operator_combinations = list(product(['+', '*'], repeat=num_operators))

        for operators in operator_combinations:
            result = evaluate_expression(numbers, list(operators))
            if result == target:
                total_sum += target
                break  # Move to the next equation if a match is found

    return total_sum


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"", file=sys.stderr)
        return

    input_file = sys.argv[1]

    # Parse input
    equations = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(equations)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],3,"arithmetic,expression evaluation,combinatorics,backtracking","recursive search,operator precedence (left-to-right),brute force",59.07149624824524
True,8,disable_debugging,"""""""
Advent of Code 2023 Day 8: Resonant Collinearity
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set
import sys

def parse_input(input_file: str) -> Tuple[List[str], Dict[str, List[Tuple[int, int]]]]:
    """"""Parse the puzzle input from file into grid and antenna positions.

    Args:
        input_file: Path to the input file

    Returns:
        A tuple containing:
            - grid (list of strings): The grid representation.
            - antenna_positions (dictionary): Antenna positions by frequency.
    """"""
    grid: List[str] = []
    antenna_positions: Dict[str, List[Tuple[int, int]]] = {}

    with open(input_file, 'r') as f:
        for line in f:
            grid.append(line.strip())

    for row in range(len(grid)):
        for col in range(len(grid[row])):
            antenna = grid[row][col]
            if antenna != '.':
                if antenna in antenna_positions:
                    antenna_positions[antenna].append((row, col))
                else:
                    antenna_positions[antenna] = [(row, col)]

    return grid, antenna_positions


def find_antinodes(antenna_positions: Dict[str, List[Tuple[int, int]]], grid: List[str]) -> Set[Tuple[int, int]]:
    """"""Find the unique antinode locations based on antenna positions and grid.

    Args:
        antenna_positions: A dictionary mapping antenna frequencies to their coordinates.
        grid: The grid representation.

    Returns:
        A set of tuples representing the unique antinode locations.
    """"""
    antinode_locations: Set[Tuple[int, int]] = set()
    num_rows = len(grid)
    num_cols = len(grid[0]) if num_rows > 0 else 0

    for frequency, antennas in antenna_positions.items():
        for i in range(len(antennas)):
            for j in range(i + 1, len(antennas)):
                antenna1_row, antenna1_col = antennas[i]
                antenna2_row, antenna2_col = antennas[j]

                # Calculate the two potential antinode locations
                n1_row = 2 * antenna1_row - antenna2_row
                n1_col = 2 * antenna1_col - antenna2_col
                n2_row = 2 * antenna2_row - antenna1_row
                n2_col = 2 * antenna2_col - antenna1_col

                # Check if the antinode locations are within the bounds of the grid
                if 0 <= n1_row < num_rows and 0 <= n1_col < num_cols:
                    antinode_locations.add((n1_row, n1_col))
                if 0 <= n2_row < num_rows and 0 <= n2_col < num_cols:
                    antinode_locations.add((n2_row, n2_col))

    return antinode_locations


def main():
    """"""Main function to solve the puzzle.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    grid, antenna_positions = parse_input(input_file)

    # Find antinodes
    antinode_locations = find_antinodes(antenna_positions, grid)

    # Generate output
    print(len(antinode_locations))

if __name__ == ""__main__"":
    main()
",0,[],3,"grid,antenna,antinode,collinearity,distance,frequency,signal,coordinates","geometry,coordinate geometry,distance calculation,collinearity check,grid traversal",105.66134142875671
False,9,disable_debugging,,0,[],1,"string manipulation,simulation,checksum,disk compaction","parsing,simulation,arithmetic",74.06837868690491
True,10,disable_debugging,"""""""
Advent of Code 2023 Day 10: Hoof It
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set
import sys
from collections import deque

def parse_input(input_file: str) -> List[List[int]]:
    """"""Parse the puzzle input from file into a 2D list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list of integers representing the topographic map.
    """"""
    grid: List[List[int]] = []
    with open(input_file, 'r') as f:
        for line in f:
            row: List[int] = [int(char) for char in line.strip()]
            grid.append(row)
    return grid


def identify_trailheads(grid: List[List[int]]) -> List[Tuple[int, int]]:
    """"""Find all positions with height 0 in the grid.

    Args:
        grid: A 2D list of integers representing the topographic map.

    Returns:
        A list of tuples, where each tuple represents the (row, col) coordinates of a trailhead.
    """"""
    trailheads: List[Tuple[int, int]] = []
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            if grid[row][col] == 0:
                trailheads.append((row, col))
    return trailheads


def is_valid(row: int, col: int, grid: List[List[int]]) -> bool:
    """"""Check if a position is within the grid boundaries.

    Args:
        row: The row index.
        col: The column index.
        grid: The 2D list representing the grid.

    Returns:
        True if the position is within the grid boundaries, False otherwise.
    """"""
    num_rows = len(grid)
    num_cols = len(grid[0]) if num_rows > 0 else 0  # Handle empty grid case
    return 0 <= row < num_rows and 0 <= col < num_cols


def calculate_trailhead_score(grid: List[List[int]], trailhead: Tuple[int, int]) -> int:
    """"""Calculate the score of a single trailhead.

    Args:
        grid: The 2D list representing the grid.
        trailhead: A tuple representing the (row, col) coordinates of the trailhead.

    Returns:
        The score of the trailhead (number of reachable 9-height positions).
    """"""
    row, col = trailhead
    visited: Set[Tuple[int, int]] = set()
    queue: deque[Tuple[int, int, int]] = deque([(row, col, 0)])  # (row, col, height)
    trailhead_score = 0

    while queue:
        curr_row, curr_col, curr_height = queue.popleft()

        if (curr_row, curr_col) in visited:
            continue

        visited.add((curr_row, curr_col))

        if curr_height == 9:
            trailhead_score += 1
            continue

        # Explore neighbors (up, down, left, right)
        neighbors = [
            (curr_row - 1, curr_col),
            (curr_row + 1, curr_col),
            (curr_row, curr_col - 1),
            (curr_row, curr_col + 1),
        ]

        for new_row, new_col in neighbors:
            if is_valid(new_row, new_col, grid):
                if grid[new_row][new_col] == curr_height + 1:
                    queue.append((new_row, new_col, curr_height + 1))

    return trailhead_score


def solve_part_one(grid: List[List[int]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: The 2D list representing the topographic map.

    Returns:
        The sum of the scores of all trailheads.
    """"""
    trailheads = identify_trailheads(grid)
    total_score = 0
    for trailhead in trailheads:
        total_score += calculate_trailhead_score(grid, trailhead)
    return total_score


def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)

    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],1,"grid traversal,pathfinding,heightmap,trailhead,reachability","breadth-first search,depth-first search,graph traversal,coordinate systems",53.93092727661133
True,11,disable_debugging,"""""""
Advent of Code 2023 Day 11: Plutonian Pebbles
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        List[int]: A list of integers representing the initial stone arrangement.
    """"""
    with open(input_file, 'r') as f:
        line = f.readline().strip()
        stones = [int(x) for x in line.split()]
    return stones


def apply_rules(stones: List[int]) -> List[int]:
    """"""Applies the rules to each stone in the current arrangement simultaneously.

    Args:
        stones: List[int] representing the current stone arrangement.

    Returns:
        List[int]: The next stone arrangement after applying the rules.
    """"""
    next_stones: List[int] = []
    for stone in stones:
        if stone == 0:
            next_stones.append(1)
        else:
            stone_str = str(stone)
            if len(stone_str) % 2 == 0:
                mid = len(stone_str) // 2
                left = int(stone_str[:mid])
                right = int(stone_str[mid:])
                next_stones.append(left)
                next_stones.append(right)
            else:
                next_stones.append(stone * 2024)
    return next_stones


def solve_part_one(stones: List[int]) -> int:
    """"""Solves part one of the puzzle by simulating the stone evolution for 25 blinks.

    Args:
        stones: List[int] representing the initial stone arrangement.

    Returns:
        int: The total number of stones after 25 blinks.
    """"""
    for _ in range(25):
        stones = apply_rules(stones)
    return len(stones)


def main():
    """"""Main function to execute the solution.

    Parses the input, simulates the stone evolution, and prints the final stone count.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    stones = parse_input(input_file)
    final_count = solve_part_one(stones)
    print(final_count)


if __name__ == ""__main__"":
    main()
",0,[],2,"simulation,number transformation,sequence manipulation","iteration,conditional logic,string manipulation,integer arithmetic",72.244220495224
True,12,disable_debugging,"""""""
Advent of Code 2023 Day 12: Garden Groups
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re

def parse_input(input_file: str) -> List[List[str]]:
    """"""Parse the puzzle input from file into a 2D list of strings.

    Args:
        input_file: Path to the input file

    Returns:
        A 2D list representing the grid.
    """"""
    grid = []
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                grid.append(list(line))
    return grid

def dfs(grid: List[List[str]], row: int, col: int, plant_type: str, visited: Set[Tuple[int, int]]) -> Set[Tuple[int, int]]:
    """"""Perform Depth-First Search to identify a connected region.

    Args:
        grid: The 2D grid representing the garden map.
        row: The starting row index.
        col: The starting column index.
        plant_type: The plant type of the region being explored.
        visited: A set to keep track of visited cells.

    Returns:
        A set containing the (row, col) coordinates of all cells in the region.
    """"""
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or (row, col) in visited or grid[row][col] != plant_type:
        return set()

    visited.add((row, col))
    region = {(row, col)}

    region = region.union(dfs(grid, row + 1, col, plant_type, visited))
    region = region.union(dfs(grid, row - 1, col, plant_type, visited))
    region = region.union(dfs(grid, row, col + 1, plant_type, visited))
    region = region.union(dfs(grid, row, col - 1, plant_type, visited))

    return region

def identify_regions(grid: List[List[str]]) -> List[Set[Tuple[int, int]]]:
    """"""Identify all connected regions in the grid.

    Args:
        grid: The 2D grid representing the garden map.

    Returns:
        A list of sets, where each set represents a region and contains the
        coordinates of the cells in that region.
    """"""
    regions = []
    visited = set()
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if (row, col) not in visited:
                region = dfs(grid, row, col, grid[row][col], visited)
                if region:
                    regions.append(region)
    return regions

def calculate_perimeter(grid: List[List[str]], region: Set[Tuple[int, int]]) -> int:
    """"""Calculate the perimeter of a region.

    Args:
        grid: The 2D grid representing the garden map.
        region: A set of cell coordinates representing the region.

    Returns:
        The perimeter of the region.
    """"""
    perimeter = 0
    for row, col in region:
        # Check up
        if row == 0 or (row - 1, col) not in region:
            perimeter += 1
        # Check down
        if row == len(grid) - 1 or (row + 1, col) not in region:
            perimeter += 1
        # Check left
        if col == 0 or (row, col - 1) not in region:
            perimeter += 1
        # Check right
        if col == len(grid[0]) - 1 or (row, col + 1) not in region:
            perimeter += 1
    return perimeter

def solve_part_one(grid: List[List[str]]) -> int:
    """"""Solve part one of the puzzle.

    Args:
        grid: Processed input data

    Returns:
        Solution for part one
    """"""
    regions = identify_regions(grid)
    total_cost = 0
    for region in regions:
        area = len(region)
        perimeter = calculate_perimeter(grid, region)
        cost = area * perimeter
        total_cost += cost
    return total_cost

def main():
    # Check command line arguments
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    parsed_data = parse_input(input_file)

    # Solve part one
    part_one_solution = solve_part_one(parsed_data)
    # ONLY PRINT THE RESULT, NO OTHER TEXT
    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],2,"grid,region,area,perimeter,connected components,string manipulation","depth-first search,breadth-first search,graph traversal,flood fill",88.62782621383667
False,13,disable_debugging,,0,[],2,"optimization,linear equations,claw machine","Diophantine equations,integer programming,brute force,linear algebra",93.3482096195221
False,14,disable_debugging,,0,[],2,"simulation,grid,robot motion,wrapping,quadrants,product,coordinate system","modular arithmetic,geometry,iteration,conditional logic",60.96604537963867
False,15,disable_debugging,,0,[],3,"robot simulation,warehouse,box pushing,grid,GPS coordinates","grid traversal,simulation,conditional logic",84.95077586174011
False,16,disable_debugging,,0,[],3,"maze,pathfinding,minimum cost,grid,reindeer","graph traversal,shortest path,breadth-first search,A*,dynamic programming",165.12064623832703
False,17,disable_debugging,,0,[],1,"computer simulation,instruction set,program execution,registers,bitwise operations,modulo,integer division","interpreter,state machine,assembly language,conditional jump",67.25027632713318
True,18,disable_debugging,"""""""
Advent of Code 2023 Day 18: RAM Run
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Tuple, Set, Deque
import sys
from collections import deque

def parse_input(input_file: str) -> Set[Tuple[int, int]]:
    """"""Parse the puzzle input from file into a set of corrupted coordinates.

    Args:
        input_file: Path to the input file

    Returns:
        A set containing tuples (x, y) of corrupted coordinates.
    """"""
    corrupted_coordinates: Set[Tuple[int, int]] = set()
    with open(input_file, 'r') as f:
        for i, line in enumerate(f):
            if i >= 1024:
                break
            x, y = map(int, line.strip().split(','))
            corrupted_coordinates.add((x, y))
    return corrupted_coordinates

def solve_part_one(corrupted_coordinates: Set[Tuple[int, int]]) -> int:
    """"""Solve part one of the puzzle using Breadth-First Search (BFS).

    Args:
        corrupted_coordinates: A set of tuples representing corrupted coordinates.

    Returns:
        The minimum number of steps to reach (70, 70) from (0, 0), or -1 if no path is found.
    """"""

    queue: Deque[Tuple[Tuple[int, int], int]] = deque([((0, 0), 0)])
    visited: Set[Tuple[int, int]] = set([(0, 0)])

    while queue:
        (x, y), steps = queue.popleft()

        if (x, y) == (70, 70):
            return steps

        # Possible moves: up, down, left, right
        moves = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        for dx, dy in moves:
            next_x, next_y = x + dx, y + dy

            # Check boundaries, corrupted status, and visited status
            if (0 <= next_x <= 70 and 0 <= next_y <= 70 and
                    (next_x, next_y) not in corrupted_coordinates and
                    (next_x, next_y) not in visited):

                queue.append(((next_x, next_y), steps + 1))
                visited.add((next_x, next_y))

    return -1  # No path found

def main():
    """"""Main function to parse input, solve the puzzle, and print the result.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    corrupted_coordinates = parse_input(input_file)
    part_one_solution = solve_part_one(corrupted_coordinates)

    print(part_one_solution)

if __name__ == ""__main__"":
    main()
",0,[],0,"shortest path,grid traversal,pathfinding,simulation,2D grid,coordinate system","breadth-first search,A*,graph traversal,state space search",39.4589569568634
True,19,disable_debugging,"""""""
Advent of Code 2023 Day 19: Linen Layout
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List, Dict, Tuple, Set, Optional
import sys
from collections import defaultdict, deque
import re


def parse_input(input_file: str) -> Tuple[List[str], List[str]]:
    """"""Parse the puzzle input from file into towel patterns and designs.

    Args:
        input_file: Path to the input file

    Returns:
        Tuple containing lists of towel patterns and designs.
    """"""
    with open(input_file, 'r') as f:
        input_str = f.read().strip()

    parts = input_str.split('\n\n')
    patterns = parts[0].split(', ')
    designs = parts[1].splitlines()

    return patterns, designs


def is_design_possible(design: str, patterns: List[str]) -> bool:
    """"""Checks if a design can be created from the given patterns using dynamic programming.

    Args:
        design: The design string to check.
        patterns: A list of available towel patterns.

    Returns:
        True if the design is possible, False otherwise.
    """"""
    dp = [False] * (len(design) + 1)
    dp[0] = True

    for i in range(1, len(design) + 1):
        for pattern in patterns:
            if len(pattern) <= i and design[i - len(pattern):i] == pattern and dp[i - len(pattern)]:
                dp[i] = True
                break

    return dp[len(design)]


def solve_part_one(patterns: List[str], designs: List[str]) -> int:
    """"""Solve part one of the puzzle by counting possible designs.

    Args:
        patterns: List of available towel patterns.
        designs: List of desired designs.

    Returns:
        The number of designs that can be formed from the patterns.
    """"""
    count = 0
    for design in designs:
        if is_design_possible(design, patterns):
            count += 1
    return count


def main():
    """"""Main function to execute the solution.

    Parses the input, solves part one, and prints the result.
    """"""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]
    patterns, designs = parse_input(input_file)

    part_one_solution = solve_part_one(patterns, designs)
    print(part_one_solution)


if __name__ == ""__main__"":
    main()
",0,[],2,"string matching,string concatenation,pattern matching,towel arrangement","dynamic programming,string decomposition",52.09864115715027
False,20,disable_debugging,,0,[],1,"grid traversal,pathfinding,optimization,cheating,shortest path","breadth-first search,graph traversal,dynamic programming (potentially),combinatorial search",91.42794299125671
False,21,disable_debugging,,0,[],3,"shortest path,robot control,keypad,string manipulation,optimization","graph traversal,breadth-first search,state space search",98.67991948127747
True,22,disable_debugging,"""""""
Advent of Code 2023 Day 22: Monkey Market
Solution implementation based on the provided plan.

Usage: python3 solution.py [input_file]
""""""
from typing import List
import sys

def parse_input(input_file: str) -> List[int]:
    """"""Parse the puzzle input from file into a list of integers.

    Args:
        input_file: Path to the input file

    Returns:
        A list of integers representing the initial secret numbers of the buyers.
    """"""
    initial_secrets = []
    with open(input_file, 'r') as f:
        for line in f:
            initial_secrets.append(int(line.strip()))
    return initial_secrets


def simulate_secret_numbers(initial_secrets: List[int]) -> List[int]:
    """"""Simulate the generation of 2000 new secret numbers for each buyer.

    Args:
        initial_secrets: A list of integers representing the initial secret numbers.

    Returns:
        A list of integers, where each integer is the 2000th secret number for each buyer.
    """"""
    final_secrets = []
    for initial_secret in initial_secrets:
        secret_number = initial_secret
        for _ in range(2000):
            secret_number ^= (secret_number * 64)
            secret_number %= 16777216
            secret_number ^= (secret_number // 32)
            secret_number %= 16777216
            secret_number ^= (secret_number * 2048)
            secret_number %= 16777216
        final_secrets.append(secret_number)
    return final_secrets


def calculate_sum(secrets: List[int]) -> int:
    """"""Calculate the sum of the secret numbers.

    Args:
        secrets: A list of integers.

    Returns:
        The sum of the integers in the list.
    """"""
    total_sum = 0
    for secret in secrets:
        total_sum += secret
    return total_sum


def main():
    """"""Main function to execute the solution.""""""
    if len(sys.argv) < 2:
        print(""Usage: python3 solution.py [input_file]"")
        return

    input_file = sys.argv[1]

    # Parse input
    initial_secrets = parse_input(input_file)

    # Simulate secret number generation
    final_secrets = simulate_secret_numbers(initial_secrets)

    # Calculate the sum
    total_sum = calculate_sum(final_secrets)

    # Print the result
    print(total_sum)

if __name__ == ""__main__"":
    main()
",0,[],1,"pseudorandom number generation,simulation,bitwise XOR,modulo operation","numerical simulation,algorithm implementation",46.72474551200867
False,23,disable_debugging,,0,[],2,"graph,network,set,connected components,string manipulation","graph traversal,set theory,string matching",50.44819641113281
False,24,disable_debugging,,0,[],3,"boolean logic,circuit simulation,bitwise operations,parsing,data dependency","topological sort,graph traversal,event-driven simulation",81.93970370292664
False,25,disable_debugging,,0,[],2,"string processing,pattern matching,height calculation,combinatorial search","parsing,iteration,conditional logic",52.019423961639404
